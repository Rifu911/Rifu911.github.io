<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>21-04-14</title>
    <url>/2021/04/14/21-04-14/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 问下博主?" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="7cf43550b53d30c10e3e2001b3ccb17ab0923292cb7682faa57b59380a525e01">246b2b0d6e3812f1e6bfe99c8f54ff1595c62824439e11fccf7c3c89d4e1e78591f7e52c4125a4b5edc9f63c80575087308d4728e6c7d29b9daec136a5a5f2ae7dba800187e1c184d181b85c4058b4bacf17e1370313cd684165c53425d72550daa1c6864b8fbeaecea7194a8602be7e6942c6601973317b513740eadd170f6bd15aa0ea6622441874ca5690a5a32f1114473d72ab77cc36c4636d24b1d3ae2d7792b243320e2d7eaa31f059bdf61f6b334f051748afd460a985008222c660a70788fd1915f453df785ede2eea621decf707844e732f46b92ca1ea71c12e45b152a39a66947ffaf38b1b5d35aff33d72acba8d747fb25a6963f9f2cef65611696faa5a9f5c1d6910b7350b5fbe94c0a03987f5006c0eae59d580ad76f500f222ea2741c5a29428f73f92a7c84657467941e9b515e36d4a00e8e4275f01a6126bbbc8214b4243d42affe99ae36fe81c6ac788e934fb954aeb4f5d3c609758aad836b2efca8a29041d7a33d87abc597ea29c07454e7d9bd0f7c222d016ac2fc8aab0aefa909b4a7a1ed571e8bac465657396d4ffc3d721c4b608de560a9c84b59740ad8584edf3416e45e0161b4c2f6eea40ac44e332792e92e5af6a3661add06b053d643f8f956ccbb7c7068a8d2d9c815b2287b9e2c13a6997b008df54db85e55f89ef3b99d1033f4bd63ea47ce93f781cdcf30fd77ddf7a25b723d2516bdf0443a41323bab18d9f4cac161ded41bf194f7b0f10a2ee067f99a0c61408cdcb83bc07657a70b3612db799853fed9f119d5d371b54402dbef53c229a5b4e135e133a0bb9eaee780c954efa9e1b64af55a4e46d2b5ca564b444a2577678fdeffbffd9ff97cccad8ab7deb9d2b327c3721241f7d3097a5dbf95828571ceaca0369cf932228d7823d7b9c683db77789c49df5d7ddbbe7c9248fadcaae6c58750e121a68c867e3ff0662e8c5876e5013dc77a088301d202893b3d8ee7035452128a3048a24b5276905fb3e9b1df050600d05ad2a23ef56c51fb94daecb89b8bb160835fe468198659eadb9d7c3ea8c628d3caf6824d41d91eb5a92fde1c579564717d9d60007a28bb747a89191807e899dc5f4351c05b528536dc949343976186fd929de6b56cf06fac478a42ea74b7d72f64cb9bc13ba33d39b66cd823afc4eae3b24057330cc861d2d1610bd506226a4edca7921a39398e3bb918e42278765227f2c6df96c8c4874a6064e065301a4cf1f53ec85f5a35609a3622ca7bbbf3a9c9dab54d028818d8e43c210bd9f4d17e3da515855ed77573479ca8ce2ecf9768d3bd6c32fda67c9fe1afb906f1b5c5e710da9904165bf046ecbd53d3b1b28fd9d9aa3d212809bd26b5ecdf38ccc9a4ce14a84830b825063e53f057b7e063d38c7202f4d20bb3ca444cf68b79b6ce28d9aa1f8846c17ab5e69ee2545cc4a4984ef8985269b8c6df0651ef6fc277ddfcc2c38132536d2bbc30e343cc0a1315d9171be61f71e93297f4202e38b39a01111b1ea6bf73d943a04847c587cb04f0a5893e1f61801905419c12b7e021297be6c7ea5ac1ad06dd8850a5eb125c78f89b5c3a5b3ce586fc69fa9770870216446f57af4be5409ae7454e9edb047341b1c9f706b7716436dbd280470be3df3608d69de9d58bcf5238c90f702425c9ac0651fa6c6f8669fc09c7c9109faef8566a2add4322ff3586a0371a23a88bb80e803575e038a16eebe35b229c4721f62ff7d23e7b2d5856e6cdb4ff10aff33f66d4850c3da93ba932f1f2be88a2b18d4f52996c18e0f4e57b741db76223b3534c1fbebb50e0c2da4b3ad364e01c49d4989b2aa9e05835b191c0b242062ca8d232443135024d3727dad32cd62b3de1e51e26b3784ec93da2b77ba191bcd6ef3071357372c38873593e1c834ff8d9347bc3c58363fc81e061ea045cc2236cdb4ac716bb9310dd128235b7b9a26b80f1b36f140eef0f3373021a17c039d2a2b9bac1adfc04b774337439b6e2a1289f1f17115cec88b98b3fd7cc826d88ad833a4df9b5041581df38d89e14e54afb79786ed1e6a5da74f141769d8c4118c22c44b441bf17bf833777f367fbd2d1f78b643f585f9bea96f7196e64bbe80dbbc9f0c32320db8ee59b63f4780600992f386ff54ac7783d0bc16c7dff827afc2da447267cd7cc8eae07f5c5651c7190495bf37e6842fc0c9257c58e4b7b7a67e899b48cbf606db5b92981ee15e237b74cecd8e997205749610c3654a5007115ce818dda0ca91a1af5343fadb0e9ea084659100db95d25a27d17b111e72e54633467f1a5f3ecc573ceb87ee48ed3cc7b050fd42781a5d1c62e5c6a51fb4c240743ab75c8550592f09fb83</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">点击我输入密码</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Vlog</category>
      </categories>
  </entry>
  <entry>
    <title>Docker</title>
    <url>/2019/09/11/Docker/</url>
    <content><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>Docker是一种容器，它里面可以装载多种软件镜像，并将其放进容器，启动该容器就相当于启动了该软件。</p>
<p>eg:在Docker里面装载了Mysql的镜像，Docker就会为其建立一个容器，而启动该容器就相当于启动了Mysql</p>
<p>docker加速：registry.docker-cn.com/library/</p>
<span id="more"></span>

<h3 id="二、安装Docker-Centos7"><a href="#二、安装Docker-Centos7" class="headerlink" title="二、安装Docker(Centos7)"></a>二、安装Docker(Centos7)</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install docker</span><br></pre></td></tr></table></figure>



<h3 id="三、常用操作指令"><a href="#三、常用操作指令" class="headerlink" title="三、常用操作指令"></a>三、常用操作指令</h3><p>1）、启动Docker :</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service docker start</span><br></pre></td></tr></table></figure>

<p>2）、设置开机自启动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure>

<p>3）、查看Docker的公共Repository可以安装的镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker search mysql</span><br></pre></td></tr></table></figure>

<p>4）、下载某个镜像(tag指定要安装的版本号)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull mysql:tag</span><br></pre></td></tr></table></figure>

<p>5）、查看docker已安装的镜像​    </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>

<p>6）、删除镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rmi image-id</span><br></pre></td></tr></table></figure>

<p>7）、运行镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name mytomcat -d tomcat:tag</span><br></pre></td></tr></table></figure>

<pre><code>    (当出现一串字符，表示运行成功)
</code></pre>
<p>8）、查看当前那些镜像在运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>

<p>9）、停止运行中的容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker stop containerId(或者自己起的容器名字)</span><br></pre></td></tr></table></figure>

<p>10）、查看所有容器（镜像安装后称为容器）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps  -a </span><br></pre></td></tr></table></figure>

<p>11）、启动容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker start containerId</span><br></pre></td></tr></table></figure>

<p>12）、删除指定的容器(该容器需要在停止状态)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rm containerId</span><br></pre></td></tr></table></figure>

<p>13）、带端口映射的启动容器(-d     代表后台运行)​    </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p  docker.port:container.port   tomcat:tag</span><br><span class="line"></span><br><span class="line">eg:docker run -d -p  8888:8080   tomcat:tag    (将主机的8888端口映射到容器的8080端口)</span><br></pre></td></tr></table></figure>

<p>14）、查看容器的日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker logs container-name/container-id</span><br></pre></td></tr></table></figure>



<p>====注意：一个镜像可以启动为多个端口，在启动的时候指定不同的名字即可====</p>
<h3 id="四、docker安装mysql示例"><a href="#四、docker安装mysql示例" class="headerlink" title="四、docker安装mysql示例"></a>四、docker安装mysql示例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1.docker pull mysql</span><br><span class="line"></span><br><span class="line">2.docker run --name mysql-01 -e  MYSQL_ROOT_PASSWORD=528428 -d mysql:tag</span><br></pre></td></tr></table></figure>



<blockquote>
<p>错误示例：没有映射端口，无法正常使用mysql</p>
<p>正确的启动方式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -p 3306:3306 --name mysql-01 -e  MYSQL_ROOT_PASSWORD=528428 -d mysql:tag</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>高级一点的启动方式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name some-mysql -v /my/custom:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag</span><br><span class="line"></span><br><span class="line">将主机的/my/custom文件挂载到/etc/mysql/conf.d所在的文件夹里面</span><br><span class="line">(两个配置文件是合并的关系)</span><br></pre></td></tr></table></figure></blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo面试题集合</title>
    <url>/2021/04/13/Dubbo%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<p>文章目录</p>
<ul>
<li>基础知识<ul>
<li>为什么要用 Dubbo？</li>
<li>Dubbo 是什么？</li>
<li>Dubbo 的使用场景有哪些？</li>
<li>Dubbo 核心功能有哪些？</li>
</ul>
</li>
</ul>
<span id="more"></span>

<ul>
<li>架构设计<ul>
<li>Dubbo 核心组件有哪些？</li>
<li>Dubbo 服务器注册与发现的流程？</li>
<li>Dubbo 的整体架构设计有哪些分层?</li>
<li>Dubbo Monitor 实现原理？</li>
</ul>
</li>
<li>分布式框架<ul>
<li>Dubbo 类似的分布式框架还有哪些？</li>
<li>Dubbo 和 Spring Cloud 有什么关系？</li>
<li>Dubbo 和 Spring Cloud 有什么哪些区别？</li>
<li>Dubbo 和 Dubbox 之间的区别？</li>
</ul>
</li>
<li>注册中心<ul>
<li>Dubbo 有哪些注册中心？</li>
<li>Dubbo 的注册中心集群挂掉，发布者和订阅者之间还能通信么？</li>
</ul>
</li>
<li>集群<ul>
<li>Dubbo集群提供了哪些<a href="https://cloud.tencent.com/product/clb?from=10680">负载均衡</a>策略？</li>
<li>Dubbo的集群容错方案有哪些？</li>
</ul>
</li>
<li>配置<ul>
<li>Dubbo 配置文件是如何加载到 Spring 中的？</li>
<li>说说核心的配置有哪些？</li>
<li>Dubbo 超时设置有哪些方式？</li>
<li>服务调用超时会怎么样？</li>
</ul>
</li>
<li>通信协议<ul>
<li>Dubbo 使用的是什么通信框架?</li>
<li>Dubbo 支持哪些协议，它们的优缺点有哪些？</li>
</ul>
</li>
<li>设计模式<ul>
<li>Dubbo 用到哪些设计模式？</li>
</ul>
</li>
<li>运维管理<ul>
<li>服务上线怎么兼容旧版本？</li>
<li>Dubbo telnet 命令能做什么？</li>
<li>Dubbo 支持服务降级吗？</li>
<li>Dubbo 如何优雅停机？</li>
</ul>
</li>
<li>SPI<ul>
<li>Dubbo SPI 和 Java SPI 区别？</li>
</ul>
</li>
<li>其他<ul>
<li>Dubbo 支持分布式事务吗？</li>
<li>Dubbo 可以对结果进行缓存吗？</li>
<li>Dubbo 必须依赖的包有哪些？</li>
<li>Dubbo 支持哪些序列化方式？</li>
<li>Dubbo 在安全方面有哪些措施？</li>
<li>服务调用是阻塞的吗？</li>
<li>服务提供者能实现失效踢出是什么原理？</li>
<li>同一个服务多个注册的情况下可以直连某一个服务吗？</li>
<li>Dubbo 服务降级，失败重试怎么做？</li>
<li>Dubbo 使用过程中都遇到了些什么问题？</li>
</ul>
</li>
<li>RPC<ul>
<li>为什么要有RPC</li>
<li>什么是RPC</li>
<li>PRC架构组件</li>
<li>RPC和SOA、SOAP、REST的区别</li>
<li>RPC框架需要解决的问题？</li>
<li>RPC的实现基础？</li>
<li>RPC使用了哪些关键技术？</li>
<li>主流RPC框架有哪些</li>
<li>RPC的实现原理架构图</li>
</ul>
</li>
</ul>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="为什么要用-Dubbo？"><a href="#为什么要用-Dubbo？" class="headerlink" title="为什么要用 Dubbo？"></a>为什么要用 Dubbo？</h3><p>随着服务化的进一步发展，服务越来越多，服务之间的调用和依赖关系也越来越复杂，诞生了面向服务的架构体系(SOA)，也因此衍生出了一系列相应的技术，如对服务提供、服务调用、连接处理、通信协议、序列化方式、服务发现、服务路由、日志输出等行为进行封装的服务框架。就这样为分布式系统的服务治理框架就出现了，Dubbo 也就这样产生了。</p>
<h3 id="Dubbo-是什么？"><a href="#Dubbo-是什么？" class="headerlink" title="Dubbo 是什么？"></a>Dubbo 是什么？</h3><p>Dubbo 是一款高性能、轻量级的开源 RPC 框架，提供服务自动注册、自动发现等高效服务治理方案， 可以和 Spring 框架无缝集成。</p>
<h3 id="Dubbo-的使用场景有哪些？"><a href="#Dubbo-的使用场景有哪些？" class="headerlink" title="Dubbo 的使用场景有哪些？"></a>Dubbo 的使用场景有哪些？</h3><ul>
<li>透明化的远程方法调用：就像调用本地方法一样调用远程方法，只需简单配置，没有任何API侵入。</li>
<li>软负载均衡及容错机制：可在内网替代 F5 等硬件负载均衡器，降低成本，减少单点。</li>
<li>服务自动注册与发现：不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。</li>
</ul>
<h3 id="Dubbo-核心功能有哪些？"><a href="#Dubbo-核心功能有哪些？" class="headerlink" title="Dubbo 核心功能有哪些？"></a>Dubbo 核心功能有哪些？</h3><ul>
<li>Remoting：网络通信框架，提供对多种NIO框架抽象封装，包括“同步转异步”和“请求-响应”模式的信息交换方式。</li>
<li>Cluster：服务框架，提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。</li>
<li>Registry：服务注册，基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。</li>
</ul>
<h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><h3 id="Dubbo-核心组件有哪些？"><a href="#Dubbo-核心组件有哪些？" class="headerlink" title="Dubbo 核心组件有哪些？"></a>Dubbo 核心组件有哪些？</h3><p><img src="https://img-blog.csdnimg.cn/20210321130058459.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5nbGlmdTUyMA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<ul>
<li>Provider：暴露服务的服务提供方</li>
<li>Consumer：调用远程服务消费方</li>
<li>Registry：服务注册与发现注册中心</li>
<li>Monitor：监控中心和访问调用统计</li>
<li>Container：服务运行容器</li>
</ul>
<h3 id="Dubbo-服务器注册与发现的流程？"><a href="#Dubbo-服务器注册与发现的流程？" class="headerlink" title="Dubbo 服务器注册与发现的流程？"></a>Dubbo 服务器注册与发现的流程？</h3><p><strong>服务容器Container</strong>负责启动，加载，运行服务提供者。</p>
<p><strong>服务提供者Provider</strong>在启动时，向注册中心注册自己提供的服务。</p>
<p><strong>服务消费者Consumer</strong>在启动时，向注册中心订阅自己所需的服务。</p>
<p><strong>注册中心Registry</strong>返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</p>
<p><strong>服务消费者Consumer</strong>，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</p>
<p><strong>服务消费者Consumer和提供者Provider</strong>，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心Monitor。</p>
<h3 id="Dubbo-的整体架构设计有哪些分层"><a href="#Dubbo-的整体架构设计有哪些分层" class="headerlink" title="Dubbo 的整体架构设计有哪些分层?"></a>Dubbo 的整体架构设计有哪些分层?</h3><p><img src="https://img-blog.csdnimg.cn/20210321130237421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5nbGlmdTUyMA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p><strong>接口服务层（Service）</strong>：该层与业务逻辑相关，根据 provider 和 consumer 的业务设计对应的接口和实现</p>
<p><strong>配置层（Config）</strong>：对外配置接口，以 ServiceConfig 和 ReferenceConfig 为中心</p>
<p><strong>服务代理层（Proxy）</strong>：服务接口透明代理，生成服务的客户端 Stub 和 服务端的 Skeleton，以 ServiceProxy 为中心，扩展接口为 ProxyFactory</p>
<p><strong>服务注册层（Registry）</strong>：封装服务地址的注册和发现，以服务 URL 为中心，扩展接口为 RegistryFactory、Registry、RegistryService</p>
<p><strong>路由层（Cluster）</strong>：封装多个提供者的路由和负载均衡，并桥接注册中心，以Invoker 为中心，扩展接口为 Cluster、Directory、Router 和 LoadBlancce</p>
<p><strong>监控层（Monitor）</strong>：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory、Monitor 和 MonitorService</p>
<p><strong>远程调用层（Protocal）</strong>：封装 RPC 调用，以 Invocation 和 Result 为中心，扩展接口为 Protocal、Invoker 和 Exporter</p>
<p><strong>信息交换层（Exchange）</strong>：封装请求响应模式，同步转异步。以 Request 和Response 为中心，扩展接口为 Exchanger、ExchangeChannel、ExchangeClient 和 ExchangeServer</p>
<p><strong>网络 传输 层（Transport）</strong>：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel、Transporter、Client、Server 和 Codec</p>
<p><strong>数据序列化层（Serialize）</strong>：可复用的一些工具，扩展接口为 Serialization、ObjectInput、ObjectOutput 和 ThreadPool</p>
<h3 id="Dubbo-Monitor-实现原理？"><a href="#Dubbo-Monitor-实现原理？" class="headerlink" title="Dubbo Monitor 实现原理？"></a>Dubbo Monitor 实现原理？</h3><p>Consumer 端在发起调用之前会先走 filter 链；provider 端在接收到请求时也是先走 filter 链，然后才进行真正的业务逻辑处理。默认情况下，在 consumer 和 provider 的 filter 链中都会有 Monitorfilter。</p>
<p>1、MonitorFilter 向 DubboMonitor 发送数据</p>
<p>2、DubboMonitor 将数据进行聚合后（默认聚合 1min 中的统计数据）暂存到ConcurrentMap&lt;Statistics, AtomicReference&gt; statisticsMap，然后使用一个含有 3 个线程（线程名字：DubboMonitorSendTimer）的线程池每隔 1min 钟，调用 SimpleMonitorService 遍历发送 statisticsMap 中的统计数据，每发送完毕一个，就重置当前的 Statistics 的 AtomicReference</p>
<p>3、SimpleMonitorService 将这些聚合数据塞入 BlockingQueue queue 中（队列大写为 100000）</p>
<p>4、SimpleMonitorService 使用一个后台线程（线程名为：DubboMonitorAsyncWriteLogThread）将 queue 中的数据写入文件（该线程以死循环的形式来写）</p>
<p>5、SimpleMonitorService 还会使用一个含有 1 个线程（线程名字：DubboMonitorTimer）的线程池每隔 5min 钟，将文件中的统计数据画成图表</p>
<h2 id="分布式框架"><a href="#分布式框架" class="headerlink" title="分布式框架"></a>分布式框架</h2><h3 id="Dubbo-类似的分布式框架还有哪些？"><a href="#Dubbo-类似的分布式框架还有哪些？" class="headerlink" title="Dubbo 类似的分布式框架还有哪些？"></a>Dubbo 类似的分布式框架还有哪些？</h3><p>比较著名的就是 Spring Cloud。</p>
<h3 id="Dubbo-和-Spring-Cloud-有什么关系？"><a href="#Dubbo-和-Spring-Cloud-有什么关系？" class="headerlink" title="Dubbo 和 Spring Cloud 有什么关系？"></a>Dubbo 和 Spring Cloud 有什么关系？</h3><p>Dubbo 是 SOA 时代的产物，它的关注点主要在于服务的调用，流量分发、流量监控和熔断。而 Spring Cloud 诞生于微服务架构时代，考虑的是微服务治理的方方面面，另外由于依托了 Spring、Spring Boot 的优势之上，两个框架在开始目标就不一致，Dubbo 定位服务治理、Spring Cloud 是打造一个生态。</p>
<h3 id="Dubbo-和-Spring-Cloud-有什么哪些区别？"><a href="#Dubbo-和-Spring-Cloud-有什么哪些区别？" class="headerlink" title="Dubbo 和 Spring Cloud 有什么哪些区别？"></a>Dubbo 和 Spring Cloud 有什么哪些区别？</h3><p>Dubbo 底层是使用 Netty 这样的 NIO 框架，是基于 TCP 协议传输的，配合以 Hession 序列化完成 RPC 通信。</p>
<p>Spring Cloud 是基于 Http 协议 Rest 接口调用远程过程的通信，相对来说 Http 请求会有更大的报文，占的带宽也会更多。但是 REST 相比 RPC 更为灵活，服务提供方和调用方的依赖只依靠一纸契约，不存在代码级别的强依赖，这在强调快速演化的微服务环境下，显得更为合适，至于注重通信速度还是方便灵活性，具体情况具体考虑。</p>
<h3 id="Dubbo-和-Dubbox-之间的区别？"><a href="#Dubbo-和-Dubbox-之间的区别？" class="headerlink" title="Dubbo 和 Dubbox 之间的区别？"></a>Dubbo 和 Dubbox 之间的区别？</h3><p>Dubbox 是继 Dubbo 停止维护后，当当网基于 Dubbo 做的一个扩展项目，如加了服务可 Restful 调用，更新了开源组件等。</p>
<h2 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h2><h3 id="Dubbo-有哪些注册中心？"><a href="#Dubbo-有哪些注册中心？" class="headerlink" title="Dubbo 有哪些注册中心？"></a>Dubbo 有哪些注册中心？</h3><ul>
<li>Multicast 注册中心：Multicast 注册中心不需要任何中心节点，只要广播地址，就能进行服务注册和发现,基于网络中组播传输实现。</li>
<li>Zookeeper 注册中心：基于分布式协调系统 Zookeeper 实现，采用 Zookeeper 的 watch 机制实现数据变更。</li>
<li><a href="https://cloud.tencent.com/product/crs?from=10680">Redis</a> 注册中心：基于 Redis 实现，采用 key/map 存储，key 存储服务名和类型，map 中 key 存储服务 url，value 服务过期时间。基于 Redis 的发布/订阅模式通知数据变更。</li>
<li>Simple 注册中心。</li>
</ul>
<p>推荐使用 Zookeeper 作为注册中心</p>
<h3 id="Dubbo-的注册中心集群挂掉，发布者和订阅者之间还能通信么？"><a href="#Dubbo-的注册中心集群挂掉，发布者和订阅者之间还能通信么？" class="headerlink" title="Dubbo 的注册中心集群挂掉，发布者和订阅者之间还能通信么？"></a>Dubbo 的注册中心集群挂掉，发布者和订阅者之间还能通信么？</h3><p>可以通讯。启动 Dubbo 时，消费者会从 Zookeeper 拉取注册的生产者的地址接口等数据，缓存在本地。每次调用时，按照本地存储的地址进行调用。</p>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><h3 id="Dubbo集群提供了哪些负载均衡策略？"><a href="#Dubbo集群提供了哪些负载均衡策略？" class="headerlink" title="Dubbo集群提供了哪些负载均衡策略？"></a>Dubbo集群提供了哪些负载均衡策略？</h3><ul>
<li>Random LoadBalance: 随机选取提供者策略，有利于动态调整提供者权重。截面碰撞率高，调用次数越多，分布越均匀。</li>
<li>RoundRobin LoadBalance: 轮循选取提供者策略，平均分布，但是存在请求累积的问题。</li>
<li>LeastActive LoadBalance: 最少活跃调用策略，解决慢提供者接收更少的请求。</li>
<li>ConstantHash LoadBalance: 一致性 Hash 策略，使相同参数请求总是发到同一提供者，一台机器宕机，可以基于虚拟节点，分摊至其他提供者，避免引起提供者的剧烈变动。</li>
</ul>
<p>默认为 Random 随机调用。</p>
<h3 id="Dubbo的集群容错方案有哪些？"><a href="#Dubbo的集群容错方案有哪些？" class="headerlink" title="Dubbo的集群容错方案有哪些？"></a>Dubbo的集群容错方案有哪些？</h3><ul>
<li>Failover Cluster：失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。</li>
<li>Failfast Cluster：快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</li>
<li>Failsafe Cluster：失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</li>
<li>Failback Cluster：失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</li>
<li>Forking Cluster：并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=”2″ 来设置最大并行数。</li>
<li>Broadcast Cluster：广播调用所有提供者，逐个调用，任意一台报错则报错 。通常用于通知所有提供者更新缓存或日志等本地资源信息。</li>
</ul>
<p>默认的容错方案是 Failover Cluster。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="Dubbo-配置文件是如何加载到-Spring-中的？"><a href="#Dubbo-配置文件是如何加载到-Spring-中的？" class="headerlink" title="Dubbo 配置文件是如何加载到 Spring 中的？"></a>Dubbo 配置文件是如何加载到 Spring 中的？</h3><p>Spring 容器在启动的时候，会读取到 Spring 默认的一些 schema 以及 Dubbo 自定义的 schema，每个 schema 都会对应一个自己的 NamespaceHandler，NamespaceHandler 里面通过 BeanDefinitionParser 来解析配置信息并转化为需要加载的 bean 对象！</p>
<h3 id="说说核心的配置有哪些？"><a href="#说说核心的配置有哪些？" class="headerlink" title="说说核心的配置有哪些？"></a>说说核心的配置有哪些？</h3><table>
<thead>
<tr>
<th>标签</th>
<th>用途</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><a href="dubbo:service/">dubbo:service/</a></td>
<td>服务配置</td>
<td>用于暴露一个服务，定义服务的元信息，一个服务可以用多个协议暴露，一个服务也可以注册到多个注册中心</td>
</tr>
<tr>
<td><a href="dubbo:reference/">dubbo:reference/</a></td>
<td>引用配置</td>
<td>用于创建一个远程服务代理，一个引用可以指向多个注册中心</td>
</tr>
<tr>
<td><a href="dubbo:protocol/">dubbo:protocol/</a></td>
<td>协议配置</td>
<td>用于配置提供服务的协议信息，协议由提供方指定，消费方被动接受</td>
</tr>
<tr>
<td><a href="dubbo:application/">dubbo:application/</a></td>
<td>应用配置</td>
<td>用于配置当前应用信息，不管该应用是提供者还是消费者</td>
</tr>
<tr>
<td><a href="dubbo:module/">dubbo:module/</a></td>
<td>模块配置</td>
<td>用于配置当前模块信息，可选</td>
</tr>
<tr>
<td><a href="dubbo:registry/">dubbo:registry/</a></td>
<td>注册中心配置</td>
<td>用于配置连接注册中心相关信息</td>
</tr>
<tr>
<td><a href="dubbo:monitor/">dubbo:monitor/</a></td>
<td>监控中心配置</td>
<td>用于配置连接监控中心相关信息，可选</td>
</tr>
<tr>
<td><a href="dubbo:provider/">dubbo:provider/</a></td>
<td>提供方配置</td>
<td>当 ProtocolConfig 和 ServiceConfig 某属性没有配置时，采用此缺省值，可选</td>
</tr>
<tr>
<td><a href="dubbo:consumer/">dubbo:consumer/</a></td>
<td>消费方配置</td>
<td>当 ReferenceConfig 某属性没有配置时，采用此缺省值，可选</td>
</tr>
<tr>
<td><a href="dubbo:method/">dubbo:method/</a></td>
<td>方法配置</td>
<td>用于 ServiceConfig 和 ReferenceConfig 指定方法级的配置信息</td>
</tr>
<tr>
<td><a href="dubbo:argument/">dubbo:argument/</a></td>
<td>参数配置</td>
<td>用于指定方法参数配置</td>
</tr>
</tbody></table>
<h3 id="Dubbo-超时设置有哪些方式？"><a href="#Dubbo-超时设置有哪些方式？" class="headerlink" title="Dubbo 超时设置有哪些方式？"></a>Dubbo 超时设置有哪些方式？</h3><p>Dubbo 超时设置有两种方式：</p>
<ul>
<li>服务提供者端设置超时时间，在Dubbo的用户文档中，推荐如果能在服务端多配置就尽量多配置，因为服务提供者比消费者更清楚自己提供的服务特性。</li>
<li>服务消费者端设置超时时间，如果在消费者端设置了超时时间，以消费者端为主，即优先级更高。因为服务调用方设置超时时间控制性更灵活。如果消费方超时，服务端线程不会定制，会产生警告。</li>
</ul>
<h3 id="服务调用超时会怎么样？"><a href="#服务调用超时会怎么样？" class="headerlink" title="服务调用超时会怎么样？"></a>服务调用超时会怎么样？</h3><p>dubbo 在调用服务不成功时，默认是会重试两次。</p>
<h2 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h2><h3 id="Dubbo-使用的是什么通信框架"><a href="#Dubbo-使用的是什么通信框架" class="headerlink" title="Dubbo 使用的是什么通信框架?"></a>Dubbo 使用的是什么通信框架?</h3><p>默认使用 Netty 作为通讯框架。</p>
<h3 id="Dubbo-支持哪些协议，它们的优缺点有哪些？"><a href="#Dubbo-支持哪些协议，它们的优缺点有哪些？" class="headerlink" title="Dubbo 支持哪些协议，它们的优缺点有哪些？"></a>Dubbo 支持哪些协议，它们的优缺点有哪些？</h3><ul>
<li>Dubbo： 单一长连接和 NIO 异步通讯，适合大并发小数据量的服务调用，以及消费者远大于提供者。传输协议 TCP，异步 Hessian 序列化。<strong>Dubbo推荐使用dubbo协议</strong>。</li>
<li>RMI： 采用 JDK 标准的 RMI 协议实现，传输参数和返回参数对象需要实现 Serializable 接口，使用 Java 标准序列化机制，使用阻塞式短连接，传输数据包大小混合，消费者和提供者个数差不多，可传文件，传输协议 TCP。 多个短连接 TCP 协议传输，同步传输，适用常规的远程服务调用和 RMI 互操作。在依赖低版本的 Common-Collections 包，Java 序列化存在安全漏洞。</li>
<li>WebService：基于 WebService 的远程调用协议，集成 CXF 实现，提供和原生 WebService 的互操作。多个短连接，基于 HTTP 传输，同步传输，适用系统集成和跨语言调用。</li>
<li>HTTP： 基于 Http 表单提交的远程调用协议，使用 Spring 的 HttpInvoke 实现。多个短连接，传输协议 HTTP，传入参数大小混合，提供者个数多于消费者，需要给应用程序和浏览器 JS 调用。</li>
<li>Hessian：集成 Hessian 服务，基于 HTTP 通讯，采用 Servlet 暴露服务，Dubbo 内嵌 Jetty 作为服务器时默认实现，提供与 Hession 服务互操作。多个短连接，同步 HTTP 传输，Hessian 序列化，传入参数较大，提供者大于消费者，提供者压力较大，可传文件。</li>
<li>Memcache：基于 Memcache实现的 RPC 协议。</li>
<li>Redis：基于 Redis 实现的RPC协议。</li>
</ul>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="Dubbo-用到哪些设计模式？"><a href="#Dubbo-用到哪些设计模式？" class="headerlink" title="Dubbo 用到哪些设计模式？"></a>Dubbo 用到哪些设计模式？</h3><p>Dubbo 框架在初始化和通信过程中使用了多种设计模式，可灵活控制类加载、权限控制等功能。</p>
<p><strong>工厂模式</strong></p>
<p>Provider 在 export 服务时，会调用 ServiceConfig 的 export 方法。ServiceConfig中有个字段：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">private static final Protocol protocol =</span><br><span class="line">ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtensi</span><br><span class="line">on();</span><br></pre></td></tr></table></figure>

<p>Dubbo 里有很多这种代码。这也是一种工厂模式，只是实现类的获取采用了 JDKSPI 的机制。这么实现的优点是可扩展性强，想要扩展实现，只需要在 classpath下增加个文件就可以了，代码零侵入。另外，像上面的 Adaptive 实现，可以做到调用时动态决定调用哪个实现，但是由于这种实现采用了动态代理，会造成代码调试比较麻烦，需要分析出实际调用的实现类。</p>
<p><strong>装饰器模式</strong></p>
<p>Dubbo 在启动和调用阶段都大量使用了装饰器模式。以 Provider 提供的调用链为例，具体的调用链代码是在 ProtocolFilterWrapper 的 buildInvokerChain 完成的，具体是将注解中含有 group=provider 的 Filter 实现，按照 order 排序，最后的调用顺序是：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">EchoFilter -&gt; ClassLoaderFilter -&gt; GenericFilter -&gt; ContextFilter -&gt;</span><br><span class="line">ExecuteLimitFilter -&gt; TraceFilter -&gt; TimeoutFilter -&gt; MonitorFilter -&gt;</span><br><span class="line">ExceptionFilter</span><br></pre></td></tr></table></figure>

<p>更确切地说，这里是装饰器和责任链模式的混合使用。例如，EchoFilter 的作用是判断是否是回声测试请求，是的话直接返回内容，这是一种责任链的体现。而像ClassLoaderFilter 则只是在主功能上添加了功能，更改当前线程的 ClassLoader，这是典型的装饰器模式。</p>
<p><strong>观察者模式</strong></p>
<p>Dubbo 的 Provider 启动时，需要与注册中心交互，先注册自己的服务，再订阅自己的服务，订阅时，采用了观察者模式，开启一个 listener。注册中心会每 5 秒定时检查是否有服务更新，如果有更新，向该服务的提供者发送一个 notify 消息，provider 接受到 notify 消息后，运行 NotifyListener 的 notify 方法，执行监听器方法。</p>
<p><strong>动态代理模式</strong></p>
<p>Dubbo 扩展 JDK SPI 的类 ExtensionLoader 的 Adaptive 实现是典型的动态代理实现。Dubbo 需要灵活地控制实现类，即在调用阶段动态地根据参数决定调用哪个实现类，所以采用先生成代理类的方法，能够做到灵活的调用。生成代理类的代码是 ExtensionLoader 的 createAdaptiveExtensionClassCode 方法。代理类主要逻辑是，获取 URL 参数中指定参数的值作为获取实现类的 key。</p>
<h2 id="运维管理"><a href="#运维管理" class="headerlink" title="运维管理"></a>运维管理</h2><h3 id="服务上线怎么兼容旧版本？"><a href="#服务上线怎么兼容旧版本？" class="headerlink" title="服务上线怎么兼容旧版本？"></a>服务上线怎么兼容旧版本？</h3><p>可以用版本号（version）过渡，多个不同版本的服务注册到注册中心，版本号不同的服务相互间不引用。这个和服务分组的概念有一点类似。</p>
<h3 id="Dubbo-telnet-命令能做什么？"><a href="#Dubbo-telnet-命令能做什么？" class="headerlink" title="Dubbo telnet 命令能做什么？"></a>Dubbo telnet 命令能做什么？</h3><p>dubbo 服务发布之后，我们可以利用 telnet 命令进行调试、管理。Dubbo2.0.5 以上版本服务提供端口支持 telnet 命令</p>
<h3 id="Dubbo-支持服务降级吗？"><a href="#Dubbo-支持服务降级吗？" class="headerlink" title="Dubbo 支持服务降级吗？"></a>Dubbo 支持服务降级吗？</h3><p>以通过 dubbo:reference 中设置 mock=“return null”。mock 的值也可以修改为 true，然后再跟接口同一个路径下实现一个 Mock 类，命名规则是 “接口名称+Mock” 后缀。然后在 Mock 类里实现自己的降级逻辑</p>
<h3 id="Dubbo-如何优雅停机？"><a href="#Dubbo-如何优雅停机？" class="headerlink" title="Dubbo 如何优雅停机？"></a>Dubbo 如何优雅停机？</h3><p>Dubbo 是通过 JDK 的 ShutdownHook 来完成优雅停机的，所以如果使用kill -9 PID 等强制关闭指令，是不会执行优雅停机的，只有通过 kill PID 时，才会执行。</p>
<h2 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h2><h3 id="Dubbo-SPI-和-Java-SPI-区别？"><a href="#Dubbo-SPI-和-Java-SPI-区别？" class="headerlink" title="Dubbo SPI 和 Java SPI 区别？"></a>Dubbo SPI 和 Java SPI 区别？</h3><p><strong>JDK SPI</strong>：</p>
<p>JDK 标准的 SPI 会一次性加载所有的扩展实现，如果有的扩展很耗时，但也没用上，很浪费资源。所以只希望加载某个的实现，就不现实了</p>
<p><strong>DUBBO SPI</strong>：</p>
<p>1、对 Dubbo 进行扩展，不需要改动 Dubbo 的源码</p>
<p>2、延迟加载，可以一次只加载自己想要加载的扩展实现。</p>
<p>3、增加了对扩展点 IOC 和 AOP 的支持，一个扩展点可以直接 setter 注入其</p>
<p>它扩展点。</p>
<p>4、Dubbo 的扩展机制能很好的支持第三方 IoC 容器，默认支持 Spring Bean。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="Dubbo-支持分布式事务吗？"><a href="#Dubbo-支持分布式事务吗？" class="headerlink" title="Dubbo 支持分布式事务吗？"></a>Dubbo 支持分布式事务吗？</h3><p>目前暂时不支持，可与通过 tcc-transaction 框架实现</p>
<p>介绍：tcc-transaction 是开源的 TCC 补偿性分布式事务框架</p>
<p>TCC-Transaction 通过 Dubbo 隐式传参的功能，避免自己对业务代码的入侵。</p>
<h3 id="Dubbo-可以对结果进行缓存吗？"><a href="#Dubbo-可以对结果进行缓存吗？" class="headerlink" title="Dubbo 可以对结果进行缓存吗？"></a>Dubbo 可以对结果进行缓存吗？</h3><p>为了提高数据访问的速度。Dubbo 提供了声明式缓存，以减少用户加缓存的工作量&lt;dubbo:reference cache=“true” /&gt;</p>
<p>其实比普通的配置文件就多了一个标签 cache=“true”</p>
<h3 id="Dubbo-必须依赖的包有哪些？"><a href="#Dubbo-必须依赖的包有哪些？" class="headerlink" title="Dubbo 必须依赖的包有哪些？"></a>Dubbo 必须依赖的包有哪些？</h3><p>Dubbo 必须依赖 JDK，其他为可选。</p>
<h3 id="Dubbo-支持哪些序列化方式？"><a href="#Dubbo-支持哪些序列化方式？" class="headerlink" title="Dubbo 支持哪些序列化方式？"></a>Dubbo 支持哪些序列化方式？</h3><p>默认使用 Hessian 序列化，还有 Duddo、FastJson、Java 自带序列化。</p>
<h3 id="Dubbo-在安全方面有哪些措施？"><a href="#Dubbo-在安全方面有哪些措施？" class="headerlink" title="Dubbo 在安全方面有哪些措施？"></a>Dubbo 在安全方面有哪些措施？</h3><ul>
<li>Dubbo 通过 Token 令牌防止用户绕过注册中心直连，然后在注册中心上管理授权。</li>
<li>Dubbo 还提供服务黑白名单，来控制服务所允许的调用方。</li>
</ul>
<h3 id="服务调用是阻塞的吗？"><a href="#服务调用是阻塞的吗？" class="headerlink" title="服务调用是阻塞的吗？"></a>服务调用是阻塞的吗？</h3><p>默认是阻塞的，可以异步调用，没有返回值的可以这么做。Dubbo 是基于 NIO 的非阻塞实现并行调用，客户端不需要启动多线程即可完成并行调用多个远程服务，相对多线程开销较小，异步调用会返回一个 Future 对象。</p>
<h3 id="服务提供者能实现失效踢出是什么原理？"><a href="#服务提供者能实现失效踢出是什么原理？" class="headerlink" title="服务提供者能实现失效踢出是什么原理？"></a>服务提供者能实现失效踢出是什么原理？</h3><p>服务失效踢出基于 zookeeper 的临时节点原理。</p>
<h3 id="同一个服务多个注册的情况下可以直连某一个服务吗？"><a href="#同一个服务多个注册的情况下可以直连某一个服务吗？" class="headerlink" title="同一个服务多个注册的情况下可以直连某一个服务吗？"></a>同一个服务多个注册的情况下可以直连某一个服务吗？</h3><p>可以点对点直连，修改配置即可，也可以通过 telnet 直接某个服务。</p>
<h3 id="Dubbo-服务降级，失败重试怎么做？"><a href="#Dubbo-服务降级，失败重试怎么做？" class="headerlink" title="Dubbo 服务降级，失败重试怎么做？"></a>Dubbo 服务降级，失败重试怎么做？</h3><p>可以通过 dubbo:reference 中设置 mock=“return null”。mock 的值也可以修改为 true，然后再跟接口同一个路径下实现一个 Mock 类，命名规则是 “接口名称+Mock” 后缀。然后在 Mock 类里实现自己的降级逻辑</p>
<h3 id="Dubbo-使用过程中都遇到了些什么问题？"><a href="#Dubbo-使用过程中都遇到了些什么问题？" class="headerlink" title="Dubbo 使用过程中都遇到了些什么问题？"></a>Dubbo 使用过程中都遇到了些什么问题？</h3><p>在注册中心找不到对应的服务,检查 service 实现类是否添加了@service 注解无法连接到注册中心,检查配置文件中的对应的测试 ip 是否正确</p>
<h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><h3 id="为什么要有RPC"><a href="#为什么要有RPC" class="headerlink" title="为什么要有RPC"></a>为什么要有RPC</h3><p>http接口是在接口不多、系统与系统交互较少的情况下，解决信息孤岛初期常使用的一种通信手段；优点就是简单、直接、开发方便。利用现成的http协议进行传输。但是如果是一个大型的网站，内部子系统较多、接口非常多的情况下，RPC框架的好处就显示出来了，首先就是长链接，不必每次通信都要像http一样去3次握手什么的，减少了网络开销；其次就是RPC框架一般都有注册中心，有丰富的监控管理；发布、下线接口、动态扩展等，对调用方来说是无感知、统一化的操作。第三个来说就是安全性。最后就是最近流行的服务化架构、服务化治理，RPC框架是一个强力的支撑。</p>
<p>socket只是一个简单的网络通信方式，只是创建通信双方的通信通道，而要实现rpc的功能，还需要对其进行封装，以实现更多的功能。</p>
<p>RPC一般配合netty框架、spring自定义注解来编写轻量级框架，其实netty内部是封装了socket的，较新的jdk的IO一般是NIO，即非阻塞IO，在高并发网站中，RPC的优势会很明显</p>
<h3 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="什么是RPC"></a>什么是RPC</h3><p>RPC（Remote Procedure Call Protocol）远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。简言之，RPC使得程序能够像访问本地系统资源一样，去访问远端系统资源。比较关键的一些方面包括：通讯协议、序列化、资源（接口）描述、服务框架、性能、语言支持等。</p>
<p>简单的说，RPC就是从一台机器(客户端)上通过参数传递的方式调用另一台机器(服务器)上的一个函数或方法(可以统称为服务)并得到返回的结果。</p>
<h3 id="PRC架构组件"><a href="#PRC架构组件" class="headerlink" title="PRC架构组件"></a>PRC架构组件</h3><p>一个基本的RPC架构里面应该至少包含以下4个组件：</p>
<p>1、<strong>客户端</strong>（Client）:服务调用方（服务消费者）</p>
<p>2、<strong>客户端存根</strong>（Client Stub）:存放服务端地址信息，将客户端的请求参数数据信息打包成网络消息，再通过网络传输发送给服务端</p>
<p>3、<strong>服务端存根</strong>（Server Stub）:接收客户端发送过来的请求消息并进行解包，然后再调用本地服务进行处理</p>
<p>4、<strong>服务端</strong>（Server）:服务的真正提供者</p>
<p><img src="https://img-blog.csdnimg.cn/20210321130342167.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5nbGlmdTUyMA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p><strong>具体调用过程</strong>：</p>
<p>1、服务消费者（client客户端）通过调用本地服务的方式调用需要消费的服务；</p>
<p>2、客户端存根（client stub）接收到调用请求后负责将方法、入参等信息序列化（组装）成能够进行网络传输的消息体；</p>
<p>3、客户端存根（client stub）找到远程的服务地址，并且将消息通过网络发送给服务端；</p>
<p>4、服务端存根（server stub）收到消息后进行解码（反序列化操作）；</p>
<p>5、服务端存根（server stub）根据解码结果调用本地的服务进行相关处理；</p>
<p>6、本地服务执行具体业务逻辑并将处理结果返回给服务端存根（server stub）；</p>
<p>7、服务端存根（server stub）将返回结果重新打包成消息（序列化）并通过网络发送至消费方；</p>
<p>8、客户端存根（client stub）接收到消息，并进行解码（反序列化）；</p>
<p>9、服务消费方得到最终结果；</p>
<p>而RPC框架的实现目标则是将上面的第2-10步完好地封装起来，也就是把调用、编码/解码的过程给封装起来，让用户感觉上像调用本地服务一样的调用远程服务。</p>
<h3 id="RPC和SOA、SOAP、REST的区别"><a href="#RPC和SOA、SOAP、REST的区别" class="headerlink" title="RPC和SOA、SOAP、REST的区别"></a>RPC和SOA、SOAP、REST的区别</h3><p><strong>1、REST</strong></p>
<p>可以看着是HTTP协议的一种直接应用，默认基于JSON作为传输格式,使用简单,学习成本低效率高,但是安全性较低。</p>
<p><strong>2、SOAP</strong></p>
<p>SOAP是一种数据交换协议规范,是一种轻量的、简单的、基于XML的协议的规范。而SOAP可以看着是一个重量级的协议，基于XML、SOAP在安全方面是通过使用XML-Security和XML-Signature两个规范组成了WS-Security来实现安全控制的,当前已经得到了各个厂商的支持 。</p>
<p>它有什么优点？简单总结为：易用、灵活、跨语言、跨平台。</p>
<p><strong>3、SOA</strong></p>
<p>面向服务架构，它可以根据需求通过网络对松散耦合的粗粒度应用组件进行分布式部署、组合和使用。服务层是SOA的基础，可以直接被应用调用，从而有效控制系统中与软件代理交互的人为依赖性。</p>
<p>SOA是一种粗粒度、松耦合服务架构，服务之间通过简单、精确定义接口进行通讯，不涉及底层编程接口和通讯模型。SOA可以看作是B/S模型、XML（标准通用标记语言的子集）/Web Service技术之后的自然延伸。</p>
<p><strong>4、REST 和 SOAP、RPC 有何区别呢?</strong></p>
<p>没什么太大区别，他们的本质都是提供可支持分布式的基础服务，最大的区别在于他们各自的的特点所带来的不同应用场景 。</p>
<h3 id="RPC框架需要解决的问题？"><a href="#RPC框架需要解决的问题？" class="headerlink" title="RPC框架需要解决的问题？"></a>RPC框架需要解决的问题？</h3><p>1、如何确定客户端和服务端之间的通信协议？</p>
<p>2、如何更高效地进行网络通信？</p>
<p>3、服务端提供的服务如何暴露给客户端？</p>
<p>4、客户端如何发现这些暴露的服务？</p>
<p>5、如何更高效地对请求对象和响应结果进行序列化和反序列化操作？</p>
<h3 id="RPC的实现基础？"><a href="#RPC的实现基础？" class="headerlink" title="RPC的实现基础？"></a>RPC的实现基础？</h3><p>1、需要有非常高效的网络通信，比如一般选择Netty作为网络通信框架；</p>
<p>2、需要有比较高效的序列化框架，比如谷歌的Protobuf序列化框架；</p>
<p>3、可靠的寻址方式（主要是提供服务的发现），比如可以使用Zookeeper来注册服务等等；</p>
<p>4、如果是带会话（状态）的RPC调用，还需要有会话和状态保持的功能；</p>
<h3 id="RPC使用了哪些关键技术？"><a href="#RPC使用了哪些关键技术？" class="headerlink" title="RPC使用了哪些关键技术？"></a>RPC使用了哪些关键技术？</h3><p><strong>1、动态代理</strong></p>
<p>生成Client Stub（客户端存根）和Server Stub（服务端存根）的时候需要用到Java动态代理技术，可以使用JDK提供的原生的动态代理机制，也可以使用开源的：CGLib代理，Javassist字节码生成技术。</p>
<p><strong>2、序列化和反序列化</strong></p>
<p>在网络中，所有的数据都将会被转化为字节进行传送，所以为了能够使参数对象在网络中进行传输，需要对这些参数进行序列化和反序列化操作。</p>
<ul>
<li>序列化：把对象转换为字节序列的过程称为对象的序列化，也就是编码的过程。</li>
<li>反序列化：把字节序列恢复为对象的过程称为对象的反序列化，也就是解码的过程。</li>
</ul>
<p>目前比较高效的开源序列化框架：如Kryo、FastJson和Protobuf等。</p>
<p><strong>3、NIO通信</strong></p>
<p>出于并发性能的考虑，传统的阻塞式 IO 显然不太合适，因此我们需要异步的 IO，即 NIO。Java 提供了 NIO 的解决方案，Java 7 也提供了更优秀的 NIO.2 支持。可以选择Netty或者MINA来解决NIO数据传输的问题。</p>
<p><strong>4、服务注册中心</strong></p>
<p>可选：Redis、Zookeeper、Consul 、Etcd。一般使用ZooKeeper提供服务注册与发现功能，解决单点故障以及分布式部署的问题(注册中心)。</p>
<h3 id="主流RPC框架有哪些"><a href="#主流RPC框架有哪些" class="headerlink" title="主流RPC框架有哪些"></a>主流RPC框架有哪些</h3><p><strong>1、RMI</strong></p>
<p>利用java.rmi包实现，基于Java远程方法协议(Java Remote Method Protocol) 和java的原生序列化。</p>
<p><strong>2、Hessian</strong></p>
<p>是一个轻量级的remoting onhttp工具，使用简单的方法提供了RMI的功能。 基于HTTP协议，采用二进制编解码。</p>
<p><strong>3、protobuf-rpc-pro</strong></p>
<p>是一个Java类库，提供了基于 Google 的 Protocol Buffers 协议的远程方法调用的框架。基于 Netty 底层的 NIO 技术。支持 TCP 重用/ keep-alive、SSL加密、RPC 调用取消操作、嵌入式日志等功能。</p>
<p><strong>4、Thrift</strong></p>
<p>是一种可伸缩的跨语言服务的软件框架。它拥有功能强大的代码生成引擎，无缝地支持C + +，C#，Java，Python和PHP和Ruby。thrift允许你定义一个描述文件，描述数据类型和服务接口。依据该文件，编译器方便地生成RPC客户端和服务器通信代码。</p>
<p>最初由facebook开发用做系统内个语言之间的RPC通信，2007年由facebook贡献到apache基金 ，现在是apache下的opensource之一 。支持多种语言之间的RPC方式的通信：php语言client可以构造一个对象，调用相应的服务方法来调用java语言的服务，跨越语言的C/S RPC调用。底层通讯基于SOCKET。</p>
<p><strong>5、Avro</strong></p>
<p>出自Hadoop之父Doug Cutting, 在Thrift已经相当流行的情况下推出Avro的目标不仅是提供一套类似Thrift的通讯中间件,更是要建立一个新的，标准性的云计算的数据交换和存储的Protocol。支持HTTP，TCP两种协议。</p>
<p><strong>6、Dubbo</strong></p>
<p>Dubbo是 阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring框架无缝集成。</p>
<h3 id="RPC的实现原理架构图"><a href="#RPC的实现原理架构图" class="headerlink" title="RPC的实现原理架构图"></a>RPC的实现原理架构图</h3><p><img src="https://img-blog.csdnimg.cn/20210321130422659.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5nbGlmdTUyMA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p><img src="https://img-blog.csdnimg.cn/20210321130457715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5nbGlmdTUyMA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>PS：这张图非常重点，是PRC的基本原理，请大家一定记住！</p>
<p>也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。</p>
<p>比如说，A服务器想调用B服务器上的一个方法：</p>
<p>User getUserByName(String userName)</p>
<p><strong>1、建立通信</strong></p>
<p>首先要解决通讯的问题：即A机器想要调用B机器，首先得建立起通信连接。</p>
<p>主要是通过在客户端和服务器之间建立TCP连接，远程过程调用的所有交换的数据都在这个连接里传输。连接可以是按需连接，调用结束后就断掉，也可以是长连接，多个远程过程调用共享同一个连接。</p>
<p>通常这个连接可以是按需连接（需要调用的时候就先建立连接，调用结束后就立马断掉），也可以是长连接（客户端和服务器建立起连接之后保持长期持有，不管此时有无数据包的发送，可以配合心跳检测机制定期检测建立的连接是否存活有效），多个远程过程调用共享同一个连接。</p>
<p><strong>2、服务寻址</strong></p>
<p>要解决寻址的问题，也就是说，A服务器上的应用怎么告诉底层的RPC框架，如何连接到B服务器（如主机或IP地址）以及特定的端口，方法的名称名称是什么。</p>
<p>通常情况下我们需要提供B机器（主机名或IP地址）以及特定的端口，然后指定调用的方法或者函数的名称以及入参出参等信息，这样才能完成服务的一个调用。</p>
<p>可靠的寻址方式（主要是提供服务的发现）是RPC的实现基石，比如可以采用Redis或者Zookeeper来注册服务等等。</p>
<p><strong>2.1、从服务提供者的角度看</strong>：</p>
<p>当服务提供者启动的时候，需要将自己提供的服务注册到指定的注册中心，以便服务消费者能够通过服务注册中心进行查找；</p>
<p>当服务提供者由于各种原因致使提供的服务停止时，需要向注册中心注销停止的服务；</p>
<p>服务的提供者需要定期向服务注册中心发送心跳检测，服务注册中心如果一段时间未收到来自服务提供者的心跳后，认为该服务提供者已经停止服务，则将该服务从注册中心上去掉。</p>
<p><strong>2.2、从调用者的角度看</strong>：</p>
<p>服务的调用者启动的时候根据自己订阅的服务向服务注册中心查找服务提供者的地址等信息；</p>
<p>当服务调用者消费的服务上线或者下线的时候，注册中心会告知该服务的调用者；</p>
<p>服务调用者下线的时候，则取消订阅。</p>
<p><strong>3、网络传输</strong></p>
<p><strong>3.1、序列化</strong></p>
<p>当A机器上的应用发起一个RPC调用时，调用方法和其入参等信息需要通过底层的网络协议如TCP传输到B机器，由于网络协议是基于二进制的，所有我们传输的参数数据都需要先进行序列化（Serialize）或者编组（marshal）成二进制的形式才能在网络中进行传输。然后通过寻址操作和网络传输将序列化或者编组之后的二进制数据发送给B机器。</p>
<p><strong>3.2、反序列化</strong></p>
<p>当B机器接收到A机器的应用发来的请求之后，又需要对接收到的参数等信息进行反序列化操作（序列化的逆操作），即将二进制信息恢复为内存中的表达方式，然后再找到对应的方法（寻址的一部分）进行本地调用（一般是通过生成代理Proxy去调用, 通常会有JDK动态代理、CGLIB动态代理、Javassist生成字节码技术等），之后得到调用的返回值。</p>
<p><strong>4、服务调用</strong></p>
<p>B机器进行本地调用（通过代理Proxy和反射调用）之后得到了返回值，此时还需要再把返回值发送回A机器，同样也需要经过序列化操作，然后再经过网络传输将二进制数据发送回A机器，而当A机器接收到这些返回值之后，则再次进行反序列化操作，恢复为内存中的表达方式，最后再交给A机器上的应用进行相关处理（一般是业务逻辑处理操作）。</p>
]]></content>
      <categories>
        <category>面试篇</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>EclasticSearch 查询入门指南</title>
    <url>/2018/10/19/EclasticSearch-%E6%9F%A5%E8%AF%A2%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h3 id="Es查询"><a href="#Es查询" class="headerlink" title="Es查询"></a>Es查询</h3><span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.action.ListenableActionFuture;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.action.get.GetRequestBuilder;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.action.get.GetResponse;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.action.search.SearchResponse;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.action.search.SearchType;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.transport.TransportClient;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.common.settings.Settings;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.common.text.Text;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.common.transport.InetSocketTransportAddress;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.common.unit.TimeValue;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.index.query.IndicesQueryBuilder;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.index.query.NestedQueryBuilder;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.index.query.QueryBuilder;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.index.query.QueryBuilders;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.index.query.QueryStringQueryBuilder;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.index.query.RangeQueryBuilder;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.index.query.SpanFirstQueryBuilder;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.index.query.WildcardQueryBuilder;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.search.SearchHit;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.search.SearchHits;</span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * java操作查询api</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 231</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaESQuery</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> TransportClient client;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBefore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Settings</span> <span class="variable">settings</span> <span class="operator">=</span> Settings.settingsBuilder().put(<span class="string">&quot;cluster.name&quot;</span>, <span class="string">&quot;wenbronk_escluster&quot;</span>).build();</span><br><span class="line">        client = TransportClient.builder().settings(settings).build()</span><br><span class="line">                 .addTransportAddress(<span class="keyword">new</span> <span class="title class_">InetSocketTransportAddress</span>(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;192.168.50.37&quot;</span>, <span class="number">9300</span>)));</span><br><span class="line">        System.out.println(<span class="string">&quot;success to connect escluster&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用get查询</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">GetRequestBuilder</span> <span class="variable">requestBuilder</span> <span class="operator">=</span> client.prepareGet(<span class="string">&quot;twitter&quot;</span>, <span class="string">&quot;tweet&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="type">GetResponse</span> <span class="variable">response</span> <span class="operator">=</span> requestBuilder.execute().actionGet();</span><br><span class="line">        <span class="type">GetResponse</span> <span class="variable">getResponse</span> <span class="operator">=</span> requestBuilder.get();</span><br><span class="line">        ListenableActionFuture&lt;GetResponse&gt; execute = requestBuilder.execute();</span><br><span class="line">        System.out.println(response.getSourceAsString());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用QueryBuilder</span></span><br><span class="line"><span class="comment">     * termQuery(&quot;key&quot;, obj) 完全匹配</span></span><br><span class="line"><span class="comment">     * termsQuery(&quot;key&quot;, obj1, obj2..)   一次匹配多个值</span></span><br><span class="line"><span class="comment">     * matchQuery(&quot;key&quot;, Obj) 单个匹配, field不支持通配符, 前缀具高级特性</span></span><br><span class="line"><span class="comment">     * multiMatchQuery(&quot;text&quot;, &quot;field1&quot;, &quot;field2&quot;..);  匹配多个字段, field有通配符忒行</span></span><br><span class="line"><span class="comment">     * matchAllQuery();         匹配所有文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQueryBuilder</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//        QueryBuilder queryBuilder = QueryBuilders.termQuery(&quot;user&quot;, &quot;kimchy&quot;);</span></span><br><span class="line">　　　　　　<span class="type">QueryBUilder</span> <span class="variable">queryBuilder</span> <span class="operator">=</span> QueryBuilders.termQuery(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;kimchy&quot;</span>, <span class="string">&quot;wenbronk&quot;</span>, <span class="string">&quot;vini&quot;</span>);</span><br><span class="line">        QueryBuilders.termsQuery(<span class="string">&quot;user&quot;</span>, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;().add(<span class="string">&quot;kimchy&quot;</span>));</span><br><span class="line"><span class="comment">//        QueryBuilder queryBuilder = QueryBuilders.matchQuery(&quot;user&quot;, &quot;kimchy&quot;);</span></span><br><span class="line"><span class="comment">//        QueryBuilder queryBuilder = QueryBuilders.multiMatchQuery(&quot;kimchy&quot;, &quot;user&quot;, &quot;message&quot;, &quot;gender&quot;);</span></span><br><span class="line">        <span class="type">QueryBuilder</span> <span class="variable">queryBuilder</span> <span class="operator">=</span> QueryBuilders.matchAllQuery();</span><br><span class="line">        searchFunction(queryBuilder);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 组合查询</span></span><br><span class="line"><span class="comment">     * must(QueryBuilders) :   AND</span></span><br><span class="line"><span class="comment">     * mustNot(QueryBuilders): NOT</span></span><br><span class="line"><span class="comment">     * should:                  : OR</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQueryBuilder2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">QueryBuilder</span> <span class="variable">queryBuilder</span> <span class="operator">=</span> QueryBuilders.boolQuery()</span><br><span class="line">            .must(QueryBuilders.termQuery(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;kimchy&quot;</span>))</span><br><span class="line">            .mustNot(QueryBuilders.termQuery(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;nihao&quot;</span>))</span><br><span class="line">            .should(QueryBuilders.termQuery(<span class="string">&quot;gender&quot;</span>, <span class="string">&quot;male&quot;</span>));</span><br><span class="line">        searchFunction(queryBuilder);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只查询一个id的</span></span><br><span class="line"><span class="comment">     * QueryBuilders.idsQuery(String...type).ids(Collection&lt;String&gt; ids)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testIdsQuery</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">QueryBuilder</span> <span class="variable">queryBuilder</span> <span class="operator">=</span> QueryBuilders.idsQuery().ids(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        searchFunction(queryBuilder);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 包裹查询, 高于设定分数, 不计算相关性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConstantScoreQuery</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">QueryBuilder</span> <span class="variable">queryBuilder</span> <span class="operator">=</span> QueryBuilders.constantScoreQuery(QueryBuilders.termQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;kimchy&quot;</span>)).boost(<span class="number">2.0f</span>);</span><br><span class="line">        searchFunction(queryBuilder);</span><br><span class="line">        <span class="comment">// 过滤查询</span></span><br><span class="line"><span class="comment">//        QueryBuilders.constantScoreQuery(FilterBuilders.termQuery(&quot;name&quot;, &quot;kimchy&quot;)).boost(2.0f);</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * disMax查询</span></span><br><span class="line"><span class="comment">     * 对子查询的结果做union, score沿用子查询score的最大值, </span></span><br><span class="line"><span class="comment">     * 广泛用于muti-field查询</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDisMaxQuery</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">QueryBuilder</span> <span class="variable">queryBuilder</span> <span class="operator">=</span> QueryBuilders.disMaxQuery()</span><br><span class="line">            .add(QueryBuilders.termQuery(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;kimch&quot;</span>))  <span class="comment">// 查询条件</span></span><br><span class="line">            .add(QueryBuilders.termQuery(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;hello&quot;</span>))</span><br><span class="line">            .boost(<span class="number">1.3f</span>)</span><br><span class="line">            .tieBreaker(<span class="number">0.7f</span>);</span><br><span class="line">        searchFunction(queryBuilder);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模糊查询</span></span><br><span class="line"><span class="comment">     * 不能用通配符, 不知道干啥用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFuzzyQuery</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">QueryBuilder</span> <span class="variable">queryBuilder</span> <span class="operator">=</span> QueryBuilders.fuzzyQuery(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;kimch&quot;</span>);</span><br><span class="line">        searchFunction(queryBuilder);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 父或子的文档查询</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testChildQuery</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">QueryBuilder</span> <span class="variable">queryBuilder</span> <span class="operator">=</span> QueryBuilders.hasChildQuery(<span class="string">&quot;sonDoc&quot;</span>, QueryBuilders.termQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;vini&quot;</span>));</span><br><span class="line">        searchFunction(queryBuilder);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * moreLikeThisQuery: 实现基于内容推荐, 支持实现一句话相似文章查询</span></span><br><span class="line"><span class="comment">     * &#123;   </span></span><br><span class="line"><span class="comment">        &quot;more_like_this&quot; : &#123;   </span></span><br><span class="line"><span class="comment">        &quot;fields&quot; : [&quot;title&quot;, &quot;content&quot;],   // 要匹配的字段, 不填默认_all</span></span><br><span class="line"><span class="comment">        &quot;like_text&quot; : &quot;text like this one&quot;,   // 匹配的文本</span></span><br><span class="line"><span class="comment">        &#125;   </span></span><br><span class="line"><span class="comment">    &#125;     </span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    percent_terms_to_match：匹配项（term）的百分比，默认是0.3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    min_term_freq：一篇文档中一个词语至少出现次数，小于这个值的词将被忽略，默认是2</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    max_query_terms：一条查询语句中允许最多查询词语的个数，默认是25</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    stop_words：设置停止词，匹配时会忽略停止词</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    min_doc_freq：一个词语最少在多少篇文档中出现，小于这个值的词会将被忽略，默认是无限制</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    max_doc_freq：一个词语最多在多少篇文档中出现，大于这个值的词会将被忽略，默认是无限制</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    min_word_len：最小的词语长度，默认是0</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    max_word_len：最多的词语长度，默认无限制</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    boost_terms：设置词语权重，默认是1</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    boost：设置查询权重，默认是1</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    analyzer：设置使用的分词器，默认是使用该字段指定的分词器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMoreLikeThisQuery</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">QueryBuilder</span> <span class="variable">queryBuilder</span> <span class="operator">=</span> QueryBuilders.moreLikeThisQuery(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">                            .like(<span class="string">&quot;kimchy&quot;</span>);</span><br><span class="line"><span class="comment">//                            .minTermFreq(1)         //最少出现的次数</span></span><br><span class="line"><span class="comment">//                            .maxQueryTerms(12);        // 最多允许查询的词语</span></span><br><span class="line">        searchFunction(queryBuilder);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前缀查询</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPrefixQuery</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">QueryBuilder</span> <span class="variable">queryBuilder</span> <span class="operator">=</span> QueryBuilders.matchQuery(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;kimchy&quot;</span>);</span><br><span class="line">        searchFunction(queryBuilder);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询解析查询字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQueryString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">QueryBuilder</span> <span class="variable">queryBuilder</span> <span class="operator">=</span> QueryBuilders.queryStringQuery(<span class="string">&quot;+kimchy&quot;</span>);</span><br><span class="line">        searchFunction(queryBuilder);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 范围内查询</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRangeQuery</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">QueryBuilder</span> <span class="variable">queryBuilder</span> <span class="operator">=</span> QueryBuilders.rangeQuery(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">            .from(<span class="string">&quot;kimchy&quot;</span>)</span><br><span class="line">            .to(<span class="string">&quot;wenbronk&quot;</span>)</span><br><span class="line">            .includeLower(<span class="literal">true</span>)     <span class="comment">// 包含上界</span></span><br><span class="line">            .includeUpper(<span class="literal">true</span>);      <span class="comment">// 包含下届</span></span><br><span class="line">        searchFunction(queryBuilder);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 跨度查询</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSpanQueries</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="type">QueryBuilder</span> <span class="variable">queryBuilder1</span> <span class="operator">=</span> QueryBuilders.spanFirstQuery(QueryBuilders.spanTermQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;葫芦580娃&quot;</span>), <span class="number">30000</span>);     <span class="comment">// Max查询范围的结束位置  </span></span><br><span class="line">      </span><br><span class="line">         <span class="type">QueryBuilder</span> <span class="variable">queryBuilder2</span> <span class="operator">=</span> QueryBuilders.spanNearQuery()  </span><br><span class="line">                .clause(QueryBuilders.spanTermQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;葫芦580娃&quot;</span>)) <span class="comment">// Span Term Queries  </span></span><br><span class="line">                .clause(QueryBuilders.spanTermQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;葫芦3812娃&quot;</span>))  </span><br><span class="line">                .clause(QueryBuilders.spanTermQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;葫芦7139娃&quot;</span>))  </span><br><span class="line">                .slop(<span class="number">30000</span>)                                               <span class="comment">// Slop factor  </span></span><br><span class="line">                .inOrder(<span class="literal">false</span>)  </span><br><span class="line">                .collectPayloads(<span class="literal">false</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// Span Not</span></span><br><span class="line">         <span class="type">QueryBuilder</span> <span class="variable">queryBuilder3</span> <span class="operator">=</span> QueryBuilders.spanNotQuery()  </span><br><span class="line">                .include(QueryBuilders.spanTermQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;葫芦580娃&quot;</span>))  </span><br><span class="line">                .exclude(QueryBuilders.spanTermQuery(<span class="string">&quot;home&quot;</span>, <span class="string">&quot;山西省太原市2552街道&quot;</span>));  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// Span Or   </span></span><br><span class="line">         <span class="type">QueryBuilder</span> <span class="variable">queryBuilder4</span> <span class="operator">=</span> QueryBuilders.spanOrQuery()  </span><br><span class="line">                .clause(QueryBuilders.spanTermQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;葫芦580娃&quot;</span>))  </span><br><span class="line">                .clause(QueryBuilders.spanTermQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;葫芦3812娃&quot;</span>))  </span><br><span class="line">                .clause(QueryBuilders.spanTermQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;葫芦7139娃&quot;</span>));  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// Span Term  </span></span><br><span class="line">         <span class="type">QueryBuilder</span> <span class="variable">queryBuilder5</span> <span class="operator">=</span> QueryBuilders.spanTermQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;葫芦580娃&quot;</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试子查询</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTopChildrenQuery</span><span class="params">()</span> &#123;</span><br><span class="line">        QueryBuilders.hasChildQuery(<span class="string">&quot;tweet&quot;</span>, </span><br><span class="line">                QueryBuilders.termQuery(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;kimchy&quot;</span>))</span><br><span class="line">            .scoreMode(<span class="string">&quot;max&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通配符查询, 支持 * </span></span><br><span class="line"><span class="comment">     * 匹配任何字符序列, 包括空</span></span><br><span class="line"><span class="comment">     * 避免* 开始, 会检索大量内容造成效率缓慢</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testWildCardQuery</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">QueryBuilder</span> <span class="variable">queryBuilder</span> <span class="operator">=</span> QueryBuilders.wildcardQuery(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;ki*hy&quot;</span>);</span><br><span class="line">        searchFunction(queryBuilder);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 嵌套查询, 内嵌文档查询</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testNestedQuery</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">QueryBuilder</span> <span class="variable">queryBuilder</span> <span class="operator">=</span> QueryBuilders.nestedQuery(<span class="string">&quot;location&quot;</span>, </span><br><span class="line">                QueryBuilders.boolQuery()</span><br><span class="line">                    .must(QueryBuilders.matchQuery(<span class="string">&quot;location.lat&quot;</span>, <span class="number">0.962590433140581</span>))</span><br><span class="line">                    .must(QueryBuilders.rangeQuery(<span class="string">&quot;location.lon&quot;</span>).lt(<span class="number">36.0000</span>).gt(<span class="number">0.000</span>)))</span><br><span class="line">        .scoreMode(<span class="string">&quot;total&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试索引查询</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testIndicesQueryBuilder</span> <span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">QueryBuilder</span> <span class="variable">queryBuilder</span> <span class="operator">=</span> QueryBuilders.indicesQuery(</span><br><span class="line">                QueryBuilders.termQuery(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;kimchy&quot;</span>), <span class="string">&quot;index1&quot;</span>, <span class="string">&quot;index2&quot;</span>)</span><br><span class="line">                .noMatchQuery(QueryBuilders.termQuery(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;kimchy&quot;</span>));</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询遍历抽取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryBuilder</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">searchFunction</span><span class="params">(QueryBuilder queryBuilder)</span> &#123;</span><br><span class="line">        <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.prepareSearch(<span class="string">&quot;twitter&quot;</span>)</span><br><span class="line">                .setSearchType(SearchType.DFS_QUERY_THEN_FETCH)</span><br><span class="line">                .setScroll(<span class="keyword">new</span> <span class="title class_">TimeValue</span>(<span class="number">60000</span>))</span><br><span class="line">                .setQuery(queryBuilder)</span><br><span class="line">                .setSize(<span class="number">100</span>).execute().actionGet();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            response = client.prepareSearchScroll(response.getScrollId())</span><br><span class="line">                .setScroll(<span class="keyword">new</span> <span class="title class_">TimeValue</span>(<span class="number">60000</span>)).execute().actionGet();</span><br><span class="line">            <span class="keyword">for</span> (SearchHit hit : response.getHits()) &#123;</span><br><span class="line">                Iterator&lt;Entry&lt;String, Object&gt;&gt; iterator = hit.getSource().entrySet().iterator();</span><br><span class="line">                <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">                    Entry&lt;String, Object&gt; next = iterator.next();</span><br><span class="line">                    System.out.println(next.getKey() + <span class="string">&quot;: &quot;</span> + next.getValue());</span><br><span class="line">                    <span class="keyword">if</span>(response.getHits().hits().length == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        testResponse(response);</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对response结果的分析</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testResponse</span><span class="params">(SearchResponse response)</span> &#123;</span><br><span class="line">        <span class="comment">// 命中的记录数</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">totalHits</span> <span class="operator">=</span> response.getHits().totalHits();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (SearchHit searchHit : response.getHits()) &#123;</span><br><span class="line">            <span class="comment">// 打分</span></span><br><span class="line">            <span class="type">float</span> <span class="variable">score</span> <span class="operator">=</span> searchHit.getScore();</span><br><span class="line">            <span class="comment">// 文章id</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> Integer.parseInt(searchHit.getSource().get(<span class="string">&quot;id&quot;</span>).toString());</span><br><span class="line">            <span class="comment">// title</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">title</span> <span class="operator">=</span> searchHit.getSource().get(<span class="string">&quot;title&quot;</span>).toString();</span><br><span class="line">            <span class="comment">// 内容</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> searchHit.getSource().get(<span class="string">&quot;content&quot;</span>).toString();</span><br><span class="line">            <span class="comment">// 文章更新时间</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">updatetime</span> <span class="operator">=</span> Long.parseLong(searchHit.getSource().get(<span class="string">&quot;updatetime&quot;</span>).toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对结果设置高亮显示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHighLighted</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/*  5.0 版本后的高亮设置</span></span><br><span class="line"><span class="comment">         * client.#().#().highlighter(hBuilder).execute().actionGet();</span></span><br><span class="line"><span class="comment">        HighlightBuilder hBuilder = new HighlightBuilder();</span></span><br><span class="line"><span class="comment">        hBuilder.preTags(&quot;&lt;h2&gt;&quot;);</span></span><br><span class="line"><span class="comment">        hBuilder.postTags(&quot;&lt;/h2&gt;&quot;);</span></span><br><span class="line"><span class="comment">        hBuilder.field(&quot;user&quot;);        // 设置高亮显示的字段</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// 加入查询中</span></span><br><span class="line">        <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.prepareSearch(<span class="string">&quot;blog&quot;</span>)</span><br><span class="line">            .setQuery(QueryBuilders.matchAllQuery())</span><br><span class="line">            .addHighlightedField(<span class="string">&quot;user&quot;</span>)        <span class="comment">// 添加高亮的字段</span></span><br><span class="line">            .setHighlighterPreTags(<span class="string">&quot;&lt;h1&gt;&quot;</span>)</span><br><span class="line">            .setHighlighterPostTags(<span class="string">&quot;&lt;/h1&gt;&quot;</span>)</span><br><span class="line">            .execute().actionGet();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历结果, 获取高亮片段</span></span><br><span class="line">        <span class="type">SearchHits</span> <span class="variable">searchHits</span> <span class="operator">=</span> response.getHits();</span><br><span class="line">        <span class="keyword">for</span>(SearchHit hit:searchHits)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;String方式打印文档搜索内容:&quot;</span>);</span><br><span class="line">            System.out.println(hit.getSourceAsString());</span><br><span class="line">            System.out.println(<span class="string">&quot;Map方式打印高亮内容&quot;</span>);</span><br><span class="line">            System.out.println(hit.getHighlightFields());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;遍历高亮集合，打印高亮片段:&quot;</span>);</span><br><span class="line">            Text[] text = hit.getHighlightFields().get(<span class="string">&quot;title&quot;</span>).getFragments();</span><br><span class="line">            <span class="keyword">for</span> (Text str : text) &#123;</span><br><span class="line">                System.out.println(str.string());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>ElasticSearch</tag>
        <tag>查询</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch 快速入门</title>
    <url>/2018/10/17/ElasticSearch-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><p>1.安装</p>
<p>docker pull registry.docker-cn.com/library/elasticsearch</p>
<span id="more"></span>

<p>2.run</p>
<p>由于ElasticSearch 默认使用的堆内存为2G，在这里需要限制其使用内存的大小</p>
<p>docker run -e ES_JAVA_OPTS=”-Xms256m -Xmx256m” -d -p 9200:9200 -p9300:9300 –name elasticSearch01  IMAGE-ID</p>
<p>以上步骤完成之后，可在web页面访问对应ip的9200端口，出现返回了json数据为成功</p>
<p><img src="D:\Github\source_posts\ElasticSearch-快速入门\微信截图_20181017152618.png"></p>
<h4 id="使用-https-www-elastic-co-guide-cn-elasticsearch-guide-current-index-html"><a href="#使用-https-www-elastic-co-guide-cn-elasticsearch-guide-current-index-html" class="headerlink" title="使用(https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html)"></a>使用(<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html">https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html</a>)</h4><blockquote>
<p><a href="http://ip:9200/yourIndex/docName/key">http://ip:9200/yourIndex/docName/key</a></p>
</blockquote>
<h6 id="1）-添加数据"><a href="#1）-添加数据" class="headerlink" title="1）.添加数据"></a>1）.添加数据</h6><p>http请求方式为put, 数据类型为源数据 ,也就是row</p>
<blockquote>
<p>{<br>    “first_name” : “rifu”,<br>    “last_name” : “rifu”,<br>    “age” : 25,<br>    “interests” : [“basketball”,”tableball”]<br>}</p>
</blockquote>
<p>返回结果：结果码201</p>
<blockquote>
<p>{<br>    “_index”:”zava”,<br>    “_type”:”user”,<br>    “_id”:”1”,<br>    “_version”:1,<br>    “result”:”created”,<br>    “_shards”:{<br>        “total”:2,<br>        “successful”:1,<br>        “failed”:0<br>    },<br>    “created”:true<br>}</p>
</blockquote>
<h6 id="2）-获取数据"><a href="#2）-获取数据" class="headerlink" title="2）.获取数据"></a>2）.获取数据</h6><p>http请求方式为get</p>
<h6 id="3）-删除数据"><a href="#3）-删除数据" class="headerlink" title="3）.删除数据"></a>3）.删除数据</h6><p>http请求方式为delete</p>
<h6 id="4）-检查数据是否存在"><a href="#4）-检查数据是否存在" class="headerlink" title="4）.检查数据是否存在"></a>4）.检查数据是否存在</h6><p>http请求方式为head</p>
<p>数据存在响应码为200，不存在则为404</p>
<h6 id="5）-查询所有的数据"><a href="#5）-查询所有的数据" class="headerlink" title="5）.查询所有的数据"></a>5）.查询所有的数据</h6><p>get方式</p>
<blockquote>
<p> ip:9200/yourIndex/docName/_search</p>
</blockquote>
<h6 id="6）-带条件的查询"><a href="#6）-带条件的查询" class="headerlink" title="6）.带条件的查询"></a>6）.带条件的查询</h6><p>请求方式为post,数据放在请求体里面</p>
<blockquote>
<p>ip:9200/yourIndex/docName/_search</p>
<p>{</p>
<p>“query” : {</p>
<pre><code>&quot;match&quot;：&#123;

    &quot;last_name&quot; : &quot;rifu&quot;
</code></pre>
<p>​    }</p>
<p>}</p>
<p>}</p>
</blockquote>
<h4 id="SpringBoot使用ElasticSearch"><a href="#SpringBoot使用ElasticSearch" class="headerlink" title="SpringBoot使用ElasticSearch"></a>SpringBoot使用ElasticSearch</h4><p>一共有两种方式：</p>
<p>1.使用Jest</p>
<p>在配置文件里面：</p>
<blockquote>
<p>spring.elasticsearch.jest.uris=<a href="http://120.77.82.58:9200/">http://120.77.82.58:9200</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/io.searchbox/jest --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.searchbox&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jest&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">5.3</span><span class="number">.3</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>2.使用SpringData集成的elasticsearch</p>
<p>在配置文件里面：</p>
<blockquote>
<p>spring.data.elasticsearch.cluster-name=elasticsearch<br>spring.data.elasticsearch.cluster-nodes=120.77.82.58:9300</p>
</blockquote>
<p>使用springdata-elasticsearch需要注意版本适配问题</p>
<blockquote>
<table>
<thead>
<tr>
<th>spring data elasticsearch</th>
<th>elasticsearch</th>
</tr>
</thead>
<tbody><tr>
<td>3.1.x</td>
<td>6.2.2</td>
</tr>
<tr>
<td>3.0.x</td>
<td>5.5.0</td>
</tr>
<tr>
<td>2.1.x</td>
<td>2.4.0</td>
</tr>
<tr>
<td>2.0.x</td>
<td>2.2.0</td>
</tr>
<tr>
<td>1.3.x</td>
<td>1.5.2</td>
</tr>
</tbody></table>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>



<h5 id="1-使用JestClient"><a href="#1-使用JestClient" class="headerlink" title="1.使用JestClient"></a>1.使用JestClient</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 测试保存数据到elasticsearch</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSaveData</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">Msg</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Msg</span>();</span><br><span class="line">       msg.setId(<span class="number">1</span>);</span><br><span class="line">       msg.setSender(<span class="string">&quot;rifu&quot;</span>);</span><br><span class="line">       msg.setReceiver(<span class="string">&quot;lili&quot;</span>);</span><br><span class="line">       msg.setContent(<span class="string">&quot; i love you&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="type">Index</span> <span class="variable">index</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Index</span>.Builder(msg).index(<span class="string">&quot;zava&quot;</span>).type(<span class="string">&quot;msg&quot;</span>).build();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           jestClient.execute(index);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 测试查询数据</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectData</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> <span class="string">&quot;&#123;\n&quot;</span> +</span><br><span class="line">               <span class="string">&quot;    \&quot;query\&quot;: &#123;\n&quot;</span> +</span><br><span class="line">               <span class="string">&quot;        \&quot;match\&quot;: &#123;\n&quot;</span> +</span><br><span class="line">               <span class="string">&quot;            \&quot;content\&quot;: \&quot;love\&quot;\n&quot;</span> +</span><br><span class="line">               <span class="string">&quot;        &#125;\n&quot;</span> +</span><br><span class="line">               <span class="string">&quot;    &#125;\n&quot;</span> +</span><br><span class="line">               <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">       <span class="type">Search</span> <span class="variable">search</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Search</span>.Builder(json).addIndex(<span class="string">&quot;zava&quot;</span>).addType(<span class="string">&quot;msg&quot;</span>).build();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="type">SearchResult</span> <span class="variable">result</span> <span class="operator">=</span> jestClient.execute(search);</span><br><span class="line">           System.out.println(result.getJsonString());</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-使用Springdata-ElasticSearch"><a href="#2-使用Springdata-ElasticSearch" class="headerlink" title="2.使用Springdata-ElasticSearch"></a>2.使用Springdata-ElasticSearch</h5><p>首先要在对应的实体类上标注</p>
<blockquote>
<p>@Document(indexName = “zava”,type = “article”)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 保存数据到ES</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSaveArticle</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">Article</span> <span class="variable">article</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Article</span>();</span><br><span class="line">       article.setId(<span class="number">1</span>);</span><br><span class="line">       article.setAuthor(<span class="string">&quot;rifu&quot;</span>);</span><br><span class="line">       article.setTitle(<span class="string">&quot;天方夜谭&quot;</span>);</span><br><span class="line"></span><br><span class="line">       articleRepository.index(article);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>ElasticSearch</tag>
        <tag>分词器</tag>
        <tag>搜索引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>Eureka面试题集合</title>
    <url>/2020/09/17/Eureka%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<p>Eureka是Netflix组件的一个子模块，也是核心模块之一。云端服务发现，一个基于 REST 的服务，用于定位服务，以实现云端中间层服务发现和故障转移。下图总结了Eureka服务端（以下简称服务端）与Eureka客户端（以下简称客户端）之间协同工作的流程：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWRlci5zaGltby5pbS9mL2hHbzNZNXBDT3VZeG5POE4ucG5nIXRodW1ibmFpbA?x-oss-process=image/format,png" alt="img"> <span id="more"></span></p>
<p>流程说明：</p>
<ul>
<li>Eureka客户端（以下简称客户端）启动后，定时向Eureka服务端（以下简称服务端）注册自己的服务信息（服务名、IP、端口等）；</li>
<li>客户端启动后，定时拉取服务端以保存的服务注册信息；</li>
<li>拉取服务端保存的服务注册信息后，就可调用消费其他服务提供者提供的服务。</li>
</ul>
<p>虽然流程比较简单，但是在这样的简单流程下，Eureak究竟做了哪些工作，我们会有如下问题：</p>
<ol>
<li>客户端启动时如何注册到服务端？</li>
<li>服务端如何保存客户端服务信息？</li>
<li>客户端如何拉取服务端已保存的服务信息（是需要使用的时候再去拉取，还是先拉取保存本地，使用的时候直接从本地获取）？</li>
<li>如何构建高可用的Eureka集群？</li>
<li>心跳和服务剔除机制是什么？</li>
<li>Eureka自我保护机制是什么？</li>
</ol>
<p>要彻底搞清楚Eureka的工作流程，必须需要弄清楚这些问题，也是面试中常遇到的问题，接下来我将结合源码的方式对这些问题一一解答，源码版本说明：</p>
<ul>
<li>springboot：2.2.1.RELEASE</li>
<li>springcloud：Hoxton.SR1</li>
<li>Eureka:1.9.13</li>
</ul>
<h1 id="1、客户端启动时如何注册到服务端"><a href="#1、客户端启动时如何注册到服务端" class="headerlink" title="1、客户端启动时如何注册到服务端"></a>1、客户端启动时如何注册到服务端</h1><h2 id="1-1、源码分析"><a href="#1-1、源码分析" class="headerlink" title="1.1、源码分析"></a>1.1、源码分析</h2><p>Eureka客户端在启动后，会创建一些定时任务，其中就有一个任务heartbeatExecutor就是就是处理心跳的线程池，部分源码（源码位置：com.netflix.discovery.DiscoveryClient）如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">heartbeatExecutor = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">        <span class="number">1</span>, clientConfig.getHeartbeatExecutorThreadPoolSize(), <span class="number">0</span>, TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ThreadFactoryBuilder</span>()</span><br><span class="line">                .setNameFormat(<span class="string">&quot;DiscoveryClient-HeartbeatExecutor-%d&quot;</span>)</span><br><span class="line">                .setDaemon(<span class="literal">true</span>)</span><br><span class="line">                .build()</span><br><span class="line">);  <span class="comment">// use direct handoff</span></span><br><span class="line"> </span><br><span class="line">...此处省略其他代码</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//finally, init the schedule tasks (e.g. cluster resolvers, heartbeat, instanceInfo replicator, fetch</span></span><br><span class="line">initScheduledTasks();</span><br></pre></td></tr></table></figure>

<p>查看方法initScheduledTasks以及注释，可知该方法是初始化所有的任务（schedule tasks）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes all scheduled tasks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initScheduledTasks</span><span class="params">()</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// Heartbeat timer</span></span><br><span class="line">  scheduler.schedule(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">TimedSupervisorTask</span>(</span><br><span class="line">                <span class="string">&quot;heartbeat&quot;</span>,</span><br><span class="line">                scheduler,</span><br><span class="line">                heartbeatExecutor,</span><br><span class="line">                renewalIntervalInSecs,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                expBackOffBound,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">HeartbeatThread</span>()</span><br><span class="line">        ),</span><br><span class="line">        renewalIntervalInSecs, TimeUnit.SECONDS);</span><br><span class="line">   ...   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述方法中，第15行创建了一个线程HeartbeatThread，该线程就是处理心跳任务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The heartbeat task that renews the lease in the given intervals.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">HeartbeatThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (renew()) &#123;</span><br><span class="line">            lastSuccessfulHeartbeatTimestamp = System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Renew with the eureka service by making the appropriate REST call</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">renew</span><span class="params">()</span> &#123;</span><br><span class="line">    EurekaHttpResponse&lt;InstanceInfo&gt; httpResponse;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        httpResponse = eurekaTransport.registrationClient.sendHeartBeat(instanceInfo.getAppName(), instanceInfo.getId(), instanceInfo, <span class="literal">null</span>);</span><br><span class="line">        logger.debug(PREFIX + <span class="string">&quot;&#123;&#125; - Heartbeat status: &#123;&#125;&quot;</span>, appPathIdentifier, httpResponse.getStatusCode());</span><br><span class="line">        <span class="keyword">if</span> (httpResponse.getStatusCode() == Status.NOT_FOUND.getStatusCode()) &#123;</span><br><span class="line">            REREGISTER_COUNTER.increment();</span><br><span class="line">            logger.info(PREFIX + <span class="string">&quot;&#123;&#125; - Re-registering apps/&#123;&#125;&quot;</span>, appPathIdentifier, instanceInfo.getAppName());</span><br><span class="line">            <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> instanceInfo.setIsDirtyWithTime();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> register();</span><br><span class="line">            <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                instanceInfo.unsetIsDirty(timestamp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> success;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> httpResponse.getStatusCode() == Status.OK.getStatusCode();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        logger.error(PREFIX + <span class="string">&quot;&#123;&#125; - was unable to send heartbeat!&quot;</span>, appPathIdentifier, e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在renew方法中，首先会发送一个心跳数据到服务端，服务端返回一个状态码，如果是NOT_FOUND（即404），表示Eureka服务端不存在该客户端的服务信息，那么就会向服务端发起注册请求（上面代码25行调用register方法）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">register</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    logger.info(PREFIX + <span class="string">&quot;&#123;&#125;: registering service...&quot;</span>, appPathIdentifier);</span><br><span class="line">    EurekaHttpResponse&lt;Void&gt; httpResponse;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        httpResponse = eurekaTransport.registrationClient.register(instanceInfo);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.warn(PREFIX + <span class="string">&quot;&#123;&#125; - registration failed &#123;&#125;&quot;</span>, appPathIdentifier, e.getMessage(), e);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">        logger.info(PREFIX + <span class="string">&quot;&#123;&#125; - registration status: &#123;&#125;&quot;</span>, appPathIdentifier, httpResponse.getStatusCode());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> httpResponse.getStatusCode() == Status.NO_CONTENT.getStatusCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在register方法中，向服务端的注册信息instanceInfo，它是com.netflix.appinfo.InstanceInfo，包括服务名、ip、端口、唯一实例ID等信息。</p>
<h2 id="1-2、总结"><a href="#1-2、总结" class="headerlink" title="1.2、总结"></a>1.2、总结</h2><p>Eureka客户端在启动时，首先会创建一个心跳的定时任务，定时向服务端发送心跳信息，服务端会对客户端心跳做出响应，如果响应状态码为404时，表示服务端没有该客户端的服务信息，那么客户端则会向服务端发送注册请求，注册信息包括服务名、ip、端口、唯一实例ID等信息。</p>
<h1 id="2、服务端如何保存客户端服务信息"><a href="#2、服务端如何保存客户端服务信息" class="headerlink" title="2、服务端如何保存客户端服务信息"></a>2、服务端如何保存客户端服务信息</h1><h2 id="2-1、源码分析"><a href="#2-1、源码分析" class="headerlink" title="2.1、源码分析"></a>2.1、源码分析</h2><p>服务端注册源码（com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl.class的方法register）如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(<span class="keyword">final</span> InstanceInfo info, <span class="keyword">final</span> <span class="type">boolean</span> isReplication)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">leaseDuration</span> <span class="operator">=</span> Lease.DEFAULT_DURATION_IN_SECS;</span><br><span class="line">    <span class="keyword">if</span> (info.getLeaseInfo() != <span class="literal">null</span> &amp;&amp; info.getLeaseInfo().getDurationInSecs() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        leaseDuration = info.getLeaseInfo().getDurationInSecs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">super</span>.register(info, leaseDuration, isReplication);</span><br><span class="line">    replicateToPeers(Action.Register, info.getAppName(), info.getId(), info, <span class="literal">null</span>, isReplication);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第7行调用了父类（com.netflix.eureka.registry.AbstractInstanceRegistry）register方法，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractInstanceRegistry</span> <span class="keyword">implements</span> <span class="title class_">InstanceRegistry</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt; registry</span><br><span class="line">        = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt;();</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(InstanceInfo registrant, <span class="type">int</span> leaseDuration, <span class="type">boolean</span> isReplication)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        read.lock();</span><br><span class="line">        Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; gMap = registry.get(registrant.getAppName());</span><br><span class="line">        REGISTER.increment(isReplication);</span><br><span class="line">        <span class="keyword">if</span> (gMap == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ConcurrentHashMap&lt;String, Lease&lt;InstanceInfo&gt;&gt; gNewMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, Lease&lt;InstanceInfo&gt;&gt;();</span><br><span class="line">            gMap = registry.putIfAbsent(registrant.getAppName(), gNewMap);</span><br><span class="line">            <span class="keyword">if</span> (gMap == <span class="literal">null</span>) &#123;</span><br><span class="line">                gMap = gNewMap;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在register方法中，我们可以看到将服务实例信息InstanceInfo注册到了register变量中，它其实就是一个ConcurrentHashMap。</p>
<h2 id="2-2、总结"><a href="#2-2、总结" class="headerlink" title="2.2、总结"></a>2.2、总结</h2><p>客户端通过Jersey框架（亚马逊的一个http框架）将服务实例信息发送到服务端，服务端将客户端信息放在一个ConcurrentHashMap对象中。</p>
<h1 id="3、客户端如何拉取服务端已保存的服务信息"><a href="#3、客户端如何拉取服务端已保存的服务信息" class="headerlink" title="3、客户端如何拉取服务端已保存的服务信息"></a>3、客户端如何拉取服务端已保存的服务信息</h1><p>在知道客户端是如何拉取服务端信息的同时，也需要清楚以下问题：</p>
<blockquote>
<p>是需要时才去服务端拉取，还是先拉取到本地，需要用的时候直接从本地获取？</p>
</blockquote>
<h2 id="3-1、源码分析"><a href="#3-1、源码分析" class="headerlink" title="3.1、源码分析"></a>3.1、源码分析</h2><p>我们回到问题1的1.1节的initScheduledTasks方法中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initScheduledTasks</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (clientConfig.shouldFetchRegistry()) &#123;</span><br><span class="line">        <span class="comment">// registry cache refresh timer</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">registryFetchIntervalSeconds</span> <span class="operator">=</span> clientConfig.getRegistryFetchIntervalSeconds();</span><br><span class="line">        <span class="type">int</span> <span class="variable">expBackOffBound</span> <span class="operator">=</span> clientConfig.getCacheRefreshExecutorExponentialBackOffBound();</span><br><span class="line">        scheduler.schedule(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">TimedSupervisorTask</span>(</span><br><span class="line">                        <span class="string">&quot;cacheRefresh&quot;</span>,</span><br><span class="line">                        scheduler,</span><br><span class="line">                        cacheRefreshExecutor,</span><br><span class="line">                        registryFetchIntervalSeconds,</span><br><span class="line">                        TimeUnit.SECONDS,</span><br><span class="line">                        expBackOffBound,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">CacheRefreshThread</span>()</span><br><span class="line">                ),</span><br><span class="line">                registryFetchIntervalSeconds, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中初始化了一个刷新缓存的定时任务，我们看到第14行的新建了一个线程CacheRefreshThread（源码不再列出），既是用来定时刷新服务端已保存的服务信息。</p>
<h2 id="3-2、总结"><a href="#3-2、总结" class="headerlink" title="3.2、总结"></a>3.2、总结</h2><p>通过3.1节源码总结：客户端拉取服务端服务信息是通过一个定时任务定时拉取的，每次拉取后刷新本地已保存的信息，需要使用时直接从本地直接获取。</p>
<h1 id="4、如何构建高可用的Eureka集群"><a href="#4、如何构建高可用的Eureka集群" class="headerlink" title="4、如何构建高可用的Eureka集群"></a>4、如何构建高可用的Eureka集群</h1><p>首先，搭建一个高可用的Eureka集群，只需要在每个注册中心（服务端）通过配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">eureka.client.service-url.defaultZone</span><br></pre></td></tr></table></figure>

<p>指定其他服务端的地址，多个使用逗号隔开，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">eureka.client.service-url.defaultZone=http:<span class="comment">//localhost:10000/eureka/,http://localhost:10001/eureka/,http://localhost:10002/eureka/</span></span><br></pre></td></tr></table></figure>

<p>在eureka的高可用状态下，这些注册中心是对等的，他们会互相将注册在自己的实例同步给其他的注册中心，同样是通过问题1的方式将注册在自己上的实例注册到其他注册中心去。</p>
<p>那么问题来了，一旦 其中一个eureka收到一个客户端注册实例时，既然eureka注册中心将注册在自己的实例同步到其他注册中心中的方式和客户端注册的方式相同，那么在接收的eureka注册中心一端，会不会再同步回给注册中心（或者其他注册中心），从而导致死循环。</p>
<h2 id="4-1、源码解析"><a href="#4-1、源码解析" class="headerlink" title="4.1、源码解析"></a>4.1、源码解析</h2><p>我们回到2.1节的PeerAwareInstanceRegistryImpl类的register方法，在该方法中的最后一行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">replicateToPeers(Action.Register, info.getAppName(), info.getId(), info, null, isReplication);</span><br></pre></td></tr></table></figure>

<p>replicateToPeers方法字面意思是同步或者复制到同事（即其他对等的注册中心），最后一个参数为isReplication，是一个boolean值，表示是否同步（复制），如果是客户端注册的，那么为false,如果是其他注册中心同步的则为true，replicateToPeers方法中，如果isReplication=false时，将会发起同步（第19行）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">replicateToPeers</span><span class="params">(Action action, String appName, String id,</span></span><br><span class="line"><span class="params">                              InstanceInfo info <span class="comment">/* optional */</span>,</span></span><br><span class="line"><span class="params">                              InstanceStatus newStatus <span class="comment">/* optional */</span>, <span class="type">boolean</span> isReplication)</span> &#123;</span><br><span class="line">    <span class="type">Stopwatch</span> <span class="variable">tracer</span> <span class="operator">=</span> action.getTimer().start();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isReplication) &#123;</span><br><span class="line">            numberOfReplicationsLastMin.increment();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// If it is a replication already, do not replicate again as this will create a poison replication</span></span><br><span class="line">        <span class="keyword">if</span> (peerEurekaNodes == Collections.EMPTY_LIST || isReplication) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> PeerEurekaNode node : peerEurekaNodes.getPeerEurekaNodes()) &#123;</span><br><span class="line">            <span class="comment">// If the url represents this host, do not replicate to yourself.</span></span><br><span class="line">            <span class="keyword">if</span> (peerEurekaNodes.isThisMyUrl(node.getServiceUrl())) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            replicateInstanceActionsToPeers(action, appName, id, info, newStatus, node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        tracer.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2、总结"><a href="#4-2、总结" class="headerlink" title="4.2、总结"></a>4.2、总结</h2><ul>
<li><p>搭建高可用的Eureka集群，只需要在注册中心的配置文件中配置其他注册中心的地址，配置属性如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">eureka.client.service-url.defaultZone</span><br></pre></td></tr></table></figure>

</li>
<li><p>注册中心收到注册信息后会判断是否是其他注册中心同步的信息还是客户端注册的信息，如果是客户端注册的信息，那么他将会将该客户端信息同步到其他注册中心去；否则收到信息后不作任何操作。通过此机制避免集群中信息同步的死循环。</p>
</li>
</ul>
<h1 id="5、心跳和服务剔除机制是什么"><a href="#5、心跳和服务剔除机制是什么" class="headerlink" title="5、心跳和服务剔除机制是什么"></a>5、心跳和服务剔除机制是什么</h1><h2 id="5-1、源码分析"><a href="#5-1、源码分析" class="headerlink" title="5.1、源码分析"></a>5.1、源码分析</h2><p>在eureka源码中，有个evict（剔除，驱逐，源码位置：com.netflix.eureka.registry.AbstractInstanceRegistry，代码清单5.1）的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">evict</span><span class="params">(<span class="type">long</span> additionalLeaseMs)</span> &#123;</span><br><span class="line">    logger.debug(<span class="string">&quot;Running the evict task&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (!isLeaseExpirationEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;DS: lease expiration is currently disabled.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// We collect first all expired items, to evict them in random order. For large eviction sets,</span></span><br><span class="line">    <span class="comment">// if we do not that, we might wipe out whole apps before self preservation kicks in. By randomizing it,</span></span><br><span class="line">    <span class="comment">// the impact should be evenly distributed across all applications.</span></span><br><span class="line">    List&lt;Lease&lt;InstanceInfo&gt;&gt; expiredLeases = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt; groupEntry : registry.entrySet()) &#123;</span><br><span class="line">        Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; leaseMap = groupEntry.getValue();</span><br><span class="line">        <span class="keyword">if</span> (leaseMap != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Entry&lt;String, Lease&lt;InstanceInfo&gt;&gt; leaseEntry : leaseMap.entrySet()) &#123;</span><br><span class="line">                Lease&lt;InstanceInfo&gt; lease = leaseEntry.getValue();</span><br><span class="line">                <span class="keyword">if</span> (lease.isExpired(additionalLeaseMs) &amp;&amp; lease.getHolder() != <span class="literal">null</span>) &#123;</span><br><span class="line">                    expiredLeases.add(lease);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// To compensate for GC pauses or drifting local time, we need to use current registry size as a base for</span></span><br><span class="line">    <span class="comment">// triggering self-preservation. Without that we would wipe out full registry.</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">registrySize</span> <span class="operator">=</span> (<span class="type">int</span>) getLocalRegistrySize();</span><br><span class="line">    <span class="type">int</span> <span class="variable">registrySizeThreshold</span> <span class="operator">=</span> (<span class="type">int</span>) (registrySize * serverConfig.getRenewalPercentThreshold());</span><br><span class="line">    <span class="type">int</span> <span class="variable">evictionLimit</span> <span class="operator">=</span> registrySize - registrySizeThreshold;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> <span class="variable">toEvict</span> <span class="operator">=</span> Math.min(expiredLeases.size(), evictionLimit);</span><br><span class="line">    <span class="keyword">if</span> (toEvict &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;Evicting &#123;&#125; items (expired=&#123;&#125;, evictionLimit=&#123;&#125;)&quot;</span>, toEvict, expiredLeases.size(), evictionLimit);</span><br><span class="line"> </span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(System.currentTimeMillis());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; toEvict; i++) &#123;</span><br><span class="line">            <span class="comment">// Pick a random item (Knuth shuffle algorithm)</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> i + random.nextInt(expiredLeases.size() - i);</span><br><span class="line">            Collections.swap(expiredLeases, i, next);</span><br><span class="line">            Lease&lt;InstanceInfo&gt; lease = expiredLeases.get(i);</span><br><span class="line"> </span><br><span class="line">            <span class="type">String</span> <span class="variable">appName</span> <span class="operator">=</span> lease.getHolder().getAppName();</span><br><span class="line">            <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> lease.getHolder().getId();</span><br><span class="line">            EXPIRED.increment();</span><br><span class="line">            logger.warn(<span class="string">&quot;DS: Registry: expired lease for &#123;&#125;/&#123;&#125;&quot;</span>, appName, id);</span><br><span class="line">            internalCancel(appName, id, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码第4行，做了isLeaseExpirationEnabled（字面意思：是否启用租约到期，即是否开启了服务过期超时机制，开启之后就会将过期的服务进行剔除）的if判断，源码（com.netflix.eureka.registry</p>
<p>.PeerAwareInstanceRegistryImpl实现类中，代码清单5.2）如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLeaseExpirationEnabled</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isSelfPreservationModeEnabled()) &#123;</span><br><span class="line">        <span class="comment">// The self preservation mode is disabled, hence allowing the instances to expire.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numberOfRenewsPerMinThreshold &gt; <span class="number">0</span> &amp;&amp; getNumOfRenewsInLastMin() &gt; numberOfRenewsPerMinThreshold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样在上述方法开始的第3行也做了isSelfPreservationModeEnabled方法的判断，该方法是判断是否开启了自我保护机制（有关自我保护机制有关说明在第6节），接下来看到第4行的注释翻译如下：</p>
<blockquote>
<p>自保存模式被禁用，因此允许实例过期</p>
</blockquote>
<p>也就是说如果关闭了自我保护机制，那么直接就允许实例过期，也就是说可以将过期的服务实例剔除。那如果开启了自我保护机制，会做如下判断（代码清单5.3）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">numberOfRenewsPerMinThreshold &gt; <span class="number">0</span> &amp;&amp; getNumOfRenewsInLastMin() &gt; numberOfRenewsPerMinThreshold</span><br></pre></td></tr></table></figure>

<p>getNumOfRenewsInLastMin即最后一分钟接收到的心跳总数，numberOfRenewsPerMinThreshold 表示收到一分钟内收到服务心跳数临界值（后简称临界值），也就是说当临界值大于0，且最后一分钟接收到的心跳总数大于临界值时，允许实例过期，他的计算方式源码如下（代码清单5.4）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">updateRenewsPerMinThreshold</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.numberOfRenewsPerMinThreshold = (<span class="type">int</span>) (<span class="built_in">this</span>.expectedNumberOfClientsSendingRenews</span><br><span class="line">            * (<span class="number">60.0</span> / serverConfig.getExpectedClientRenewalIntervalSeconds())</span><br><span class="line">            * serverConfig.getRenewalPercentThreshold());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>this.expectedNumberOfClientsSendingRenews：接收到的客户端数量</li>
<li>serverConfig.getExpectedClientRenewalIntervalSeconds()：客户端发送心跳时间的间隔，默认是30秒</li>
<li>serverConfig.getRenewalPercentThreshold()：一个百分比率阈值，默认是0.85，可以通过配置修改</li>
</ul>
<p>从上述代码的计算方法可以看出：</p>
<blockquote>
<p>一分钟内收到服务心跳数临界值 = 客户端数量 * （60/心跳时间间隔） * 比率</p>
</blockquote>
<p>带入默认值：</p>
<blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">一分钟内收到服务心跳数临界值 = 客户端数量 * （60/30） * 0.85</span><br><span class="line">                       = 客户端数量 * 1.7</span><br></pre></td></tr></table></figure>
</blockquote>
<p>所以假如有总共有10个客户端，那么表示一分钟至少需要收到17次心跳。</p>
<p>所以代码清单5.3的解析就是，如果开启只我保护机制，那么一分钟内收到的心跳数大于一分钟内收到服务心跳数临界值时，则启用租约到期机制，即服务剔除机制。</p>
<p>那么最终回到代码清单5.1的第4行的if判断，即如果没有启用服务剔除机制（即开启了自我保护机制或者一分钟收到的心跳数小于临界值），那么直接return结束，不做任何操作。否则代码继续运行，从代码的第9行注释到最后，可以看出先跳出已过期的服务实例，然后通过随机数的方式将这些已过期的实例进行剔除。</p>
<h2 id="5-2、总结"><a href="#5-2、总结" class="headerlink" title="5.2、总结"></a>5.2、总结</h2><p>心跳机制：</p>
<ul>
<li>客户端启动后，就会启动一个定时任务，定时向服务端发送心跳数据，告知服务端自己还活着，默认的心跳时间间隔是30秒。</li>
</ul>
<p>服务剔除机制：</p>
<ul>
<li>如果开启了自我保护机制，那么所有的服务，包括长时间没有收到心跳的服务（即已过期的服务）都不会被剔除；</li>
<li>如果未开启自我保护机制，那么将判断最后一分钟收到的心跳数与一分钟收到心跳数临界值（计算方法参考5.1节）比较，如果前者大于后者，且后者大于0的话，则启用服务剔除机制；</li>
<li>一旦服务剔除机制开启，则Eureka服务端并不会直接剔除所有已过期的服务，而是通过随机数的方式进行剔除，避免自我保护开启之前将所有的服务（包括正常的服务）给剔除。</li>
</ul>
<h1 id="6、Eureka自我保护机制是什么"><a href="#6、Eureka自我保护机制是什么" class="headerlink" title="6、Eureka自我保护机制是什么"></a>6、Eureka自我保护机制是什么</h1><p>由于在第5节中已经提到了有关Eureka自我保护机制的用途以及它在服务剔除机制中起到的作用，这里不再结合源码分析，这里分析Eureka为什么要采用自我保护机制。</p>
<p>在分布式系统的CAP理论中，Eureka采用的AP，也就是Eureak保证了服务的可用性（A），而舍弃了数据的一致性（C）。当网络发生分区时，客户端和服务端的通讯将会终止，那么服务端在一定的时间内将收不到大部分的客户端的一个心跳，如果这个时候将这些收不到心跳的服务剔除，那可能会将可用的客户端剔除了，这就不符合AP理论。</p>
]]></content>
      <categories>
        <category>面试篇</category>
      </categories>
      <tags>
        <tag>Eureka</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Gitee 和 hexo 搭建个人博客</title>
    <url>/2020/02/27/Gitee+Hexo%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h3 id="一、搭建步骤"><a href="#一、搭建步骤" class="headerlink" title="一、搭建步骤"></a>一、搭建步骤</h3><h5 id="1）安装node-js"><a href="#1）安装node-js" class="headerlink" title="1）安装node.js"></a>1）安装node.js</h5><p>这个没什么好说的，直接官网下载，next,next</p>
<span id="more"></span>

<h5 id="2-安装git"><a href="#2-安装git" class="headerlink" title=")2 安装git"></a>)2 安装git</h5><p>同样简单，然后就是配置环境等，如果不会可以参考我的另一篇学习笔记部分</p>
<p><a href="https://rifu520.gitee.io/2018/10/10/Git/">https://rifu520.gitee.io/2018/10/10/Git/</a></p>
<h5 id="3-安装hexo"><a href="#3-安装hexo" class="headerlink" title="3) 安装hexo"></a>3) 安装hexo</h5><blockquote>
<p>npm install -g hexo-cli</p>
</blockquote>
<h5 id="4-安装好hexo-之后，找个空文件夹，执行以下命令"><a href="#4-安装好hexo-之后，找个空文件夹，执行以下命令" class="headerlink" title="4) 安装好hexo 之后，找个空文件夹，执行以下命令"></a>4) 安装好hexo 之后，找个空文件夹，执行以下命令</h5><blockquote>
<p>hexo init</p>
<p>npm install</p>
</blockquote>
<p>这里安装时间比较长，耐心等待</p>
<h3 id="二、关于目录"><a href="#二、关于目录" class="headerlink" title="二、关于目录"></a>二、关于目录</h3><h5 id="1-安装完hexo-之后，它的目录结构是这样的"><a href="#1-安装完hexo-之后，它的目录结构是这样的" class="headerlink" title="1) 安装完hexo 之后，它的目录结构是这样的"></a>1) 安装完hexo 之后，它的目录结构是这样的</h5><h5 id=""><a href="#" class="headerlink" title=""></a><img src="C:\Users\Lifu\Desktop\微信截图_20181012110406.png" alt="微信截图_20181012110406"></h5><p>解释一下各个文件的作用</p>
<h5 id="config-yml"><a href="#config-yml" class="headerlink" title="config.yml"></a>config.yml</h5><p>博客的配置文件，博客的名称、关键词、作者、语言、博客主题…设置都在里面。</p>
<h5 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h5><p>应用程序信息，新添加的插件内容也会出现在这里面，我们可以不修改这里的内容。</p>
<h5 id="scaffolds"><a href="#scaffolds" class="headerlink" title="scaffolds"></a>scaffolds</h5><p>scaffolds就是脚手架的意思，这里放了三个模板文件，分别是新添加博客文章（posts）、新添加博客页（page）和新添加草稿（draft）的目标样式。</p>
<p>这部分可以修改的内容是，我们可以在模板上添加比如categories等自定义内容</p>
<h5 id="source"><a href="#source" class="headerlink" title="source"></a>source</h5><p>source是放置我们博客内容的地方，里面初始只有两个文件夹，一个是drafts（草稿），一个posts（文章），但之后我们通过命令新建tags（标签）还有categories（分类）页后，这里会相应地增加文件夹。</p>
<h5 id="themes"><a href="#themes" class="headerlink" title="themes"></a>themes</h5><p>放置主题文件包的地方。Hexo会根据这个文件来生成静态页面。</p>
<p>初始状态下只有landscape一个文件夹，后续我们可以添加自己喜欢的。</p>
<h3 id="三、指令的使用"><a href="#三、指令的使用" class="headerlink" title="三、指令的使用"></a>三、指令的使用</h3><h5 id="init"><a href="#init" class="headerlink" title="init"></a><code>init</code></h5><p>新建一个网站。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br></pre></td></tr></table></figure>

<h5 id="new"><a href="#new" class="headerlink" title="new"></a><code>new</code></h5><p>新建文章或页面。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new &lt;layout&gt; &quot;title&quot;</span><br></pre></td></tr></table></figure>

<p>这里的<code>&lt;layout&gt;</code>对应我们要添加的内容，如果是<code>posts</code>就是添加新的文章，如果是<code>page</code>就是添加新的页面。</p>
<p>默认是添加<code>posts</code>。</p>
<p>然后我们就可以在对应的posts或drafts文件夹里找到我们新建的文件，然后在文件里用Markdown的格式来写作了。</p>
<h5 id="generate"><a href="#generate" class="headerlink" title="generate"></a><code>generate</code></h5><p>生成静态页面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure>

<p>也可以简写成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>

<h5 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a><code>deploy</code></h5><p>将内容部署到网站</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>

<p>也可以简写成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo -d</span><br></pre></td></tr></table></figure>

<h5 id="publish"><a href="#publish" class="headerlink" title="publish"></a><code>publish</code></h5><p>发布内容，实际上是将内容从drafts（草稿）文件夹移到posts（文章）文件夹。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo publish &lt;layout&gt; &lt;filename&gt;</span><br></pre></td></tr></table></figure>

<h5 id="server"><a href="#server" class="headerlink" title="server"></a><code>server</code></h5><p>启动服务器，默认情况下，访问网站为<code>http://localhost:4000/</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<p>也可以简写成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>



<h3 id="四、拓展"><a href="#四、拓展" class="headerlink" title="四、拓展"></a>四、拓展</h3><h5 id="1）添加分类"><a href="#1）添加分类" class="headerlink" title="1）添加分类"></a>1）添加分类</h5><p>新建分类页面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>

<p>给分类页面添加类型</p>
<p>我们在source文件夹中的categories文件夹下找到index.md文件，并在它的头部加上type属性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章分类</span><br><span class="line">date: 2017-05-27 13:47:40</span><br><span class="line">type: &quot;categories&quot;   #这部分是新添加的</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>给模板添加分类属性</p>
<p>现在我们打开scarffolds文件夹里的post.md文件，给它的头部加上<code>categories:</code>，这样我们创建的所有新的文章都会自带这个属性，我们只需要往里填分类，就可以自动在网站上形成分类了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">categories:</span><br><span class="line">tags:</span><br></pre></td></tr></table></figure>

<p>给文章添加分类</p>
<p>现在我们可以找到一篇文章，然后尝试给它添加分类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">layout: posts</span><br><span class="line">title: 写给小白的express学习笔记1： express-static文件静态管理</span><br><span class="line">date: 2018-06-07 00:38:36</span><br><span class="line">categories: 学习笔记</span><br><span class="line">tags: [node.js, express]</span><br></pre></td></tr></table></figure>

<h5 id="2）创建标签"><a href="#2）创建标签" class="headerlink" title="2）创建标签"></a>2）创建标签</h5><p>创建”标签”页的方式和创建“分类”一样。</p>
<ul>
<li><p>新建“标签”页面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure></li>
<li><p>给标签页面添加类型</p>
<p>我们在source文件夹中的tags文件夹下找到index.md文件，并在它的头部加上type属性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: tags</span><br><span class="line">date: 2018-08-06 22:48:29</span><br><span class="line">type: &quot;tags&quot; #新添加的内容</span><br></pre></td></tr></table></figure></li>
<li><p>给文章添加标签</p>
<p>有两种写法都可以，第一种是类似数组的写法，把标签放在中括号<code>[]</code>里，用英文逗号隔开</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">layout: posts</span><br><span class="line">title: gitee 和 hexo 搭建个人博客</span><br><span class="line">date: 2018-06-07 00:38:36</span><br><span class="line">categories: 学习笔记</span><br><span class="line">tags: [node.js, express]</span><br></pre></td></tr></table></figure>

<p>第二种写法是用<code>-</code>短划线列出来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">layout: posts</span><br><span class="line">title: 写给小白的express学习笔记1： express-static文件静态管理</span><br><span class="line">date: 2018-06-07 00:38:36</span><br><span class="line">categories: 学习笔记</span><br><span class="line">tags: </span><br><span class="line">- node.js</span><br><span class="line">- express</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="使用主题"><a href="#使用主题" class="headerlink" title="使用主题"></a>使用主题</h1><p>hexo有很多开源的主题，我选了<a href="https://github.com/iissnan/hexo-theme-next">NexT</a>，开始只是觉得很简洁清爽，后来发现它的功能挺齐全的，提前解决了很多搭建过程中会遇到的问题。这里强烈推荐一下。</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>我是用的<code>git clone</code>的方法，文档中还有其他方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<h4 id="设置主题"><a href="#设置主题" class="headerlink" title="设置主题"></a>设置主题</h4><p>在<strong>hexo根目录</strong>下的配置文件config.yml里设置主题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure>

<h4 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h4><p>接下来我们就可以来按需配置主题内容了，所有内容都在<strong>themes/next</strong>文件夹下的config.yml文件里修改。</p>
<p>官方文档里写的是有些配置需要将一部分代码添加到配置文件中，但其实不用，我们逐行看配置文件就会发现，有很多功能都已经放在配置文件里了，只是注释掉了，我们只需要取消注释，把需要的相关信息补全即可使用</p>
<h5 id="菜单栏-menu"><a href="#菜单栏-menu" class="headerlink" title="菜单栏 menu"></a>菜单栏 <code>menu</code></h5><p>原生菜单栏有主页、关于、分类、标签等数个选项，但是在配置文件中是注释掉的状态，这里我们自行修改注释就行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  # about: /about/ || user</span><br><span class="line">  tags: /tags/ || tags</span><br><span class="line">  categories: /categories/ || th</span><br><span class="line">  archives: /archives/ || archive</span><br><span class="line">  # schedule: /schedule/ || calendar</span><br><span class="line">  # sitemap: /sitemap.xml || sitemap</span><br><span class="line">  # commonweal: /404/ || heartbeat</span><br></pre></td></tr></table></figure>

<p>注意点：</p>
<ul>
<li>如果事先没有通过<code>hexo new page &lt;pageName&gt;</code>来创建页面的话，即使在配置文件中取消注释，页面也没法显示</li>
<li>我们也可以添加自己想要添加的页面，不用局限在配置文件里提供的选择里</li>
<li> <code>||</code>后面是fontAwesome里的文件对应的名称</li>
<li> <code>menu_icons</code>记得选<code>enable: true</code>（默认应该是<code>true</code>）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  # about: /about/ || user</span><br><span class="line">  tags: /tags/ || tags</span><br><span class="line">  categories: /categories/ || th</span><br><span class="line">  archives: /archives/ || archive</span><br><span class="line">  # schedule: /schedule/ || calendar</span><br><span class="line">  # sitemap: /sitemap.xml || sitemap</span><br><span class="line">  # commonweal: /404/ || heartbeat</span><br></pre></td></tr></table></figure>

<h5 id="主题风格-schemes"><a href="#主题风格-schemes" class="headerlink" title="主题风格 schemes"></a>主题风格 <code>schemes</code></h5><p>主题提供了4个，我们把想要选择的取消注释，其他三个保持注释掉的状态即可。</p>
<ul>
<li><code>Muse</code></li>
</ul>
<p>  <img src="https://upload-images.jianshu.io/upload_images/9240001-5e7193faf3720112.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="img"></p>
<p>  image-20180809164700600</p>
<ul>
<li>Mist</li>
</ul>
<p>  <img src="https://upload-images.jianshu.io/upload_images/9240001-dbd774ea0be0fe87.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="img"></p>
<p>  image-20180809164749052</p>
<ul>
<li>Pisces</li>
</ul>
<p>  <img src="https://upload-images.jianshu.io/upload_images/9240001-327385996d44bb02.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="img"></p>
<p>  image-20180809164925685</p>
<ul>
<li>Gemini</li>
</ul>
<p>  <img src="https://upload-images.jianshu.io/upload_images/9240001-0e58f7644c380210.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="img"></p>
<p>  image-20180809165023401</p>
<p>选择主题后也可以自定义，不过我还没摸清楚有哪些地方可以自定义，等弄清楚了我再来更新。</p>
<h5 id="底部建站时间和图标修改"><a href="#底部建站时间和图标修改" class="headerlink" title="底部建站时间和图标修改"></a>底部建站时间和图标修改</h5><p>修改主题的配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">footer:</span><br><span class="line">  # Specify the date when the site was setup.</span><br><span class="line">  # If not defined, current year will be used.</span><br><span class="line">  since: 2018</span><br><span class="line"></span><br><span class="line">  # Icon between year and copyright info.</span><br><span class="line">  icon: snowflake-o</span><br><span class="line"></span><br><span class="line">  # If not defined, will be used `author` from Hexo main config.</span><br><span class="line">  copyright:</span><br><span class="line">  # -------------------------------------------------------------</span><br><span class="line">  # Hexo link (Powered by Hexo).</span><br><span class="line">  powered: false</span><br><span class="line"></span><br><span class="line">  theme:</span><br><span class="line">    # Theme &amp; scheme info link (Theme - NexT.scheme).</span><br><span class="line">    enable: false</span><br><span class="line">    # Version info of NexT after scheme info (vX.X.X).</span><br><span class="line">    # version: false</span><br></pre></td></tr></table></figure>

<p>我在这部分做了这样几件事：</p>
<ul>
<li>把用户的图标从小人<code>user</code>改成了雪花<code>snowflake-o</code> </li>
<li> <code>copyright</code>留空，显示成页面<code>author</code>即我的名字</li>
<li> <code>powered: false</code>把hexo的授权图片取消了</li>
<li> <code>theme: enable:false</code> 把主题的内容也取消了</li>
</ul>
<p>这样底部信息比较简单。</p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Gitee</tag>
        <tag>hexo</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title>Git</title>
    <url>/2017/04/05/Git/</url>
    <content><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h3 id="一、环境配置"><a href="#一、环境配置" class="headerlink" title="一、环境配置"></a>一、环境配置</h3><p>git config –global user.name ‘yourname’</p>
<p>git config –global user.email ‘youremail’</p>
<p>git config –global core.autocrlf false     #由于开发环境不同，配置不要管换行转换符</p>
<span id="more"></span>

<p>git config –global core.quotepath off    #配置避免中文乱码</p>
<p>生成密钥</p>
<p>ssh-keygen -t rsa -C ‘your-email’</p>
<p>至此：window下的环境已配置好</p>
<p>在linux下还要配置：</p>
<p>ssh-add ~/.ssh/id_rsa</p>
<p>当出现问题：<img src="file:///C:/Users/Lifu/AppData/Local/YNote/data/qqC1328C0E098C90A13819B468B3DF0404/ba01a2b13f524be08aa84ec376802429/clipboard.png" alt="img"></p>
<p>执行：eval ‘ssh-agent’   ==注意：这里的这个’是 Esc 下面的那个==</p>
<p>再重新执行：ssh-add ~/.ssh/id_rsa</p>
<p>最后一步就是将公钥添加到你用的码云上</p>
<h3 id="二、添加远程仓库"><a href="#二、添加远程仓库" class="headerlink" title="二、添加远程仓库"></a>二、添加远程仓库</h3><p>git remote add origin ‘ssh-key’</p>
<p>git add .</p>
<p>git commit -m ‘’</p>
<p>git push -u origin  remote-branch -f  强制推送到远程分支（不建议使用，在第一次的时候可以这样）</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>版本控制器</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap和ConcurrentHashMap详解</title>
    <url>/2021/05/23/HashMap%E5%92%8CConcurrentHashMap%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h4 id="为什么JDK8的ConcurrentHashMap放弃使用Segment分段锁"><a href="#为什么JDK8的ConcurrentHashMap放弃使用Segment分段锁" class="headerlink" title="为什么JDK8的ConcurrentHashMap放弃使用Segment分段锁"></a>为什么JDK8的ConcurrentHashMap放弃使用Segment分段锁</h4><p>jdk1.7分段锁的实现</p>
<p>和hashmap一样，在jdk1.7中ConcurrentHashMap的底层数据结构是数组加链表。和hashmap不同的是ConcurrentHashMap中存放的数据是一段段的，即由多个Segment(段)组成的。每个Segment中都有着类似于数组加链表的结构。</p>
<h5 id="关于Segment"><a href="#关于Segment" class="headerlink" title="关于Segment"></a>关于Segment</h5><p>ConcurrentHashMap有3个参数：</p>
<ol>
<li>initialCapacity：初始总容量，默认16</li>
<li>loadFactor：加载因子，默认0.75</li>
<li>concurrencyLevel：并发级别，默认16</li>
</ol>
<p>其中并发级别控制了Segment的个数，在一个ConcurrentHashMap创建后Segment的个数是不能变的，扩容过程过改变的是每个Segment的大小。<span id="more"></span></p>
<h5 id="关于分段锁"><a href="#关于分段锁" class="headerlink" title="关于分段锁"></a>关于分段锁</h5><p>段Segment继承了重入锁ReentrantLock，有了锁的功能，每个锁控制的是一段，当每个Segment越来越大时，锁的粒度就变得有些大了。</p>
<ul>
<li>分段锁的优势在于保证在操作不同段 map 的时候可以并发执行，操作同段 map 的时候，进行锁的竞争和等待。这相对于直接对整个map同步synchronized是有优势的。</li>
<li>缺点在于分成很多段时会比较浪费内存空间(不连续，碎片化); 操作map时竞争同一个分段锁的概率非常小时，分段锁反而会造成更新等操作的长时间等待; 当某个段很大时，分段锁的性能会下降。</li>
</ul>
<h4 id="jdk1-8的map实现"><a href="#jdk1-8的map实现" class="headerlink" title="jdk1.8的map实现"></a>jdk1.8的map实现</h4><p>和hashmap一样,jdk 1.8中ConcurrentHashmap采用的底层数据结构为数组+链表+红黑树的形式。数组可以扩容，链表可以转化为红黑树。</p>
<h5 id="什么时候扩容？"><a href="#什么时候扩容？" class="headerlink" title="什么时候扩容？"></a>什么时候扩容？</h5><ol>
<li>当前容量超过阈值</li>
<li>当链表中元素个数超过默认设定（8个），当数组的大小还未超过64的时候，此时进行数组的扩容，如果超过则将链表转化成红黑树</li>
</ol>
<h5 id="什么时候链表转化为红黑树？"><a href="#什么时候链表转化为红黑树？" class="headerlink" title="什么时候链表转化为红黑树？"></a>什么时候链表转化为红黑树？</h5><p>当数组大小已经超过64并且链表中的元素个数超过默认设定（8个）时，将链表转化为红黑树</p>
<p>ConcurrentHashMap的put操作代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">        <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//初始化整个table</span></span><br><span class="line">                tab = initTable();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//初始化某个桶</span></span><br><span class="line">                <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>,</span><br><span class="line">                             <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">                    <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                <span class="comment">//当前table正在迁移，当前线程加入到数据迁移的工作中</span></span><br><span class="line">                tab = helpTransfer(tab, f);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">//对桶中的头结点进行同步加锁操作</span></span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        <span class="comment">//当前桶里面是链表</span></span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            binCount = <span class="number">1</span>;</span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                                K ek;</span><br><span class="line">                                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                    ((ek = e.key) == key ||</span><br><span class="line">                                     (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                    oldVal = e.val;</span><br><span class="line">                                    <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                Node&lt;K,V&gt; pred = e;</span><br><span class="line">                                <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                                    pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                              value, <span class="literal">null</span>);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//桶里面是一颗红黑树</span></span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                            Node&lt;K,V&gt; p;</span><br><span class="line">                            binCount = <span class="number">2</span>;</span><br><span class="line">                            <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                           value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                                oldVal = p.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    p.val = value;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//判断是否需要扩容</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                        treeifyBin(tab, i);</span><br><span class="line">                    <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                        <span class="keyword">return</span> oldVal;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>把数组中的每个元素看成一个桶。可以看到大部分都是CAS操作，加锁的部分是对桶的头节点进行加锁，锁粒度很小。</p>
<h5 id="为什么不用ReentrantLock而用synchronized"><a href="#为什么不用ReentrantLock而用synchronized" class="headerlink" title="为什么不用ReentrantLock而用synchronized ?"></a>为什么不用ReentrantLock而用synchronized ?</h5><ul>
<li>减少内存开销:如果使用ReentrantLock则需要节点继承AQS来获得同步支持，增加内存开销，而1.8中只有头节点需要进行同步。</li>
<li>内部优化:synchronized则是JVM直接支持的，JVM能够在运行时作出相应的优化措施：锁粗化、锁消除、锁自旋等等。</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
        <tag>ConcurrentHashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>JMM内存模型</title>
    <url>/2021/04/15/JMM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>高并发</tag>
        <tag>内存模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Java线程池的正确使用姿势</title>
    <url>/2020/04/13/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/</url>
    <content><![CDATA[<p>Executor框架是从JKD1.5之后开始引入，位于java.util.concurrent包下，其内部使用了线程池机制，控制线程的创建、执行和关闭，简化了并发变成的操作。</p>
<p><img src="https://img-blog.csdnimg.cn/20190921152211773.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5nbGlmdTUyMA==,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<span id="more"></span>

<p>Executor</p>
<p>Executor是一个接口，其定义了一个接收Runnable对象的方法executor，其方法签名为executor(Runnable command),该方法接收一个Runable实例，它用来执行一个任务，任务即一个实现了Runnable接口的类，一般来说，Runnable任务开辟在新线程中的使用方法为：new Thread(new RunnableTask())).start()，但在Executor中，可以使用Executor而不用显示地创建线程：executor.execute(new RunnableTask()); // 异步执行</p>
<p>ExecutorService</p>
<p>ExecutorService是一个使用比Executor更加广泛的子类接口，提供了对生命周期的管理方法，可跟踪一个或者多个异步任务的执行状况返回Future。可调用本身的shutdown()来平滑关闭ExecutorService(拒绝接受新的任务，已提交的任务会继续执行完毕)。</p>
<p>通过ExecutorService.submit()方法，可以得到Future,可以通过future.isDone()来判断当前任务是否已执行完成;也可以用future.get()来直接获取执行完成返回的结果。</p>
<p>Executors</p>
<p>Executors提供了一系列的工厂方法来创建线程池，返回的线程池都实现了ExecutorService接口。</p>
<ul>
<li><p>public static ExecutorService newFixedThreadPool(int Threads) 创建固定数目线程的线程池。</p>
</li>
<li><p>public static ExecutorService newCachedThreadPool()：创建一个可缓存的线程池，调用execute 将重用以前构造的线程（如果线程可用）。如果没有可用的线程，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。</p>
</li>
<li><p><em>public static ExecutorService newSingleThreadExecutor()：</em>创建一个单线程化的Executor。</p>
</li>
<li><p><em>public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)</em></p>
<p>创建一个支持定时及周期性的任务执行的线程池，多数情况下可用来替代Timer类。</p>
</li>
</ul>
<h3 id="线程池的正确使用"><a href="#线程池的正确使用" class="headerlink" title="线程池的正确使用"></a>线程池的正确使用</h3><p>以下是阿里编程规范的一段话：</p>
<p>线程池不允许使用Executors来创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加清楚线程池的运行规则，规避资源耗尽的风险。</p>
<p>Executors的各个方法的弊端：</p>
<p>newFixedThreadPool和newSingleThreadExecutor:</p>
<p>  堆积的处理请求队列可能会耗费非常大的内存，甚至造成OOM</p>
<p>newCachedThreadPool和newScheduledThreadPool:</p>
<p> 线程的最大数是Integer.MAX_VALUE,可能会创建数量非常大的线程，甚至OOM</p>
<p>正确的使用方式：</p>
<p>手动创建线程池</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> paramInt1, <span class="type">int</span> paramInt2, <span class="type">long</span> paramLong, TimeUnit paramTimeUnit,</span></span><br><span class="line"><span class="params">            BlockingQueue&lt;Runnable&gt; paramBlockingQueue, ThreadFactory paramThreadFactory,</span></span><br><span class="line"><span class="params">            RejectedExecutionHandler paramRejectedExecutionHandler)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.ctl = <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ctlOf(-<span class="number">536870912</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="built_in">this</span>.mainLock = <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        <span class="built_in">this</span>.workers = <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">        <span class="built_in">this</span>.termination = <span class="built_in">this</span>.mainLock.newCondition();</span><br><span class="line">        <span class="keyword">if</span> ((paramInt1 &lt; <span class="number">0</span>) || (paramInt2 &lt;= <span class="number">0</span>) || (paramInt2 &lt; paramInt1) || (paramLong &lt; <span class="number">0L</span>))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        <span class="keyword">if</span> ((paramBlockingQueue == <span class="literal">null</span>) || (paramThreadFactory == <span class="literal">null</span>) || (paramRejectedExecutionHandler == <span class="literal">null</span>))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="built_in">this</span>.corePoolSize = paramInt1;</span><br><span class="line">        <span class="built_in">this</span>.maximumPoolSize = paramInt2;</span><br><span class="line">        <span class="built_in">this</span>.workQueue = paramBlockingQueue;</span><br><span class="line">        <span class="built_in">this</span>.keepAliveTime = paramTimeUnit.toNanos(paramLong);</span><br><span class="line">        <span class="built_in">this</span>.threadFactory = paramThreadFactory;</span><br><span class="line">        <span class="built_in">this</span>.handler = paramRejectedExecutionHandler;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<ul>
<li>corePoolSize :线程池的核心池大小，在创建线程池之后，线程池默认没有任何线程。当有任务过来的时候才会去创建创建线程执行任务。换个说法，线程池创建之后，线程池中的线程数为0，当任务过来就会创建一个线程去执行，直到线程数达到corePoolSize 之后，就会被到达的任务放在队列中。（注意是到达的任务）。换句更精炼的话：corePoolSize 表示允许线程池中允许同时运行的最大线程数。如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。</li>
<li>maximumPoolSize :线程池允许的最大线程数，他表示最大能创建多少个线程。maximumPoolSize肯定是大于等于corePoolSize。</li>
<li>keepAliveTime :表示线程没有任务时最多保持多久然后停止。默认情况下，只有线程池中线程数大于corePoolSize 时，keepAliveTime 才会起作用。换句话说，当线程池中的线程数大于corePoolSize，并且一个线程空闲时间达到了keepAliveTime，那么就是shutdown。</li>
<li>Unit:keepAliveTime 的单位。</li>
<li>workQueue ：一个阻塞队列，用来存储等待执行的任务，当线程池中的线程数超过它的corePoolSize的时候，线程会进入阻塞队列进行阻塞等待。通过workQueue，线程池实现了阻塞功能。</li>
<li>threadFactory ：线程工厂，用来创建线程。</li>
<li>handler :表示当拒绝处理任务时的策略。</li>
</ul>
<h3 id="手动创建线程池应注意点"><a href="#手动创建线程池应注意点" class="headerlink" title="手动创建线程池应注意点"></a>手动创建线程池应注意点</h3><p>1.<strong>任务独立。</strong>如何任务依赖于其他任务，那么可能产生死锁。例如某个任务等待另一个任务的返回值或执行结果，那么除非线程池足够大，否则将发生线程饥饿死锁。</p>
<p>2.<strong>合理配置阻塞时间过长的任务。</strong>如果任务阻塞时间过长，那么即使不出现死锁，线程池的性能也会变得很糟糕。在Java并发包里可阻塞方法都同时定义了限时方式和不限时方式。例如</p>
<p>Thread.join,BlockingQueue.put,CountDownLatch.await等，如果任务超时，则标识任务失败，然后中止任务或者将任务放回队列以便随后执行，这样，无论任务的最终结果是否成功，这种办法都能够保证任务总能继续执行下去。</p>
<p>3.<strong>设置合理的线程池大小。</strong>只需要避免过大或者过小的情况即可，上文的公式**线程池大小=NCPU *UCPU(1+W/C)**。</p>
<p>4.<strong>选择合适的阻塞队列。</strong>newFixedThreadPool和newSingleThreadExecutor都使用了无界的阻塞队列，无界阻塞队列会有消耗很大的内存，如果使用了有界阻塞队列，它会规避内存占用过大的问题，但是当任务填满有界阻塞队列，新的任务该怎么办？在使用有界队列是，需要选择合适的拒绝策略，队列的大小和线程池的大小必须一起调节。对于非常大的或者无界的线程池，可以使用SynchronousQueue来避免任务排队，以直接将任务从生产者提交到工作者线程。</p>
<h3 id="线程池大小设定"><a href="#线程池大小设定" class="headerlink" title="线程池大小设定"></a>线程池大小设定</h3><p><strong>线程池的大小决定着系统的性能，过大或者过小的线程池数量都无法发挥最优的系统性能。</strong></p>
<p>当然线程池的大小也不需要做的太过于精确，只需要避免过大和过小的情况。一般来说，确定线程池的大小需要考虑CPU的数量，内存大小，任务是计算密集型还是IO密集型等因素</p>
<p><strong>NCPU = CPU的数量</strong></p>
<p><strong>UCPU = 期望对CPU的使用率 0 ≤ UCPU ≤ 1</strong></p>
<p><strong>W/C = 等待时间与计算时间的比率</strong></p>
<p><strong>如果希望处理器达到理想的使用率，那么线程池的最优大小为：</strong></p>
<p><strong>线程池大小=NCPU *UCPU(1+W/C)</strong></p>
<p>在Java中使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">ncpus</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>获取CPU的数量。</p>
<h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><blockquote>
<p>默认采用的是丢弃策略AbortPolicy</p>
</blockquote>
<ul>
<li><p>AbortPolicy:丢弃任务并抛出RejectedExecutionException</p>
</li>
<li><p>CallerRunsPolicy：只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务。显然这样做不会真的丢弃任务，但是，任务提交线程的性能极有可能会急剧下降。</p>
</li>
<li><p>DiscardOldestPolicy：丢弃队列中最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前任务。</p>
</li>
<li><p>DiscardPolicy：丢弃任务，不做任何处理。</p>
</li>
</ul>
<p>如果当前线程池中的线程数目&gt;=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务；如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务<strong>拒绝策略</strong>进行处理；</p>
]]></content>
      <categories>
        <category>高并发</category>
      </categories>
      <tags>
        <tag>线程池</tag>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>Interview</title>
    <url>/2021/04/17/Interview/</url>
    <content><![CDATA[<h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><h4 id="1-软件设计的六大原则"><a href="#1-软件设计的六大原则" class="headerlink" title="1.软件设计的六大原则"></a>1.软件设计的六大原则</h4><ul>
<li><strong>单一职责原则</strong>：不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责。</li>
<li><strong>里氏替换原则</strong>：子类可以扩展父类的功能，但不能改变父类原有的功能。</li>
<li><strong>依赖倒置原则</strong>：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。</li>
<li><strong>接口隔离原则</strong>：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。</li>
<li><strong>迪米特法则</strong>：一个对象应该对其他对象保持最少的了解。<span id="more"></span></li>
</ul>
<h4 id="2-设计模式"><a href="#2-设计模式" class="headerlink" title="2.设计模式"></a>2.设计模式</h4><ul>
<li><strong>单例模式</strong>：懒汉模式，饿汉模式</li>
<li><strong>工厂模式</strong>：</li>
<li><strong>代理模式</strong>：Proxy</li>
<li><strong>委派模式</strong>：JDBC的驱动加载，启动类加载器委派应用类加载器来加载对应的class文件</li>
<li><strong>策略模式</strong>：eg:操作符号-&gt;加、减、乘、除；一个接口有多个实现，一个抽象类有多个实现</li>
<li><strong>适配器模式</strong>：比如vga-html接头，实现两个接口，使得适配器同时拥有这两个接口的方法</li>
</ul>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h4 id="1-Redis的应用场景"><a href="#1-Redis的应用场景" class="headerlink" title="1.Redis的应用场景"></a>1.Redis的应用场景</h4><p>缓存、简单消息队列、分布式锁、共享session。</p>
<h4 id="2-Redis支持的数据类型"><a href="#2-Redis支持的数据类型" class="headerlink" title="2.Redis支持的数据类型"></a>2.Redis支持的数据类型</h4><ul>
<li><p>String      支持最大512M</p>
</li>
<li><p>List</p>
</li>
<li><p>Set</p>
</li>
<li><p>ZSet    底层的数据结构是跳表，增删查都达到了预期效果。</p>
</li>
<li><p>Hash</p>
</li>
</ul>
<h4 id="3-Redis的持久化"><a href="#3-Redis的持久化" class="headerlink" title="3.Redis的持久化"></a>3.Redis的持久化</h4><ul>
<li>RDB(默认)   快照的方式，fork一个子进程定期将数据转换为占用空间小的快照（例如每十分钟）,dump.rdb文件，使用的具体指令是bgsave，恢复数据快</li>
<li>AOF   将执行过的指令都存到一个aof文件里面，如果指令过多，恢复数据的效率很慢，但是顶多损坏一秒钟的数据</li>
</ul>
<p>Best：一般是使用这两种持久化方式结合，优先采用aof进行数据恢复，然后再使用rdb</p>
<h4 id="4-数据过期策略和内存淘汰机制"><a href="#4-数据过期策略和内存淘汰机制" class="headerlink" title="4.数据过期策略和内存淘汰机制"></a>4.数据过期策略和内存淘汰机制</h4><blockquote>
<p>Redis是使用<strong>定期删除</strong>和<strong>惰性删除</strong>两者配合的过期策略。</p>
</blockquote>
<p>定期删除：默认每个100ms就随机抽取设置了过期时间的key，判断是否过期，过期就删除。因为key太多，全盘扫描会耗费很多时间，所以是随机抽取，但是这样的策略不够完善，需要惰性删除来配合。</p>
<p>惰性删除：客户端获取某个key，redis会检测是否过期，是，则删除并且不会返回给客户端。</p>
<p>由于以上两种策略都无法解决redis使用内存过高问题，所以有了下面的内存淘汰机制。</p>
<ul>
<li><p>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。<strong>默认策略</strong></p>
</li>
<li><p>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。</p>
</li>
<li><p>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。</p>
</li>
<li><p>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。</p>
</li>
<li><p>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。</p>
</li>
<li><p>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。</p>
</li>
</ul>
<h4 id="5-Redis哈希槽的概念"><a href="#5-Redis哈希槽的概念" class="headerlink" title="5.Redis哈希槽的概念"></a>5.Redis哈希槽的概念</h4><p>Redis集群没有使用一致性哈希，而是引入了hash槽的概念，Redis集群有16384个哈希槽，每个key经过CRC16校验后对16384进行取模，来决定放置到哪个槽里面，集群的每个节点都会负责部分槽。</p>
<h4 id="6-Redis支持事务吗"><a href="#6-Redis支持事务吗" class="headerlink" title="6.Redis支持事务吗"></a>6.Redis支持事务吗</h4><p>Redis支持部分事务，但是不满足像mysql数据库定义的事务的四大特性ACID，不满足的部分是强一致性。</p>
<p>相关的指令：</p>
<ul>
<li>MULTI：开启一个事务，MULTI 执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中。</li>
<li>EXEC：执行队列中所有的命令。</li>
<li>DISCARD：清空事务队列,并放弃执行事务。</li>
<li>UNWATCH：取消 WATCH 命令对所有 key 的监视。</li>
<li>WATCH key1 key2 …    ：监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</li>
</ul>
<h4 id="7-如何保证-redis-中的数据都是热点数据"><a href="#7-如何保证-redis-中的数据都是热点数据" class="headerlink" title="7.如何保证 redis 中的数据都是热点数据"></a>7.如何保证 redis 中的数据都是热点数据</h4><p>这个其实考验的是Redis的6种内存淘汰机制，我们可以将内存淘汰机制设置为allkeys-lru或者volatile-lru。</p>
<p>具体的操作是到redis的配置文件里面修改以下属性：</p>
<blockquote>
<p>maxmemory-policy volatile-lru</p>
</blockquote>
<h4 id="8-keys和scan指令"><a href="#8-keys和scan指令" class="headerlink" title="8.keys和scan指令"></a>8.keys和scan指令</h4><p>使用keys 和scan可以扫出指定模式的key。</p>
<p>但是由于Redis是单线程的，keys指令会导致线程阻塞一段时间，如果是线上环境，建议使用scan指令，scan指令可以无阻塞的取出符合条件的key，但是会有一定的重复概率，需要客户端再进行一次去重，效率会比keys慢。</p>
<h4 id="9-使用Redis的分布式锁（基于Redission，看门狗的使用）"><a href="#9-使用Redis的分布式锁（基于Redission，看门狗的使用）" class="headerlink" title="9.使用Redis的分布式锁（基于Redission，看门狗的使用）"></a>9.使用Redis的分布式锁（基于Redission，看门狗的使用）</h4><p>具体指令就是SETNX(SET IF NOT EXIST)：尝试给某个key赋值，如果key不存在则赋值成功，并返回1，如果赋值不成功则返回0；设置成功后会给这个key设置过期时间。</p>
<p>看门狗的作用：有可能业务时间大于-锁的过期时间，这时候就会导致事务无法提交；看门狗能给占有的锁自动续期，保证业务完成之后能够正常释放持有的Redis锁。</p>
<h4 id="10-为什么Redis是单线程的，但是又能支持高并发"><a href="#10-为什么Redis是单线程的，但是又能支持高并发" class="headerlink" title="10.为什么Redis是单线程的，但是又能支持高并发"></a>10.为什么Redis是单线程的，但是又能支持高并发</h4><p>因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，多线程会增加一个上下文切换的消耗和锁的竞争条件，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p>
<p><strong>总结</strong>：</p>
<ul>
<li>操作的数据都是在内存里面</li>
<li>单线程，没有上下文的切换消耗资源</li>
<li>NIO多路复用机制</li>
</ul>
<h4 id="11-如何保证Redis和数据库的双写一致性"><a href="#11-如何保证Redis和数据库的双写一致性" class="headerlink" title="11.如何保证Redis和数据库的双写一致性"></a>11.如何保证Redis和数据库的双写一致性</h4><ul>
<li>懒加载模式缓存可采取双删+TTL失效来实现；</li>
<li>双删失败情况下可采取重试措施，重试有业务通过mq重试以及组件消费mysql的binlog再写入mq重试两种方式；</li>
<li>主动加载由于操作本身不具有幂等性，所以需要考虑加载的有序性问题，采取mq的分区机制实现串行化处理，实现缓存和mysql数据的最终一致，此时读和写操作的缓存加载事件是走的同一个mq。</li>
</ul>
<h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h4 id="1-synchronzied（jdk1-6以后）"><a href="#1-synchronzied（jdk1-6以后）" class="headerlink" title="1.synchronzied（jdk1.6以后）"></a>1.synchronzied（jdk1.6以后）</h4><blockquote>
<p>锁粗化的过程是不可逆的</p>
</blockquote>
<p>偏向锁-&gt;CAS-&gt;自旋锁-&gt;轻量级锁-&gt;重量级锁</p>
<p>接下来谈下锁升级的过程。</p>
<p>默认使用的锁是Mark Word。</p>
<p>线程来请求资源锁，会先判断当前资源的是否有锁，有锁的话回去判断锁的对象头里面存的线程id是否为自己，是的话可直接获得当前锁（偏向锁的体现）。如果不是自己，则会进行一次CAS，判断锁标记的线程是否还存活，如果线程已经结束，则直接改线程id修改为自己，如果线程是存活，则会继续进行CAS，重复上面步骤，此时晋升为轻量级锁，在一定的自旋失败后(默认10次)，会进一步变成重量级锁，会将自己挂起。</p>
<img src="https://image-static.segmentfault.com/237/957/2379573156-e0be89c7e6213336" alt="img" style="zoom:200%;" />



<h4 id="2-volatile"><a href="#2-volatile" class="headerlink" title="2.volatile"></a>2.volatile</h4><ul>
<li><p>线程中读取的时候，每次读取都会去主内存中读取共享变量最新的值，然后将其复制到工作内存</p>
</li>
<li><p>线程中修改了工作内存中变量的副本，修改之后会立即刷新到主内存</p>
</li>
</ul>
<p>Extra：volatile是如何实现内存的可见性？</p>
<blockquote>
<p>通过加入内存屏障和禁止重排优化来实现的。</p>
<p>在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障<br>在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障</p>
</blockquote>
<h2 id="Java高并发"><a href="#Java高并发" class="headerlink" title="Java高并发"></a>Java高并发</h2><h4 id="1-必须要清楚的几个概念"><a href="#1-必须要清楚的几个概念" class="headerlink" title="1.必须要清楚的几个概念"></a>1.必须要清楚的几个概念</h4><ul>
<li><strong>同步（Synchronous）和异步（Asynchronous）</strong>：同步方法一旦开始调用，调用者必须要等方法放回结果才能继续执行；异步更像是一个消息传递，一旦开始调用，立即返回，调用者继续后续的操作。</li>
<li><strong>并发（Concurrency）和并行（Parallelism）</strong>：并发侧重于线程的上下文切换；而并行是多个线程一起执行。</li>
<li><strong>临界区</strong>：临界区用来表示一种公共资源或者说共享数据，可以被多个线程使用，但是每一次只能有一个线程使用它，一旦临界区资源被占用，其他线程要想使用这个资源就必须等待。</li>
<li><strong>阻塞（Blocking）和非阻塞（Non-Blocking）</strong>：阻塞指的是多个线程请求同一个资源（临界区），但是某个时刻只能有一个线程享用，其他线程只能等待。非阻塞的意思和其相反，它强调的是多个线程之间不会互相影响，都可以正常执行。</li>
<li><strong>死锁（DeadLock）、饥饿（Stravation）和活锁（LiveLock）</strong>：死锁就不再阐述；饥饿优先级低的线程总是被优先级高的线程插队，导致很长时间拿不到资源锁，处于饥饿的状态；活锁指的是秉承“谦让”的原则，互相让出自己所占有的锁，导致资源都是在两个线程之前切换，而没有一个线程可以拿到所有的资源正常执行。</li>
</ul>
<h4 id="2-ReentrantLock"><a href="#2-ReentrantLock" class="headerlink" title="2.ReentrantLock"></a>2.ReentrantLock</h4><ul>
<li>ReentrantLock可以实现公平锁和非公平锁。</li>
<li>ReentrantLock默认实现的是非公平锁。</li>
<li>ReentrantLock的获取锁和释放锁必须成对出现，锁了几次，也要释放几次。</li>
<li>释放锁的操作必须放在finally中执行。</li>
<li>lockInterruptibly()实例方法可以相应线程的中断方法，调用线程的interrupt()方法时，lockInterruptibly()方法会触发 <code>InterruptedException</code>异常。</li>
<li>关于 <code>InterruptedException</code>异常说一下，看到方法声明上带有 <code>throwsInterruptedException</code>，表示该方法可以响应线程中断，调用线程的interrupt()方法时，这些方法会触发 <code>InterruptedException</code>异常，触发InterruptedException时，线程的中断中断状态会被清除。所以如果程序由于调用 <code>interrupt()</code>方法而触发 <code>InterruptedException</code>异常，线程的标志由默认的false变为ture，然后又变为false。</li>
<li>实例方法tryLock()获会尝试获取锁，会立即返回，返回值表示是否获取成功。</li>
<li>实例方法tryLock(long timeout, TimeUnit unit)会在指定的时间内尝试获取锁，指定的时间内是否能够获取锁，都会返回，返回值表示是否获取锁成功，该方法会响应线程的中断。</li>
</ul>
<table>
<thead>
<tr>
<th align="left">获取锁的方法</th>
<th align="left">是否立即响应(不会阻塞)</th>
<th align="left">是否响应中断</th>
</tr>
</thead>
<tbody><tr>
<td align="left">lock()</td>
<td align="left">×</td>
<td align="left">×</td>
</tr>
<tr>
<td align="left">lockInterruptibly()</td>
<td align="left">×</td>
<td align="left">√</td>
</tr>
<tr>
<td align="left">tryLock()</td>
<td align="left">√</td>
<td align="left">×</td>
</tr>
<tr>
<td align="left">tryLock(long timeout, TimeUnit unit)</td>
<td align="left">×</td>
<td align="left">√</td>
</tr>
</tbody></table>
<h4 id="3-Condition"><a href="#3-Condition" class="headerlink" title="3.Condition"></a>3.Condition</h4><ul>
<li>使用condition的步骤：创建condition对象，获取锁，然后调用condition的方法</li>
<li>一个ReentrantLock支持床多个condition对象</li>
<li>**void await() throws InterruptedException;**方法会释放锁，让当前线程等待，支持唤醒，支持线程中断</li>
<li><strong>void awaitUninterruptibly()</strong>;方法会释放锁，让当前线程等待，支持唤醒，不支持线程中断</li>
<li><strong>long awaitNanos(long nanosTimeout) throws InterruptedException</strong>;参数为纳秒，此方法会释放锁，让当前线程等待，支持唤醒，支持中断。超时之后返回的，结果为负数；超时之前被唤醒返回的，结果为正数（表示返回时距离超时时间相差的纳秒数）</li>
<li><strong>boolean await(longtime,TimeUnit unit) throws InterruptedException</strong>;方法会释放锁，让当前线程等待，支持唤醒，支持中断。超时之后返回的，结果为false；超时之前被唤醒返回的，结果为true</li>
<li><strong>boolean awaitUntil(Date deadline)throws InterruptedException</strong>;参数表示超时的截止时间点，方法会释放锁，让当前线程等待，支持唤醒，支持中断。超时之后返回的，结果为false；超时之前被唤醒返回的，结果为true</li>
<li><strong>void signal()</strong>;会唤醒一个等待中的线程，然后被唤醒的线程会被加入同步队列，去尝试获取锁</li>
<li><strong>void signalAll()</strong>;会唤醒所有等待中的线程，将所有等待中的线程加入同步队列，然后去尝试获取锁</li>
</ul>
<table>
<thead>
<tr>
<th align="left">对比项</th>
<th align="left">Object 监视器方法</th>
<th align="left">Condition</th>
</tr>
</thead>
<tbody><tr>
<td align="left">前置条件</td>
<td align="left">获取对象的锁</td>
<td align="left">调用Lock.lock获取锁，调用Lock.newCondition()获取Condition对象</td>
</tr>
<tr>
<td align="left">调用方式</td>
<td align="left">直接调用，如：object.wait()</td>
<td align="left">直接调用，如：condition.await()</td>
</tr>
<tr>
<td align="left">等待队列个数</td>
<td align="left">一个</td>
<td align="left">多个，使用多个condition实现</td>
</tr>
<tr>
<td align="left">当前线程释放锁并进入等待状态</td>
<td align="left">支持</td>
<td align="left">支持</td>
</tr>
<tr>
<td align="left">当前线程释放锁进入等待状态中不响应中断</td>
<td align="left">不支持</td>
<td align="left">支持</td>
</tr>
<tr>
<td align="left">当前线程释放锁并进入超时等待状态</td>
<td align="left">支持</td>
<td align="left">支持</td>
</tr>
<tr>
<td align="left">当前线程释放锁并进入等待状态到将来某个时间</td>
<td align="left">不支持</td>
<td align="left">支持</td>
</tr>
<tr>
<td align="left">唤醒等待队列中的一个线程</td>
<td align="left">支持</td>
<td align="left">支持</td>
</tr>
<tr>
<td align="left">唤醒等待队列中的全部线程</td>
<td align="left">支持</td>
<td align="left">支持</td>
</tr>
</tbody></table>
<h4 id="4-LockSupport"><a href="#4-LockSupport" class="headerlink" title="4.LockSupport"></a>4.LockSupport</h4><p><strong>LockSupport</strong>位于<strong>java.util.concurrent</strong>包中，是juc中一个基础类。</p>
<p>目前为止的3种让线程等待和唤醒的方式：</p>
<p>1.Object的wait和notify,notifyAll</p>
<p>2.Condition的await和signal,signalAll</p>
<p>3.LockSupport的park和unpark</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">Object</th>
<th align="left">Condtion</th>
<th>LockSupport</th>
</tr>
</thead>
<tbody><tr>
<td align="left">前置条件</td>
<td align="left">需要在synchronized中运行</td>
<td align="left">需要先获取Lock的锁</td>
<td>无</td>
</tr>
<tr>
<td align="left">无限等待</td>
<td align="left">支持</td>
<td align="left">支持</td>
<td>支持</td>
</tr>
<tr>
<td align="left">超时等待</td>
<td align="left">支持</td>
<td align="left">支持</td>
<td>支持</td>
</tr>
<tr>
<td align="left">等待到将来某个时间返回</td>
<td align="left">不支持</td>
<td align="left">支持</td>
<td>支持</td>
</tr>
<tr>
<td align="left">等待状态中释放锁</td>
<td align="left">会释放</td>
<td align="left">会释放</td>
<td>不会释放</td>
</tr>
<tr>
<td align="left"><strong>唤醒方法先于等待方法执行，能否唤醒线程</strong></td>
<td align="left">否</td>
<td align="left">否</td>
<td>可以</td>
</tr>
<tr>
<td align="left">是否能响应线程中断</td>
<td align="left">是</td>
<td align="left">是</td>
<td>是</td>
</tr>
<tr>
<td align="left">线程中断是否会清除中断标志</td>
<td align="left">是</td>
<td align="left">是</td>
<td>否</td>
</tr>
<tr>
<td align="left">是否支持等待状态中不响应中断</td>
<td align="left">不支持</td>
<td align="left">支持</td>
<td>不支持</td>
</tr>
</tbody></table>
<h4 id="5-Semaphore"><a href="#5-Semaphore" class="headerlink" title="5.Semaphore"></a>5.Semaphore</h4><p>常用场景：<strong>限流</strong>。</p>
<ul>
<li>**Semaphore(int permits)**：构造方法，参数表示许可证数量，用来创建信号量</li>
<li>**Semaphore(int permits,boolean fair)**：构造方法，当fair等于true时，创建具有给定许可数的计数信号量并设置为公平信号量</li>
<li><strong>void acquire() throws InterruptedException</strong>：从此信号量获取1个许可前线程将一直阻塞，相当于一辆车占了一个车位，此方法会响应线程中断，表示调用线程的interrupt方法，会使该方法抛出InterruptedException异常</li>
<li><strong>void acquire(int permits) throws InterruptedException</strong> ：和acquire()方法类似，参数表示需要获取许可的数量；比如一个大卡车要入停车场，由于车比较大，需要申请3个车位才可以停放</li>
<li><strong>void acquireUninterruptibly(int permits)</strong> ：和acquire(int permits) 方法类似，只是不会响应线程中断</li>
<li>**boolean tryAcquire()**：尝试获取1个许可，不管是否能够获取成功，都立即返回，true表示获取成功，false表示获取失败</li>
<li>**boolean tryAcquire(int permits)**：和tryAcquire()，表示尝试获取permits个许可</li>
<li><strong>boolean tryAcquire(long timeout, TimeUnit unit) throws InterruptedException</strong>：尝试在指定的时间内获取1个许可，获取成功返回true，指定的时间过后还是无法获取许可，返回false</li>
<li><strong>boolean tryAcquire(int permits, long timeout, TimeUnit unit) throws InterruptedException</strong>：和tryAcquire(long timeout, TimeUnit unit)类似，多了一个permits参数，表示尝试获取permits个许可</li>
<li>**void release()**：释放一个许可，将其返回给信号量，相当于车从停车场出去时将钥匙归还给门卫</li>
<li>**void release(int n)**：释放n个许可</li>
<li>**int availablePermits()**：当前可用的许可数</li>
</ul>
<h4 id="6-CountDownLatch（闭锁）"><a href="#6-CountDownLatch（闭锁）" class="headerlink" title="6.CountDownLatch（闭锁）"></a>6.CountDownLatch（闭锁）</h4><p>常用场景：等待所有线程一起到了再执行，或者等所有线程执行完了给回调。</p>
<p>常用方法：</p>
<ul>
<li><p>**public CountDownLatch(int count)**：构造方法，count表示计数器的值，不能小于0，否者会报异常。</p>
</li>
<li><p><strong>public void await() throws InterruptedException</strong>：调用await()会让当前线程等待，直到计数器为0的时候，方法才会返回，此方法会响应线程中断操作。</p>
</li>
<li><p><strong>public boolean await(long timeout, TimeUnit unit) throws InterruptedException</strong>：限时等待，在超时之前，计数器变为了0，方法返回true，否者直到超时，返回false，此方法会响应线程中断操作。</p>
</li>
<li><p>**public void countDown()**：让计数器减1</p>
<p>CountDownLatch使用步骤：</p>
<ol>
<li>创建CountDownLatch对象</li>
<li>调用其实例方法 <code>await()</code>，让当前线程等待</li>
<li>调用 <code>countDown()</code>方法，让计数器减1</li>
<li>当计数器变为0的时候， <code>await()</code>方法会返回</li>
</ol>
</li>
</ul>
<h4 id="7-CyclicBarrier（循环栅栏-循环屏障）"><a href="#7-CyclicBarrier（循环栅栏-循环屏障）" class="headerlink" title="7.CyclicBarrier（循环栅栏/循环屏障）"></a>7.CyclicBarrier（循环栅栏/循环屏障）</h4><p>常用场景：让一批线程等待然后一起执行。</p>
<p>它和CountDownLatch非常相似，不过CountDownLatch是让一批线程等待另一批线程执行完后再执行，而CyclicBarrier是使等待的线程达到一定数目后执行。</p>
<p>常用方法：</p>
<ul>
<li><p>public CyclicBarrier(int parties)：构造方法，指定等待线程的数目。</p>
</li>
<li><p>public void await() throws InterruptedException,BrokenBarrierException：调用await()让当前线程等待，如果有线程响应中断，则会抛出BrokenBarrierException，破坏当前的规则，然后会调用notifyAll()，唤醒之前所有在等待的线程。</p>
</li>
<li><p>public void await(long timeout, TimeUnit unit) throws InterruptedException,BrokenBarrierException,TimeoutException：某个线程只等待timeout时间，超过之后await会触发TimeoutException，然后线程继续往下执行，其他等待中的线程，新到的线程会在await方法直接抛出BrokenBarrierException，然后继续执行。</p>
</li>
<li><p>public void reset()：重置规则，新来的线程要继续等待（前提是之前有线程响应了中断抛出了BrokenBarrierException），达到一定数目后一起执行。</p>
</li>
</ul>
<h4 id="8-Unsafe"><a href="#8-Unsafe" class="headerlink" title="8.Unsafe"></a>8.Unsafe</h4><p>Unsafe是位于sum.misc下的一个类，主要提供一些执行低级别、不安全的操作方法。</p>
<p>常用场景：<strong>内存操作</strong>，<strong>CAS操作</strong>，<strong>Class相关</strong>，<strong>对象操作</strong>，<strong>线程调度</strong>，<strong>系统信息获取</strong>，<strong>内存屏障</strong>，<strong>数组操作</strong></p>
<p>其中我们常说的AtomicInteger这些原子操作类，底层都是使用了Unsafe的cas操作api；LockSupport则是用了Unsafe的park和unpark方法。</p>
<h4 id="9-JUC中的原子类"><a href="#9-JUC中的原子类" class="headerlink" title="9.JUC中的原子类"></a>9.JUC中的原子类</h4><p>原子类底层对数据的修改是用了CAS，但是CAS有可能产生ABA问题，一般我们的做法是给数据添加一个版本号，而每次修改都会讲版本号version+1，JUC也考虑到了这个问题，为我们提供了AtomicStampedReference。</p>
<p>public boolean compareAndSet(V   expectedReference,V   newReference,int expectedStamp, int newStamp)</p>
<h4 id="10-ThreadLocal"><a href="#10-ThreadLocal" class="headerlink" title="10.ThreadLocal"></a>10.ThreadLocal</h4><p>定义一个ThreadLocal.ThreadLocalMap，里面存着键值对，键是当前的线程id，值可以是基础类型的包装或者对象。（存储的位置在主内存）</p>
<h4 id="11-Queue"><a href="#11-Queue" class="headerlink" title="11.Queue"></a>11.Queue</h4><table>
<thead>
<tr>
<th align="left">操作类型</th>
<th align="left">抛出异常</th>
<th align="left">返回特殊值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">插入</td>
<td align="left"><code>add(e)</code></td>
<td align="left"><code>offer(e)</code>-返回（true/false）</td>
</tr>
<tr>
<td align="left">移除</td>
<td align="left"><code>remove()</code>为空抛出异常</td>
<td align="left"><code>poll()</code>为空返回null</td>
</tr>
<tr>
<td align="left">检查（返回队列头部元素，但不移除）</td>
<td align="left"><code>element()</code></td>
<td align="left"><code>peek()</code></td>
</tr>
</tbody></table>
<h4 id="12-BlockingQueue"><a href="#12-BlockingQueue" class="headerlink" title="12.BlockingQueue"></a>12.BlockingQueue</h4><ol>
<li>队列满的情况下，调用put方法会导致当前线程阻塞</li>
<li>队列为空的情况下，调用take方法会导致当前线程阻塞</li>
<li><code>offer(e,timeuout,unit)</code>，超时之前，插入成功返回true，否者返回false</li>
<li><code>poll(timeout,unit)</code>，超时之前，获取到头部元素并将其移除，返回true，否者返回false</li>
</ol>
<table>
<thead>
<tr>
<th align="left">操作类型</th>
<th align="left">抛出异常</th>
<th align="left">返回特殊值</th>
<th align="left">一直阻塞</th>
<th align="left">超时退出</th>
</tr>
</thead>
<tbody><tr>
<td align="left">插入</td>
<td align="left"><code>add(e)</code></td>
<td align="left"><code>offer(e)</code></td>
<td align="left">put(e)</td>
<td align="left">offer(e,timeuout,unit)</td>
</tr>
<tr>
<td align="left">移除</td>
<td align="left"><code>remove()</code></td>
<td align="left"><code>poll()</code></td>
<td align="left">take()</td>
<td align="left">poll(timeout,unit)</td>
</tr>
<tr>
<td align="left">检查</td>
<td align="left"><code>element()</code></td>
<td align="left"><code>peek()</code></td>
<td align="left">不支持</td>
<td align="left">不支持</td>
</tr>
</tbody></table>
<h4 id="13-可供选择的各种阻塞队列"><a href="#13-可供选择的各种阻塞队列" class="headerlink" title="13.可供选择的各种阻塞队列"></a>13.可供选择的各种阻塞队列</h4><ul>
<li><strong>ArrayBlockingQueue</strong></li>
</ul>
<p>基于数组的阻塞队列实现，其内部维护一个定长的数组，用于存储队列元素。线程阻塞的实现是通过ReentrantLock来完成的，数据的插入与取出共用同一个锁，因此ArrayBlockingQueue并不能实现生产、消费同时进行。而且在创建ArrayBlockingQueue时，我们还可以控制对象的内部锁是否采用公平锁，默认采用非公平锁。</p>
<ul>
<li><strong>LinkedBlockingQueue</strong></li>
</ul>
<p>基于单向链表的阻塞队列实现，在初始化LinkedBlockingQueue的时候可以指定大小，也可以不指定，默认类似一个无限大小的容量（Integer.MAX_VALUE），不指队列容量大小也是会有风险的，一旦数据生产速度大于消费速度，系统内存将有可能被消耗殆尽，因此要谨慎操作。另外LinkedBlockingQueue中用于阻塞生产者、消费者的锁是两个（锁分离），因此生产与消费是可以同时进行的。</p>
<ul>
<li><strong>PriorityBlockingQueue</strong></li>
</ul>
<p>一个支持优先级排序的无界阻塞队列，进入队列的元素会按照优先级进行排序。</p>
<p>优先级队列放入元素的时候，会进行排序，所以我们需要指定排序规则，有2种方式：</p>
<ol>
<li>创建<code>PriorityBlockingQueue</code>指定比较器<code>Comparator</code></li>
<li>放入的元素需要实现<code>Comparable</code>接口</li>
</ol>
<p>上面2种方式必须选一个，如果2个都有，则走第一个规则排序。</p>
<ul>
<li><strong>SynchronousQueue</strong></li>
</ul>
<p>同步阻塞队列，SynchronousQueue没有容量，与其他BlockingQueue不同，SynchronousQueue是一个不存储元素的BlockingQueue，每一个put操作必须要等待一个take操作，否则不能继续添加元素，反之亦然。</p>
<ul>
<li><strong>DelayQueue</strong></li>
</ul>
<p>DelayQueue是一个支持延时获取元素的无界阻塞队列，里面的元素全部都是“可延期”的元素，列头的元素是最先“到期”的元素，如果队列里面没有元素到期，是不能从列头获取元素的，哪怕有元素也不行，也就是说只有在延迟期到时才能够从队列中取元素。</p>
<ul>
<li><strong>LinkedTransferQueue</strong></li>
</ul>
<p>LinkedTransferQueue是基于链表的FIFO无界阻塞队列，它出现在JDK7中，Doug Lea 大神说LinkedTransferQueue是一个聪明的队列，它是ConcurrentLinkedQueue、SynchronousQueue(公平模式下)、无界的LinkedBlockingQueues等的超集，<code>LinkedTransferQueue</code>包含了<code>ConcurrentLinkedQueue、SynchronousQueue、LinkedBlockingQueues</code>三种队列的功能。</p>
<h4 id="14-高并发限流"><a href="#14-高并发限流" class="headerlink" title="14.高并发限流"></a>14.高并发限流</h4><p>如果是微服务的话，可借助豪猪哥<strong>Hystrix</strong>或者阿里巴巴的<strong>Sentinel</strong>来进行流控。</p>
<p>如果是单体应用可以考虑使用<strong>漏桶算法、令牌桶算法</strong>。</p>
<ul>
<li><p><strong>Redis</strong>：给接口级别或者ip设置对应kv,并设置过期时间，每次请求+1，达到限流的效果。</p>
</li>
<li><p><strong>漏桶算法</strong>：水（请求）先进入到漏桶里，漏桶以一定的速度出水，当水流入速度过大会直接溢出，可以看出漏桶算法能强行限制数据的传输速率。</p>
</li>
<li><p><strong>令牌桶算法</strong>：系统以恒定的速率产生令牌，然后把令牌放到令牌桶中，令牌桶有一个容量，当令牌桶满了的时候，再向其中放令牌，那么多余的令牌会被丢弃；当想要处理一个请求的时候，需要从令牌桶中取出一个令牌，如果此时令牌桶中没有令牌，那么则拒绝该请求。</p>
</li>
</ul>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h4 id="1-JDK动态代理和CGlib的区别"><a href="#1-JDK动态代理和CGlib的区别" class="headerlink" title="1.JDK动态代理和CGlib的区别"></a>1.JDK动态代理和CGlib的区别</h4><p>首先这两个都是动态代理，静态代理只有一个就是使用aspectj对java对象在编译时期就进行静态织入；而jdk动态代理是通过实现InvocationHandler，再使用proxy来调用其实现类的方法来进行反射代理，cglib是通过asm框架在对象加载时期，对其字节码进行修改生成子类来实现。</p>
<p><strong>编译</strong>：.java文件==&gt;.class文件</p>
<p><strong>加载</strong>：字节码文件通过加载，验证，准备，解析和初始化阶段（验证，准备，解析又统称作链接），被加载到jvm内存。</p>
<p><strong>java动态代理：</strong> 利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。</p>
<p><strong>cglib动态代理：</strong> 利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。</p>
<p><strong>JDK动态代理和CGLIB字节码生成的区别？</strong></p>
<ol>
<li>JDK动态代理只能对实现了接口的类生成代理，而不能针对类</li>
<li>CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法 因为是继承，所以该类或方法不要声明成final</li>
</ol>
<h4 id="2-JVM的内存模型（JMM）"><a href="#2-JVM的内存模型（JMM）" class="headerlink" title="2.JVM的内存模型（JMM）"></a>2.JVM的内存模型（JMM）</h4><blockquote>
<p>只是一种规范，并不是实际实现。</p>
</blockquote>
<p>堆：</p>
<p>方法区：</p>
<p>虚拟机栈：</p>
<p>本地方法栈：</p>
<p>程序计数器：</p>
<h4 id="3-垃圾回收机制"><a href="#3-垃圾回收机制" class="headerlink" title="3.垃圾回收机制"></a>3.垃圾回收机制</h4><p>强引用：即使爆出OOM也不会被回收。</p>
<p>软引用：内存不够就会被回收。</p>
<p>弱引用：每次GC都会被回收。</p>
<p>虚引用：可以用来跟踪GC，对象准备被回收时发现他还有虚引用，会把这个虚引用加入一个引用队列，可以观察这个队列中虚引用是否存在来判断对象是否被回收了。</p>
<h4 id="4-垃圾回收算法"><a href="#4-垃圾回收算法" class="headerlink" title="4.垃圾回收算法"></a>4.垃圾回收算法</h4><p>引用计数法：每有一个对该对象的引用，则引用加1，缺点：如果两个对象互相引用，将导致无法回收。</p>
<p>GCRoots：根可达法</p>
<h4 id="5-垃圾回收器"><a href="#5-垃圾回收器" class="headerlink" title="5.垃圾回收器"></a>5.垃圾回收器</h4><table><thead><tr><th style="width:284px;">垃圾回收器</th>
            <th style="width:685px;">特性</th>
        </tr></thead><tbody><tr><td style="width:284px;">串行（Serial）回收器</td>
            <td style="width:685px;">单线程的一个回收器，简单、易实现、效率高。</td>
        </tr><tr><td style="width:284px;">并行（ParNew）回收器</td>
            <td style="width:685px;">Serial的多线程版，可以充分的利用CPU资源，减少回收的时间。</td>
        </tr><tr><td style="width:284px;">吞吐量优先（Parallel Scavenge）回收器</td>
            <td style="width:685px;">侧重于吞吐量的控制</td>
        </tr><tr><td style="width:284px;">并发标记清除（CMS，Concurrent Mark Sweep）回收器</td>
            <td style="width:685px;">以获取最短回收停顿时间为目标的回收器，该回收器是基于“标记-清除”算法实现的。</td>
        </tr><tr><td style="width:284px;">Serial Old</td>
            <td style="width:685px;">Serial Old是Serial的老年代版本。同Serial一样， 它也是<strong>单线程</strong>收集器。用的是“<strong>标记——整理</strong>”算法。</td>
        </tr><tr><td style="width:284px;">Parallel Old</td>
            <td style="width:685px;">Parallel Old 是 Parallel Scavenge 的老年代版本，使用<strong>多线程</strong>和“<strong>标记——整理算法</strong>”。</td>
        </tr><tr><td style="width:284px;"><strong>G1（Garbage-First）</strong>收集器</td>
            <td style="width:685px;">G1 能充分利用多CPU的硬件优势，使用多个CPU来缩短“Stop The World”停顿时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。G1从整体来看是基于<strong>“标记-整理”</strong>算法实现的收集器，从局部（两个Region之间）上来看是基于<strong>“复制”</strong>算法实现的，这意味着G1运行期间不会产生内存空间碎片。</td>
        </tr></tbody></table>


<h4 id="6-指针压缩"><a href="#6-指针压缩" class="headerlink" title="6.指针压缩"></a>6.指针压缩</h4><p>从JDK1.6开始，在64位的操作系统中，JVM支持指针压缩，启用指针压缩：-XX:+UseCompressedOops；禁止指针压缩：-XX:-UseCompressedOops</p>
<p><strong>触发条件</strong>：在堆大小在【4-32】G的时候，会被触发；在堆内存小于4G时，不需要启用指针压缩，JVM会直接去除高32位地址，使用低虚拟地址空间。</p>
<p><strong>为什么要启用指针压缩</strong>：首先是提高了堆内存的可配置空间（32位最大堆空间为4G）；其次在64位操作系统中使用大指针在主内存和缓存之间移动数据，占用较大带宽，GC也会承受较大的压力，启用指针压缩可以减少消耗。</p>
<p><strong>压缩的是哪些信息</strong>：</p>
<ul>
<li><p>对象的全局静态变量(即类属性)</p>
</li>
<li><p>对象头信息:64位平台下，原生对象头大小为16字节，压缩后为12字节</p>
</li>
<li><p>对象的引用类型:64位平台下，引用类型本身大小为8字节，压缩后为4字节</p>
</li>
<li><p>对象数组类型:64位平台下，数组类型本身大小为24字节，压缩后16字节</p>
</li>
<li><p>以下信息不会被压缩：</p>
<ul>
<li>指向非Heap的对象指针</li>
<li>局部变量、传参、返回值、NULL指针</li>
</ul>
</li>
</ul>
<h2 id="网络协议篇"><a href="#网络协议篇" class="headerlink" title="网络协议篇"></a>网络协议篇</h2><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1594720933210.png" alt="1594720933210"></p>
<h4 id="1-TCP的三次握手和四次挥手"><a href="#1-TCP的三次握手和四次挥手" class="headerlink" title="1.TCP的三次握手和四次挥手"></a>1.TCP的三次握手和四次挥手</h4><ul>
<li><p>建立连接</p>
<img src="https://user-gold-cdn.xitu.io/2017/11/9/d8bf92c7906718271fdb8b0d2d5fe5b4?imageslim" alt="img" style="zoom: 80%;" /></li>
<li><p>断开连接</p>
</li>
</ul>
<img src="https://user-gold-cdn.xitu.io/2017/11/9/8c7874fafe233c9278509e40e906055c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" style="zoom:80%;" />

<p>问：为什么握手是三次而挥手是四次？</p>
<p>首先是客户端发送Fin报文告知服务端，我已发送数据完毕了，服务端收到报文后会立刻给客户端发送一个确认码，但是有可能服务端还有数据发送，所以需要等待发送完后才能发送Fin报文给客户端，当客户端收到Fin的回复，才能确认双方都发送完数据了，然后发送ack报文给服务端，至此，双方完成挥手操作。</p>
<h4 id="2-HTTP和HTTPS有什么区别"><a href="#2-HTTP和HTTPS有什么区别" class="headerlink" title="2.HTTP和HTTPS有什么区别"></a>2.HTTP和HTTPS有什么区别</h4><p>http监听的是22端口，HTTPS监听的是443接口，HTTPS是在http的基础上增加了一个ssl的验证。</p>
<h4 id="3-网络模型"><a href="#3-网络模型" class="headerlink" title="3.网络模型"></a>3.网络模型</h4><ul>
<li>OSI  7层网络模型———只是一个标准，并非实现。</li>
<li>TCP/IP 4层网络模型———-是一个实现的应用模型，由7层模型简化而来。</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2017/8/25/3fe5c91aafa1173c22b944e0ed8746c8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="file"></p>
<p>TCP/IP 协议中每层技术举例：</p>
<p>网络访问层：ARP、RARP</p>
<p>互联网层：ICMP、IP</p>
<p>传输层：TCP、UDP</p>
<p>应用层：DNS、FTP、HTTP、SMTP、TELNET、IRC、WHOIS</p>
<h4 id="4-TCP是如何保证传输的可靠性"><a href="#4-TCP是如何保证传输的可靠性" class="headerlink" title="4.TCP是如何保证传输的可靠性"></a>4.TCP是如何保证传输的可靠性</h4><ul>
<li><p>三次握手、四次挥手是保证可靠传输的前提</p>
</li>
<li><p>传输数据的切分为合适的数据块</p>
</li>
<li><p><strong>序列号和确认应答机制</strong>：传输时将每个报文的数据都进行了编号，这就是序列号；每次接收方收到数据都需要进行应答(就是发送ACK报文)，如果接收端通过校验序列号来判断有没有丢包，在ACK里面返回下一次需要发送的序列号。</p>
</li>
<li><p><strong>超时重传</strong>：发送过程中全体丢包或者收不到接收端发过来的ACK，选择动态计算时间来进行重传。</p>
</li>
<li><p><strong>使用滑动窗口进行流量控制</strong></p>
</li>
<li><p><strong>拥塞窗口</strong>：不是一开始就发送大量数据，而是慢慢增大达到阈值后窗口重置为1</p>
</li>
</ul>
<h4 id="10-聊聊SSL和TLS"><a href="#10-聊聊SSL和TLS" class="headerlink" title="10.聊聊SSL和TLS"></a>10.聊聊SSL和TLS</h4><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1594720668312.png" alt="1594720668312"></p>
<h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><h4 id="1-数据库引擎"><a href="#1-数据库引擎" class="headerlink" title="1.数据库引擎"></a>1.数据库引擎</h4><ul>
<li>MYISAM：只支持表锁，不支持事务，不支持外键。非聚集索引，使用B+Tree作为索引结构。</li>
<li>INNODB：支持行锁和表锁，支持事务，支持外键。聚集索引，使用B+Tree作为索引结构。</li>
</ul>
<h4 id="2-索引"><a href="#2-索引" class="headerlink" title="2.索引"></a>2.索引</h4><blockquote>
<p>索引是一种数据结构。</p>
</blockquote>
<ul>
<li>创建索引的原则<ul>
<li>最左前缀匹配原则，在索引列上进行函数操作、范围查询、使用不等于!=，或者like ‘%tmp’，均会导致索引失效。</li>
<li>频繁作为查询条件的字段才需要建立索引。</li>
<li>更新频繁，或者散列值很小（就是重复度很高）的字段不能建索引。</li>
<li>字段值太长的不能建索引。</li>
</ul>
</li>
<li>聚集索引和非聚集索引<ul>
<li>聚集索引：将数据存储与索引放到了一块，找到索引也就找到了数据。</li>
<li>非聚集索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据。</li>
</ul>
</li>
<li>三种常用的索引结构：Hash，B Tree ，B+ Tree（最好）<ul>
<li>Hash：hash索引底层就是hash表，进行查找时，调用hash函数就可以得到键值，然后进行回表查询。所以使用等值查询很快，但是无法进行范围查询。当某个键值大量重复时，会发生hash碰撞，效率很低。</li>
<li>Btree：可以存储在内部节点存储键和值。只适合进行随机检索。</li>
<li>B+Tree：内部节点只存储键，叶子结点存储值。支持随机检索和顺序检索。在使用了聚集索引的前提下，不需要再次进行回表查询。</li>
</ul>
</li>
</ul>
<h4 id="3-事务的四大特性-ACID"><a href="#3-事务的四大特性-ACID" class="headerlink" title="3.事务的四大特性(ACID)"></a>3.事务的四大特性(ACID)</h4><ul>
<li>原子性(Atomic)</li>
<li>一致性(Consitentcy)</li>
<li>隔离性(Isolation)</li>
<li>持久性(Durability)</li>
</ul>
<h4 id="4-标准的隔离级别"><a href="#4-标准的隔离级别" class="headerlink" title="4.标准的隔离级别"></a>4.标准的隔离级别</h4><ul>
<li>READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li>
<li>READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li>
<li>REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li>
<li>SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li>
</ul>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>读已提交</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>可重复读</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>可串行化</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
<blockquote>
<p>Mysql 默认采用的 REPEATABLE_READ隔离级别 </p>
<p>Oracle 默认采用的 READ_COMMITTED隔离级别</p>
</blockquote>
<h4 id="5-Mysql支持的锁"><a href="#5-Mysql支持的锁" class="headerlink" title="5.Mysql支持的锁"></a>5.Mysql支持的锁</h4><blockquote>
<p><a href="https://www.ibm.com/developerworks/cn/opensource/os-mysql-transaction-isolation-levels-and-locks/index.html">https://www.ibm.com/developerworks/cn/opensource/os-mysql-transaction-isolation-levels-and-locks/index.html</a></p>
</blockquote>
<p>InnoDB 实现了两种类型的行级锁：</p>
<ul>
<li><p>共享锁</p>
<p>（也称为 S 锁）：允许事务读取一行数据。</p>
<p>可以使用 SQL 语句 <code>select * from tableName where … lock in share mode;</code> 手动加 S 锁。</p>
</li>
<li><p>独占锁</p>
<p>（也称为 X 锁）：允许事务删除或更新一行数据。</p>
<p>可以使用 SQL 语句 <code>select * from tableName where … for update</code>; 手动加 X 锁。</p>
</li>
</ul>
<p>S 锁和 S 锁是<strong>兼容</strong>的，X 锁和其它锁都<strong>不兼容</strong>，举个例子，事务 T1 获取了一个行 r1 的 S 锁，另外事务 T2 可以立即获得行 r1 的 S 锁，此时 T1 和 T2 共同获得行 r1 的 S 锁，此种情况称为<strong>锁兼容</strong>，但是另外一个事务 T2 此时如果想获得行 r1 的 X 锁，则必须等待 T1 对行 r 锁的释放，此种情况也成为<strong>锁冲突</strong>。</p>
<p>为了实现多粒度的锁机制，InnoDB 还有两种内部使用的<strong>意向锁</strong>，由 InnoDB 自动添加，且都是表级别的锁。</p>
<ul>
<li><strong>意向共享锁</strong>（IS）：事务即将给表中的各个行设置共享锁，事务给数据行加 S 锁前必须获得该表的 IS 锁。</li>
<li><strong>意向排他锁</strong>（IX）：事务即将给表中的各个行设置排他锁，事务给数据行加 X 锁前必须获得该表 IX 锁。</li>
</ul>
<p>意向锁的主要目的是为了使得<strong>行锁</strong>和<strong>表锁</strong>共存。下面列出了行级锁和表级意向锁的兼容性。</p>
<table>
<thead>
<tr>
<th align="left"><strong>锁类型</strong></th>
<th align="left"><strong>X</strong></th>
<th align="left"><strong>IX</strong></th>
<th align="left"><strong>S</strong></th>
<th align="left"><strong>IS</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>X</strong></td>
<td align="left">冲突</td>
<td align="left">冲突</td>
<td align="left">冲突</td>
<td align="left">冲突</td>
</tr>
<tr>
<td align="left"><strong>IX</strong></td>
<td align="left">冲突</td>
<td align="left">兼容</td>
<td align="left">冲突</td>
<td align="left">兼容</td>
</tr>
<tr>
<td align="left"><strong>S</strong></td>
<td align="left">冲突</td>
<td align="left">冲突</td>
<td align="left">兼容</td>
<td align="left">兼容</td>
</tr>
<tr>
<td align="left"><strong>IS</strong></td>
<td align="left">冲突</td>
<td align="left">兼容</td>
<td align="left">兼容</td>
<td align="left">兼容</td>
</tr>
</tbody></table>
<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h4 id="1-IOC和AOP"><a href="#1-IOC和AOP" class="headerlink" title="1.IOC和AOP"></a>1.IOC和AOP</h4><p>IOC控制反转：也叫依赖注入(DI)，通过工厂模式来创建并管理Bean，并对其进行一个容器化管理。依赖注入的方式有两种，一个是构造器注入，另一种是通过调用setter方法注入。</p>
<p>AOP切面编程：一般用于权限控制，事务管理，日志记录等。</p>
<h4 id="2-IOC的初始化过程"><a href="#2-IOC的初始化过程" class="headerlink" title="2.IOC的初始化过程"></a>2.IOC的初始化过程</h4><ul>
<li>首先是初始化上下文-得到一个ClassPathXmlApplicationContext或者AnnotationApplicationContext</li>
<li>再获取resourcePatternResolver对象，将resources目录下的xml,properties文件解析生Resource对象</li>
<li>利用前面得到的上下文context和resource进行初始化工厂BeanFactory，将resource解析成BeanDefinition，然后将BeanDefinition注册到BeanFactory</li>
</ul>
<h4 id="3-Bean的创建过程"><a href="#3-Bean的创建过程" class="headerlink" title="3.Bean的创建过程"></a>3.Bean的创建过程</h4><ul>
<li>BeanDefinition解析：调用容器中InstantiationAwareBeanPostProcessor的postProcessBeforeInstantiation()方法，可以在Bean实例化前修改BeanDefinition。</li>
<li>实例化：将指定的BeanDefinition转换成BeanWrapper，然后调用createBeanInstance创建Bean的实例。Bean的实例化有多种策略，如工厂方法、指定参数构造器和默认无参构造器等。总之，createBeanInstance()方法会返回一个刚实例化好的、属性未赋值的空Bean。</li>
<li>属性填充：调用populateBean()方法，为Bean进行属性的赋值和依赖的注入。</li>
<li>属性填充后置处理：调用容器中InstantiationAwareBeanPostProcessor的postProcessAfterInstantiation()方法，进行属性填充后处理。</li>
<li>初始化前置处理：调用BeanPostProcessor的postProcessBeforeInitialization()方法进行初始化前置处理。</li>
<li>初始化：调用Bean的初始化方法，顺序为：InitializingBean的afterPropertiesSet() -&gt; 注册的init-method。</li>
<li>初始化后置处理：调用BeanPostProcessor的postProcessAfterInitialization()执行初始化后置处理。</li>
<li>调用registerDisposableBeanIfNecessary()方法，注册Bean的销毁处理逻辑：将所有实现了DisposableBean接口的或者注册了destroy-method方法的Bean,封装成一个DisposableBean,将其销毁的回调注册到容器中。</li>
</ul>
<h4 id="4-如何解决Bean循环依赖的问题"><a href="#4-如何解决Bean循环依赖的问题" class="headerlink" title="4.如何解决Bean循环依赖的问题"></a>4.如何解决Bean循环依赖的问题</h4><p>解决循环依赖是在初始化的时候进行。Spring为了解决循环依赖的问题引入了<strong>三级缓存</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Cache of singleton objects: bean name --&gt; bean instance：已经实例化并且初始化的对象 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, Object&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of early singleton objects: bean name --&gt; bean instance：已经实例化的对象 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of singleton factories: bean name --&gt; ObjectFactory:对象的构造工厂 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, ObjectFactory&lt;?&gt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure>

<p>下面是对源码的阅读解析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, <span class="type">boolean</span> allowEarlyReference)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">    <span class="comment">//判断对象是否为空&amp;bean是否正在创建中</span></span><br><span class="line">    <span class="comment">//isSingletonCurrentlyInCreation:当前单例是否正在创建中，就是未完成初始化</span></span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">            singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">            <span class="comment">//allowEarlyReference:是否允许从singletonFactories中通过getObject拿到对象</span></span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                ObjectFactory&lt;?&gt; singletonFactory = <span class="built_in">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                    <span class="built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                    <span class="built_in">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="literal">null</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>总：Spring首先从一级缓存singletonObjects中获取对象，获取不到并且对象正在创建中，再去二级缓存里面获取，如果还是获取不到，并且允许从从singletonFactories中通过getObject拿到对象，再去三级缓存singletonFactories里面获取，最后是一定能够获取到对象的，获取到之后，将对应的beanFactory从三级缓存移除，并将拿到的对象放入到二级缓存。</p>
<p><em>ps：Spring不能解决使用构造器注入的循环依赖。</em></p>
<h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><h4 id="1-处理请求的流程"><a href="#1-处理请求的流程" class="headerlink" title="1.处理请求的流程"></a>1.处理请求的流程</h4><ul>
<li>所有的客户端请求都会被DispatcherServlet所拦截</li>
<li>DispatcherServlet通过Handler Mappings来决定这个请求交给哪个Handler进行处理（我们可以理解为Controller）</li>
<li>Handler处理之后会返回一个ModelAndView对象给DispatcherServlet</li>
<li>DispatcherServlet将③的结果发送给View Resolver，经过解析后得到实际的View Page</li>
<li>DispatcherServlet将Model渲染到View上面，得到最后用户所看到的的页面。</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2019/5/19/16ad044ca097b7d4?imageslim" alt="img"></p>
<h2 id="分布式技术"><a href="#分布式技术" class="headerlink" title="分布式技术"></a>分布式技术</h2><h4 id="1-分布式锁和分布式事务"><a href="#1-分布式锁和分布式事务" class="headerlink" title="1.分布式锁和分布式事务"></a>1.分布式锁和分布式事务</h4><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><h4 id="1-基础"><a href="#1-基础" class="headerlink" title="1.基础"></a>1.基础</h4><p><strong>使用的通信协议</strong>：AMQP，ActiveMQ使用的是JMS</p>
<p><strong>角色</strong>：生产者、消费者、代理</p>
<p><strong>重要的组件</strong>：</p>
<ul>
<li>ConnectionFactory：应用程序和RabbitMQ建立连接的管理器</li>
<li>Channel：信道，用于消息传递的通道</li>
<li>Exchange：交换机（也可称作路由），用于接收和分配消息。</li>
<li>Queue：消息队列。</li>
<li>RoutingKey：路由键，用于指定消息发送到交换机的规则。</li>
<li>BindingKey：绑定键，用于交换机绑定消息队列。</li>
</ul>
<p><strong>广播的方式</strong>：</p>
<ul>
<li>fanout：扇出，所有绑定到该路由上面的消息队列都能收到消息。</li>
<li>direct：通过routingKey和exchange决定哪个消息队列可以接收到消息。例如(direct-test-route-key)</li>
<li>topic：所有符合routingkey绑定规则的消息队列都能收到消息(例如*-test-route-key)</li>
</ul>
<h4 id="2-如何避免消息丢失"><a href="#2-如何避免消息丢失" class="headerlink" title="2.如何避免消息丢失"></a>2.如何避免消息丢失</h4><ul>
<li><p>发送端进行发送确认</p>
</li>
<li><p>消息持久化（将交换机和队列进行持久化，设置队列的durable为true）</p>
</li>
<li><p>消费端ACK确认机制</p>
</li>
</ul>
<h4 id="3-如何实现延迟队列"><a href="#3-如何实现延迟队列" class="headerlink" title="3.如何实现延迟队列"></a>3.如何实现延迟队列</h4><p>首先必须要了解两个概念：</p>
<p>消息的过期时间Time-To-Live(TTL)和死信队列Dead Letter Exchanges(DLX)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">argument.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, <span class="string">&quot;your dlx name&quot;</span>)</span><br><span class="line">channel.queueDeclare(queueName, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, agruments);</span><br></pre></td></tr></table></figure>

<p>消息变成死信的原因有：</p>
<ul>
<li>消息过期了TTL</li>
<li>消息被拒绝了，并且reQueue = false</li>
<li>队列达到最大长度</li>
</ul>
<p>实现原理：给需要延时的消息设置过期时间，并发送到队列上，当消息过期后，会再通过DLX发送到死信队列上面，客户端通过消费死信队列的消息，通过消息中指定的消费队列，来再次进行发送。</p>
<h2 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h2><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h4><p>ElasticSearch是一款基于Luncene高效的全文搜索引擎。</p>
<ul>
<li>index == Mysql中的数据库，库里面可以建很多的表</li>
<li>type == 数据库表</li>
<li>document == 相当于一行记录</li>
<li>field == 相当于字段</li>
</ul>
<blockquote>
<p>PS : 在7.0版本后，去掉了type这个mapping。</p>
<p>具体原因可查看该文档<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/removal-of-types.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/removal-of-types.html</a></p>
</blockquote>
<h4 id="2-关于IK分词器"><a href="#2-关于IK分词器" class="headerlink" title="2.关于IK分词器"></a>2.关于IK分词器</h4><p>ElasticSearch使用的是IK分词器，对中文的分词也比较好。如果需要自定义分词效果，可以在elasticsearch目下的\plugins\ik\config下新建custom.dic，添加自定义的词汇，使用换行符分隔，最后在同等级的配置文件IKAnalyzer.cfg.xml中的<properties>添加<entry key="ext_dict">custom.dic</entry></p>
<h4 id="3-倒排索引"><a href="#3-倒排索引" class="headerlink" title="3.倒排索引"></a>3.倒排索引</h4><p>传统的通过关键字进行全文搜索，是遍历每篇文章是否包含改关键字；而倒排索引则恰恰相反，倒排索引在数据插入的时候，会先对文章进行分词，然后给所有词汇建立索引，格式为词汇 - &gt; 文章主键，形成词汇-文章的关系映射表，时间复杂度为O(1)。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/1/22/16874bae6bd24813?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>加分项：倒排索引底层是使用了FST（Finite State Tranducer）数据结构，它有两个优点：</p>
<p>1.空间占用小，通过对词典中单词前缀和后缀的重复利用，压缩了存储空间。</p>
<p>2.查询速度快。O(len(str))的查询时间复杂度。</p>
]]></content>
      <categories>
        <category>面试篇</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Idea 常用的插件</title>
    <url>/2018/10/16/Idea%20%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8%E7%AF%87/</url>
    <content><![CDATA[<p>记录一下本人在使用Idea 时用到的十分好用的插件</p>
<p><a href="http://plugins.jetbrains.com/idea">官方插件库</a></p>
<span id="more"></span>

<h5 id="一、ApiDebugger"><a href="#一、ApiDebugger" class="headerlink" title="一、ApiDebugger"></a>一、ApiDebugger</h5><h6 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h6><p><img src="https://upload-images.jianshu.io/upload_images/3335021-1d6eecf42c0bba00.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/498/format/webp" alt="img"></p>
<p>apidebugger.gif</p>
<h6 id="支持的请求方式"><a href="#支持的请求方式" class="headerlink" title="支持的请求方式"></a>支持的请求方式</h6><p><img src="https://upload-images.jianshu.io/upload_images/3335021-bd8655d3d1da1144.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/121/format/webp" alt="img"></p>
<p>method</p>
<p> 目前ApiDebugger支持 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET</span><br><span class="line">POST</span><br><span class="line">PUT</span><br><span class="line">PATCH</span><br><span class="line">DELETE</span><br><span class="line">HEAD</span><br><span class="line">OPTIONS</span><br><span class="line">TRACE</span><br></pre></td></tr></table></figure>



<h6 id="Header支持"><a href="#Header支持" class="headerlink" title="Header支持"></a>Header支持</h6><ol>
<li>发送Header<br> 可在请求发送区的Header内填写需要发送的Header键值对。</li>
</ol>
<p>   <img src="https://upload-images.jianshu.io/upload_images/3335021-a0a5cca6cab004e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/471/format/webp" alt="img"></p>
<p>   request-header</p>
<ol start="2">
<li>接收Header<br> 如果请求中携带Header数据，可在响应区Headers中查看到获取到的Header键值对。</li>
</ol>
<p>   <img src="https://upload-images.jianshu.io/upload_images/3335021-11605e3907721302.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/465/format/webp" alt="img"></p>
<p>   response-header</p>
<h6 id="Cookie支持"><a href="#Cookie支持" class="headerlink" title="Cookie支持"></a>Cookie支持</h6><p>如果请求中存在cookie，可在响应区中的<code>Cookies</code>查看所有cookie。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3335021-e42931c1eab718f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/467/format/webp" alt="img"></p>
<p>cookie</p>
<h6 id="多类型的Content-Type支持"><a href="#多类型的Content-Type支持" class="headerlink" title="多类型的Content-Type支持"></a>多类型的Content-Type支持</h6><p>支持多种Content-Type，包含<code>from-data</code> <code>x-www-urlencoded</code> <code>raw</code> <code>binary</code>。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3335021-5dea4df0b8f65476.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/470/format/webp" alt="img"></p>
<p>form-data</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3335021-a6a1b21013bdef14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/467/format/webp" alt="img"></p>
<p>binary</p>
<h6 id="响应支持高亮、格式化支持"><a href="#响应支持高亮、格式化支持" class="headerlink" title="响应支持高亮、格式化支持"></a>响应支持高亮、格式化支持</h6><p>在response区域中，body可支持响应内容的高亮，对html、json、xml等数据的格式化显示以及自动换行等。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3335021-a07369f1919012dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/465/format/webp" alt="img"></p>
<p>json</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3335021-6b15837d5317aba7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/467/format/webp" alt="img"></p>
<p>html</p>
<h6 id="多tab支持"><a href="#多tab支持" class="headerlink" title="多tab支持"></a>多tab支持</h6><p>这个过tab的支持可帮助你同时测多个API。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3335021-91d63c2c032d1160.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/507/format/webp" alt="img"></p>
<p>tabs</p>
<h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p>这个插件能直接在idea的右侧打开就可进行网络请求，真的超级方便，做了沉浸式的开发。</p>
<h5 id="二、MybatisX"><a href="#二、MybatisX" class="headerlink" title="二、MybatisX"></a>二、MybatisX</h5><p>mapper接口 与 mapper配置文件相互跳转</p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Idea</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 下安装 Nginx 教程</title>
    <url>/2019/04/12/Linux%20%E4%B8%8B%E5%AE%89%E8%A3%85Nginx%20%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h3 id="一、环境配置"><a href="#一、环境配置" class="headerlink" title="一、环境配置"></a>一、环境配置</h3><p>1.安装GCC</p>
<p>sudo apt-get install gcc</p>
<span id="more"></span>

<p>2.安装zlib</p>
<p>官网是<a href="http://www.zlib.net/">http://www.zlib.net/</a></p>
<pre><code>下载好之后解压

进入目录：执行文件sudo ./configure

执行sudo make

执行sudo make install    
</code></pre>
<p>3.安装pcre</p>
<p>sudo apt-get install pcre pcre-devel</p>
<p>(如果安装失败，可以自己去下载离线包<a href="ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/">ftp://ftp.csx.cam.ac.uk/../pub/software/programming/pcre/</a>)</p>
<pre><code>下载好之后解压 sudo tar -zxvf XXX

进入目录：执行文件sudo ./configure

执行sudo make

执行sudo make install
</code></pre>
<p>在执行./configure的时候，可能会说你没有安装c++的编译环境</p>
<p>这时候就需要去</p>
<p><img src="data:image/png;base64,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" alt="img"></p>
<p>sudo apt-get install build-essential</p>
<p><img src="data:image/png;base64,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" alt="img"></p>
<p>4.安装nginx</p>
<pre><code>下载之后解压

进入目录：执行文件sudo ./configure

执行sudo make
</code></pre>
<p>​    执行sudo make install</p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>版本控制器</tag>
        <tag>Nginx</tag>
        <tag>安装Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux搭建Jenkins持续化集成部署项目</title>
    <url>/2021/04/13/Linux%E6%90%AD%E5%BB%BAJenkins%E6%8C%81%E7%BB%AD%E5%8C%96%E9%9B%86%E6%88%90%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<blockquote>
<p>背景：由于之前在腾讯购买的云服务器过期，续费的价格虚高，导致最后放弃使用，之前部署的一套Jenkins环境丢失，刚好朋友的阿里云服务器一直处于置灰状态，拿过来重新搭一遍环境</p>
</blockquote>
<h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>需要搭建好JDK和Maven环境，这里就不做赘述。</p>
<p>同时去下载jenkins的war包，这里不建议在docker里面部署jenkins，很多坑。</p>
<p>如果是直接在本地下载的，需要上传到服务器，上传命令rz，这里如果提示命令不存在，则需要安装lszrz。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">安装lszrz插件</span></span><br><span class="line">yum install -y lszrz</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">上传指令</span></span><br><span class="line">rz</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">下载指令</span></span><br><span class="line">sz</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="跑起来"><a href="#跑起来" class="headerlink" title="跑起来"></a>跑起来</h3><p>先把下载好/上传好的jenkins.war执行起来。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">后台运行，并输出日志到out.log</span></span><br><span class="line">nohup java -jar jenkins.war &gt; out.log &amp;</span><br></pre></td></tr></table></figure>

<p>如果没有意外，在浏览器输入对应的ip+端口8080，即可以看到jenkins正在初始化。</p>
<p>首先第一步是要输入管理员的账号密码，默认密码是在目录/data/jenkins_home/secrets/initialAdminPassword</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果不知道密码在哪里，可以先查一下，这里选择在根目录下通过文件名称查询</span></span><br><span class="line">find / -name initialAdminPassword</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查到在哪里后，将里面的内容复制出来</span></span><br><span class="line">cat /data/jenkins_home/secrets/initialAdminPassword</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">拿到密码在页面上输入，即可进入主页面</span></span><br></pre></td></tr></table></figure>

<p>第二步是安装所需要的插件，这里额外提一个插件git parameter，这个可以在构建项目的时候选择构建的分支。</p>
<p>第三步是初始化一些全局配置，如maven、jdk、时间等。</p>
<p><img src="image-20210412151330194.png" alt="image-20210412151330194"></p>
<p><img src="image-20210412151422095.png" alt="image-20210412151402045"></p>
<p><img src="image-20210412151440186.png" alt="image-20210412151440186"></p>
<p>还有就是配置时间，如果不配置的话jenkins上显示的时间不正确，我们一般都是用的上海的时区,在【系统管理】-&gt;【脚本命令行】运行下面的命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">System.setProperty(&#x27;org.apache.commons.jelly.tags.fmt.timeZone&#x27;, &#x27;Asia/Shanghai&#x27;)</span><br></pre></td></tr></table></figure>

<p><img src="image-20210412151759256.png" alt="image-20210412151759256"></p>
<h3 id="部署项目"><a href="#部署项目" class="headerlink" title="部署项目"></a>部署项目</h3><p>先创建一个流水线项目</p>
<p><img src="image-20210412145624401.png" alt="image-20210412145624401"></p>
<p>接下来是配置预检分支，配置流水线步骤。</p>
<p>在参数化构建过程里面，我们选择一个git参数，这个参数是作为后面我们部署项目所使用的分支。</p>
<p><img src="image-20210412145935953.png" alt="image-20210412145935953"></p>
<p><img src="image-20210412150024211.png" alt="image-20210412150024211"></p>
<p>接下来配置流水线工作，先配置远程仓库</p>
<p><img src="image-20210412150216717.png" alt="image-20210412150216717"></p>
<p><img src="image-20210412150246555.png" alt="image-20210412150246555"></p>
<p>脚本路径我这里使用的是项目根目录下的文件，名称为Jenkinsfile，也可以直接用在线脚本的形式。</p>
<p>这里我填一个坑，就是上面截图最后的“轻量级检出”，如果勾选了这个选项，在上面指定的分支会获取不到，这里我检查了很久，因为看了其他博客这里配置是没问题的，后来在stack overflow查到了我想要的答案，就是不要勾选这里。</p>
<p>对应的Jenkinsfile我也贴出来，如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> def devUser = &#x27;root&#x27;</span><br><span class="line"></span><br><span class="line"> def project = &#x27;guns&#x27;</span><br><span class="line"></span><br><span class="line"> pipeline &#123;</span><br><span class="line"></span><br><span class="line">     agent any</span><br><span class="line"></span><br><span class="line">     parameters &#123;</span><br><span class="line"></span><br><span class="line">             gitParameter branchFilter: &#x27;origin/(.*)&#x27;, defaultValue: &#x27;master&#x27;, name: &#x27;BRANCH&#x27;, type: &#x27;PT_BRANCH&#x27;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">     stages &#123;</span><br><span class="line"></span><br><span class="line">         stage(&#x27;代码更新&#x27;) &#123;</span><br><span class="line"></span><br><span class="line">             steps &#123;</span><br><span class="line">             #这里的credentialsId在jenkins的全局凭据里面可看到</span><br><span class="line">                 git branch: &#x27;$BRANCH&#x27;,credentialsId: &#x27;huanglifu&#x27;,</span><br><span class="line">                     url: &#x27;https://gitee.com/rifu520/guns.git&#x27;</span><br><span class="line">                     </span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         stage(&#x27;构建代码&#x27;) &#123;</span><br><span class="line"></span><br><span class="line">             steps &#123;</span><br><span class="line"></span><br><span class="line">                 sh &#x27;mvn clean compile&#x27;</span><br><span class="line"></span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         stage(&#x27;打包服务&#x27;) &#123;</span><br><span class="line"></span><br><span class="line">             steps &#123;</span><br><span class="line"></span><br><span class="line">                 echo &#x27;开始打包&#x27;</span><br><span class="line">                 </span><br><span class="line">                 sh &#x27;mvn package -Dmaven.test.skip=true&#x27;</span><br><span class="line">                 </span><br><span class="line">                 echo &#x27;打包完成&#x27;</span><br><span class="line"></span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         stage(&#x27;创建镜像&#x27;) &#123;</span><br><span class="line"></span><br><span class="line">             steps &#123;</span><br><span class="line"></span><br><span class="line">                 sh &quot;&quot;&quot;</span><br><span class="line">cd guns-main</span><br><span class="line"></span><br><span class="line">                     mv -f target/*.jar ./$&#123;project&#125;.jar</span><br><span class="line"></span><br><span class="line">                     docker build -t $&#123;project&#125;:$BUILD_NUMBER .</span><br><span class="line"></span><br><span class="line">                     rm -f ./$&#123;project&#125;.jar</span><br><span class="line"></span><br><span class="line">                 &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         stage(&#x27;部署生产环境&#x27;) &#123;</span><br><span class="line"></span><br><span class="line">             steps &#123;</span><br><span class="line"></span><br><span class="line">                 sh &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">                     docker  rm -f $&#123;project&#125; | true</span><br><span class="line"></span><br><span class="line">                     docker  run -d --name $&#123;project&#125; -p 9090:9090 -v /home/service/guns:/guns -e &quot;spring.profiles.active=dev&quot;  --restart=always $&#123;project&#125;:$BUILD_NUMBER</span><br><span class="line"></span><br><span class="line">                 &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>





<p>以下是dockerfile</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM java:8-jre</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">作者</span></span><br><span class="line">MAINTAINER rifu</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">时区</span></span><br><span class="line">ENV TZ Asia/Shanghai</span><br><span class="line">RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo $TZ &gt; /etc/timezone; mkdir -p guns</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">端口</span></span><br><span class="line">EXPOSE 9090</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">应用包</span></span><br><span class="line">ADD guns.jar /usr/local/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动命令</span></span><br><span class="line">ENTRYPOINT java -Xms512m -Xmx512m \</span><br><span class="line">-XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=128m \</span><br><span class="line">-XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:guns/gc.log \</span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=guns/heap.log \</span><br><span class="line">-XX:ErrorFile=guns/hs_err_pid%p.log \</span><br><span class="line">-jar /usr/local/guns.jar \</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
        <tag>持续化集成CI/CD</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis面试题集合</title>
    <url>/2020/10/17/Mybatis%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h2 id="MyBatis简介"><a href="#MyBatis简介" class="headerlink" title="MyBatis简介"></a>MyBatis简介</h2><h3 id="MyBatis是什么？"><a href="#MyBatis是什么？" class="headerlink" title="MyBatis是什么？"></a>MyBatis是什么？</h3><p>MyBatis 是一款优秀的持久层框架，一个半 ORM（对象关系映射）框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。<span id="more"></span></p>
<h3 id="ORM是什么"><a href="#ORM是什么" class="headerlink" title="ORM是什么"></a>ORM是什么</h3><p>ORM（Object Relational Mapping），对象关系映射，是一种为了解决关系型数据库数据与简单Java对象（POJO）的映射关系的技术。简单的说，ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系型数据库中。</p>
<h3 id="为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"><a href="#为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？" class="headerlink" title="为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"></a>为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？</h3><p>Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。</p>
<p>而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。</p>
<h3 id="传统JDBC开发存在的问题"><a href="#传统JDBC开发存在的问题" class="headerlink" title="传统JDBC开发存在的问题"></a>传统JDBC开发存在的问题</h3><ul>
<li>频繁创建数据库连接对象、释放，容易造成系统资源浪费，影响系统性能。可以使用连接池解决这个问题。但是使用jdbc需要自己实现连接池。</li>
<li>sql语句定义、参数设置、结果集处理存在硬编码。实际项目中sql语句变化的可能性较大，一旦发生变化，需要修改java代码，系统需要重新编译，重新发布。不好维护。</li>
<li>使用preparedStatement向占有位符号传参数存在硬编码，因为sql语句的where条件不一定，可能多也可能少，修改sql还要修改代码，系统不易维护。</li>
<li>结果集处理存在重复代码，处理麻烦。如果可以映射成Java对象会比较方便。</li>
</ul>
<h3 id="JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？"><a href="#JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？" class="headerlink" title="JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？"></a>JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？</h3><p>1、数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库连接池可解决此问题。</p>
<p>解决：在mybatis-config.xml中配置数据链接池，使用连接池管理数据库连接。</p>
<p>2、Sql语句写在代码中造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。</p>
<p>解决：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。</p>
<p>3、向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。</p>
<p>解决： Mybatis自动将java对象映射至sql语句。</p>
<p>4、对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便。</p>
<p>解决：Mybatis自动将sql执行结果映射至java对象。</p>
<h3 id="Mybatis优缺点"><a href="#Mybatis优缺点" class="headerlink" title="Mybatis优缺点"></a>Mybatis优缺点</h3><p><strong>优点</strong></p>
<p>与传统的数据库访问技术相比，ORM有以下优点：</p>
<ul>
<li>基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML里，解除sql与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态SQL语句，并可重用</li>
<li>与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接</li>
<li>很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持）</li>
<li>提供映射标签，支持对象与数据库的ORM字段关系映射；提供对象关系映射标签，支持对象关系组件维护</li>
<li>能够与Spring很好的集成</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求</li>
<li>SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库</li>
</ul>
<h3 id="MyBatis框架适用场景"><a href="#MyBatis框架适用场景" class="headerlink" title="MyBatis框架适用场景"></a>MyBatis框架适用场景</h3><ul>
<li>MyBatis专注于SQL本身，是一个足够灵活的DAO层解决方案。</li>
<li>对性能的要求很高，或者需求变化较多的项目，如互联网项目，MyBatis将是不错的选择。</li>
</ul>
<h3 id="Hibernate-和-MyBatis-的区别"><a href="#Hibernate-和-MyBatis-的区别" class="headerlink" title="Hibernate 和 MyBatis 的区别"></a>Hibernate 和 MyBatis 的区别</h3><p><strong>相同点</strong></p>
<p>都是对jdbc的封装，都是持久层的框架，都用于dao层的开发。</p>
<p><strong>不同点</strong></p>
<p>映射关系</p>
<ul>
<li>MyBatis 是一个半自动映射的框架，配置Java对象与sql语句执行结果的对应关系，多表关联关系配置简单</li>
<li>Hibernate 是一个全表映射的框架，配置Java对象与数据库表的对应关系，多表关联关系配置复杂</li>
</ul>
<p>SQL优化和移植性</p>
<ul>
<li>Hibernate 对SQL语句封装，提供了日志、缓存、级联（级联比 MyBatis 强大）等特性，此外还提供 HQL（Hibernate Query Language）操作数据库，数据库无关性支持好，但会多消耗性能。如果项目需要支持多种数据库，代码开发量少，但SQL语句优化困难。</li>
<li>MyBatis 需要手动编写 SQL，支持动态 SQL、处理列表、动态生成表名、支持存储过程。开发工作量相对大些。直接使用SQL语句操作数据库，不支持数据库无关性，但sql语句优化容易。</li>
</ul>
<p>开发难易程度和学习成本</p>
<ul>
<li>Hibernate 是重量级框架，学习使用门槛高，适合于需求相对稳定，中小型的项目，比如：办公自动化系统</li>
<li>MyBatis 是轻量级框架，学习使用门槛低，适合于需求变化频繁，大型的项目，比如：互联网电子商务系统</li>
</ul>
<p><strong>总结</strong></p>
<p>MyBatis 是一个小巧、方便、高效、简单、直接、半自动化的持久层框架，</p>
<p>Hibernate 是一个强大、方便、高效、复杂、间接、全自动化的持久层框架。</p>
<h2 id="MyBatis的解析和运行原理"><a href="#MyBatis的解析和运行原理" class="headerlink" title="MyBatis的解析和运行原理"></a>MyBatis的解析和运行原理</h2><h3 id="MyBatis编程步骤是什么样的？"><a href="#MyBatis编程步骤是什么样的？" class="headerlink" title="MyBatis编程步骤是什么样的？"></a>MyBatis编程步骤是什么样的？</h3><p>1、 创建SqlSessionFactory</p>
<p>2、 通过SqlSessionFactory创建SqlSession</p>
<p>3、 通过sqlsession执行数据库操作</p>
<p>4、 调用session.commit()提交事务</p>
<p>5、 调用session.close()关闭会话</p>
<h3 id="请说说MyBatis的工作原理"><a href="#请说说MyBatis的工作原理" class="headerlink" title="请说说MyBatis的工作原理"></a>请说说MyBatis的工作原理</h3><p>在学习 MyBatis 程序之前，需要了解一下 MyBatis 工作原理，以便于理解程序。MyBatis 的工作原理如下图</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL015QmF0aXMlRTYlQTElODYlRTYlOUUlQjYlRTYlODAlQkIlRTclQkIlOTMvTXlCYXRpcyVFNSVCNyVBNSVFNCVCRCU5QyVFNSU4RSU5RiVFNyU5MCU4Ni5wbmc" alt="img"></p>
<p>1）读取 MyBatis 配置文件：mybatis-config.xml 为 MyBatis 的全局配置文件，配置了 MyBatis 的运行环境等信息，例如数据库连接信息。</p>
<p>2）加载映射文件。映射文件即 SQL 映射文件，该文件中配置了操作数据库的 SQL 语句，需要在 MyBatis 配置文件 mybatis-config.xml 中加载。mybatis-config.xml 文件可以加载多个映射文件，每个文件对应数据库中的一张表。</p>
<p>3）构造会话工厂：通过 MyBatis 的环境等配置信息构建会话工厂 SqlSessionFactory。</p>
<p>4）创建会话对象：由会话工厂创建 SqlSession 对象，该对象中包含了执行 SQL 语句的所有方法。</p>
<p>5）Executor 执行器：MyBatis 底层定义了一个 Executor 接口来操作数据库，它将根据 SqlSession 传递的参数动态地生成需要执行的 SQL 语句，同时负责查询缓存的维护。</p>
<p>6）MappedStatement 对象：在 Executor 接口的执行方法中有一个 MappedStatement 类型的参数，该参数是对映射信息的封装，用于存储要映射的 SQL 语句的 id、参数等信息。</p>
<p>7）输入参数映射：输入参数类型可以是 Map、List 等集合类型，也可以是基本数据类型和 POJO 类型。输入参数映射过程类似于 JDBC 对 preparedStatement 对象设置参数的过程。</p>
<p>8）输出结果映射：输出结果类型可以是 Map、 List 等集合类型，也可以是基本数据类型和 POJO 类型。输出结果映射过程类似于 JDBC 对结果集的解析过程。</p>
<h3 id="MyBatis的功能架构是怎样的"><a href="#MyBatis的功能架构是怎样的" class="headerlink" title="MyBatis的功能架构是怎样的"></a>MyBatis的功能架构是怎样的</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL015QmF0aXMlRTYlQTElODYlRTYlOUUlQjYlRTYlODAlQkIlRTclQkIlOTMvTXlCYXRpcyVFNSU4QSU5RiVFOCU4MyVCRCVFNiU5RSVCNiVFNiU5RSU4NC5wbmc" alt="Mybatis功能框架"></p>
<p>我们把Mybatis的功能架构分为三层：</p>
<ul>
<li>API接口层：提供给外部使用的接口API，开发人员通过这些本地API来操纵数据库。接口层一接收到调用请求就会调用数据处理层来完成具体的数据处理。</li>
<li>数据处理层：负责具体的SQL查找、SQL解析、SQL执行和执行结果映射处理等。它主要的目的是根据调用的请求完成一次数据库操作。</li>
<li>基础支撑层：负责最基础的功能支撑，包括连接管理、事务管理、配置加载和缓存处理，这些都是共用的东西，将他们抽取出来作为最基础的组件。为上层的数据处理层提供最基础的支撑。</li>
</ul>
<h3 id="MyBatis的框架架构设计是怎么样的"><a href="#MyBatis的框架架构设计是怎么样的" class="headerlink" title="MyBatis的框架架构设计是怎么样的"></a>MyBatis的框架架构设计是怎么样的</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL015QmF0aXMlRTYlQTElODYlRTYlOUUlQjYlRTYlODAlQkIlRTclQkIlOTMvTXlCYXRpcyVFNiVBMSU4NiVFNiU5RSVCNiVFNiU5RSVCNiVFNiU5RSU4NC5wbmc" alt="Mybatis框架架构"></p>
<p>这张图从上往下看。MyBatis的初始化，会从mybatis-config.xml配置文件，解析构造成Configuration这个类，就是图中的红框。</p>
<p>(1)加载配置：配置来源于两个地方，一处是配置文件，一处是Java代码的注解，将SQL的配置信息加载成为一个个MappedStatement对象（包括了传入参数映射配置、执行的SQL语句、结果映射配置），存储在内存中。</p>
<p>(2)SQL解析：当API接口层接收到调用请求时，会接收到传入SQL的ID和传入对象（可以是Map、JavaBean或者基本数据类型），Mybatis会根据SQL的ID找到对应的MappedStatement，然后根据传入参数对象对MappedStatement进行解析，解析后可以得到最终要执行的SQL语句和参数。</p>
<p>(3)SQL执行：将最终得到的SQL和参数拿到数据库进行执行，得到操作数据库的结果。</p>
<p>(4)结果映射：将操作数据库的结果按照映射的配置进行转换，可以转换成HashMap、JavaBean或者基本数据类型，并将最终结果返回。</p>
<h3 id="为什么需要预编译"><a href="#为什么需要预编译" class="headerlink" title="为什么需要预编译"></a>为什么需要预编译</h3><ol>
<li>定义：<br>SQL 预编译指的是数据库驱动在发送 SQL 语句和参数给 DBMS 之前对 SQL 语句进行编译，这样 DBMS 执行 SQL 时，就不需要重新编译。</li>
<li>为什么需要预编译<br>JDBC 中使用对象 PreparedStatement 来抽象预编译语句，使用预编译。预编译阶段可以优化 SQL 的执行。预编译之后的 SQL 多数情况下可以直接执行，DBMS 不需要再次编译，越复杂的SQL，编译的复杂度将越大，预编译阶段可以合并多次操作为一个操作。同时预编译语句对象可以重复利用。把一个 SQL 预编译后产生的 PreparedStatement 对象缓存下来，下次对于同一个SQL，可以直接使用这个缓存的 PreparedState 对象。Mybatis默认情况下，将对所有的 SQL 进行预编译。</li>
</ol>
<h3 id="Mybatis都有哪些Executor执行器？它们之间的区别是什么？"><a href="#Mybatis都有哪些Executor执行器？它们之间的区别是什么？" class="headerlink" title="Mybatis都有哪些Executor执行器？它们之间的区别是什么？"></a>Mybatis都有哪些Executor执行器？它们之间的区别是什么？</h3><p>Mybatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。</p>
<p><strong>SimpleExecutor</strong>：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。</p>
<p><strong>ReuseExecutor</strong>：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用Statement对象。</p>
<p><strong>BatchExecutor</strong>：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。</p>
<p>作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内。</p>
<h3 id="Mybatis中如何指定使用哪一种Executor执行器？"><a href="#Mybatis中如何指定使用哪一种Executor执行器？" class="headerlink" title="Mybatis中如何指定使用哪一种Executor执行器？"></a>Mybatis中如何指定使用哪一种Executor执行器？</h3><p>在Mybatis配置文件中，在设置（settings）可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数，如SqlSession openSession(ExecutorType execType)。</p>
<p>配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（prepared statements）； BATCH 执行器将重用语句并执行批量更新。</p>
<h3 id="Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"></a>Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？</h3><p>Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。</p>
<p>它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p>
<p>当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。</p>
<h3 id="什么是MyBatis的接口绑定？有哪些实现方式？"><a href="#什么是MyBatis的接口绑定？有哪些实现方式？" class="headerlink" title="什么是MyBatis的接口绑定？有哪些实现方式？"></a>什么是MyBatis的接口绑定？有哪些实现方式？</h3><p>接口绑定，就是在MyBatis中任意定义接口，然后把接口里面的方法和SQL语句绑定，我们直接调用接口方法就可以，这样比起原来了SqlSession提供的方法我们可以有更加灵活的选择和设置。</p>
<p>接口绑定有两种实现方式</p>
<p>通过注解绑定，就是在接口的方法上面加上 @Select、@Update等注解，里面包含Sql语句来绑定；</p>
<p>通过xml里面写SQL来绑定， 在这种情况下，要指定xml映射文件里面的namespace必须为接口的全路径名。当Sql语句比较简单时候，用注解绑定， 当SQL语句比较复杂时候，用xml绑定，一般用xml绑定的比较多。</p>
<h3 id="使用MyBatis的mapper接口调用时有哪些要求？"><a href="#使用MyBatis的mapper接口调用时有哪些要求？" class="headerlink" title="使用MyBatis的mapper接口调用时有哪些要求？"></a>使用MyBatis的mapper接口调用时有哪些要求？</h3><p>1、Mapper接口方法名和mapper.xml中定义的每个sql的id相同。</p>
<p>2、Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同。</p>
<p>3、Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同。</p>
<p>4、Mapper.xml文件中的namespace即是mapper接口的类路径。</p>
<h3 id="最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗"><a href="#最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗" class="headerlink" title="最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗"></a>最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗</h3><p>Dao接口，就是人们常说的Mapper接口，接口的全限名，就是映射文件中的namespace的值，接口的方法名，就是映射文件中MappedStatement的id值，接口方法内的参数，就是传递给sql的参数。Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement，举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到namespace为com.mybatis3.mappers.StudentDao下面id = findStudentById的MappedStatement。在Mybatis中，每一个<delete>,<insert>,<select>,<update>标签，都会被解析为一个MappedStatement对象。</p>
<p>Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。</p>
<p>Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。</p>
<h3 id="Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？"><a href="#Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？" class="headerlink" title="Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？"></a>Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？</h3><p>不同的Xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复；毕竟namespace不是必须的，只是最佳实践而已。</p>
<p>原因就是namespace+id是作为Map&lt;String, MappedStatement&gt;的key使用的，如果没有namespace，就剩下id，那么，id重复会导致数据互相覆盖。有了namespace，自然id就可以重复，namespace不同，namespace+id自然也就不同。</p>
<h3 id="简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？"><a href="#简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？" class="headerlink" title="简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？"></a>简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？</h3><p>答：Mybatis将所有Xml配置信息都封装到All-In-One重量级对象Configuration内部。在Xml映射文件中，<code>标签会被解析为ParameterMap对象，其每个子元素会被解析为ParameterMapping对象。</code>标签会被解析为ResultMap对象，其每个子元素会被解析为ResultMapping对象。每一个<delete>,<insert>,<select>,<update>标签均会被解析为MappedStatement对象，标签内的sql会被解析为BoundSql对象。</p>
<h3 id="Mybatis是如何进行分页的？分页插件的原理是什么？"><a href="#Mybatis是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="Mybatis是如何进行分页的？分页插件的原理是什么？"></a>Mybatis是如何进行分页的？分页插件的原理是什么？</h3><p>Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p>
<p>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。</p>
<p>举例：select * from student，拦截sql后重写为：select t.* from (select * from student) t limit 0, 10</p>
<h3 id="简述Mybatis的插件运行原理，以及如何编写一个插件。"><a href="#简述Mybatis的插件运行原理，以及如何编写一个插件。" class="headerlink" title="简述Mybatis的插件运行原理，以及如何编写一个插件。"></a>简述Mybatis的插件运行原理，以及如何编写一个插件。</h3><p>Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。</p>
<p>实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。</p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="Mybatis的一级、二级缓存"><a href="#Mybatis的一级、二级缓存" class="headerlink" title="Mybatis的一级、二级缓存"></a>Mybatis的一级、二级缓存</h3><p>1）一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。</p>
<p>2）二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置`` ；</p>
<p>3）对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</p>
]]></content>
      <categories>
        <category>面试篇</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql相关</title>
    <url>/2021/04/27/Mysql%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h4 id="Mysql有哪些数据引擎，分别有什么特点"><a href="#Mysql有哪些数据引擎，分别有什么特点" class="headerlink" title="Mysql有哪些数据引擎，分别有什么特点"></a>Mysql有哪些数据引擎，分别有什么特点</h4><p>Innodb/MyISAM/Memory/Archive</p>
<span id="more"></span>

<h4 id="Innodb用的是B-树的数据结构，那它是如何定位到某一条记录的"><a href="#Innodb用的是B-树的数据结构，那它是如何定位到某一条记录的" class="headerlink" title="Innodb用的是B+树的数据结构，那它是如何定位到某一条记录的"></a>Innodb用的是B+树的数据结构，那它是如何定位到某一条记录的</h4><p><img src="image-20200607161014044.png" alt="image-20200607161014044"></p>
<p>Innodb中默认每一页大小是16kb，而页里面如果数据太多会进行分组，例如每6行记录为一组，页目录里面记录的就是每组的第一个记录的主键（索引）。</p>
<p><img src="image-20200607162147239.png" alt="image-20200607162147239"></p>
<h4 id="mvcc机制"><a href="#mvcc机制" class="headerlink" title="mvcc机制"></a>mvcc机制</h4><h4 id="redo和undo文件的区别"><a href="#redo和undo文件的区别" class="headerlink" title="redo和undo文件的区别"></a>redo和undo文件的区别</h4><h4 id="Mysql里面的执行计划–explain"><a href="#Mysql里面的执行计划–explain" class="headerlink" title="Mysql里面的执行计划–explain"></a>Mysql里面的执行计划–explain</h4><h4 id="唯一索引和普通索引的区别"><a href="#唯一索引和普通索引的区别" class="headerlink" title="唯一索引和普通索引的区别"></a>唯一索引和普通索引的区别</h4><p>①对于查询来说：两种索引的性能是没差别，主要的差别是在更新索引上，mysql的读取是按页来的，每一页的大小是16k</p>
<p>细分以下两种情况：</p>
<p>1.需要更新的索引在内存中，修改的结果会保存到change buffer</p>
<p>1）唯一索引：找到对应的位置，判断有没有冲突，没有则将更新写入到change buffer，执行结束。</p>
<p>2）普通索引：找到对应的位置，不需要判断，将更新写入到change buffer，执行结束。</p>
<p>2.需要更新的索引不在内存中</p>
<p>1）唯一索引：先将磁盘数据读到内存中，找到对应的位置，判断冲突是否存在，不存在则写入change buffer，执行结束。</p>
<p>2）普通索引：找到对应的位置，不需要判断，将更新写入到change buffer，执行结束。</p>
<h3 id="什么情况下会产生using-temporary-和using-filesort"><a href="#什么情况下会产生using-temporary-和using-filesort" class="headerlink" title="什么情况下会产生using temporary 和using filesort"></a>什么情况下会产生using temporary 和using filesort</h3><p><strong>文件内排序</strong>:单表查询时，如果order by的字段，无法走索引，此时便会产生文件内排序，filesort函数会优先使用内存(sort_buffer_size大小)排序，如果不够，便会产生临时文件。</p>
<p><strong>临时表</strong>：①使用union查询</p>
<p>②当order by 和group by的字段不一致</p>
<p>③在多表连接下，order by 字段不是驱动表</p>
<p>④使用distinct查询并且加上了order by</p>
<p>⑤from里使用了子查询</p>
<p>临时表也分为两种：<strong>磁盘临时表</strong> 和 <strong>内存临时表</strong></p>
<p>磁盘临时表一般由用户显式创建:create temporary table</p>
<p>内存临时表一般由优化器隐式创建，例如上面描述的几种情况。如果内存临时表大小超过了设定</p>
<blockquote>
<p>min(tmp_table_size,max_heap_table_size)</p>
</blockquote>
<p>则会转化为磁盘临时表。</p>
<p>在5.6前，磁盘临时表使用的是MyISAM引擎，5.7以后可以选择Innodb或者MyISAM。</p>
<p>5.6和5.7中，内存临时表都只能使用Memory引擎，在8.0后可以选择Template引擎。</p>
]]></content>
      <categories>
        <category>面试篇</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx使用总结</title>
    <url>/2021/07/26/Nginx%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><strong>Nginx</strong>一共有以下五大应用场景</p>
<ul>
<li>HTTP服务器</li>
<li>静态服务器</li>
<li>反向代理</li>
<li>负载均衡</li>
<li>动静分离</li>
</ul>
<span id="more"></span>

<h4 id="HTTP服务器"><a href="#HTTP服务器" class="headerlink" title="HTTP服务器"></a>HTTP服务器</h4><p>Nginx本身也是一个静态资源的服务器，当只有静态资源的时候，就可以使用Nginx来做服务器，如果一个网站只是静态页面的话，那么就可以通过这种方式来实现部署。</p>
<h5 id="1、-文件准备"><a href="#1、-文件准备" class="headerlink" title="1、 文件准备"></a>1、 文件准备</h5><p>首先在文档根目录Docroot(/usr/local/var/www)下创建html目录, 然后在html中放一个test.html;</p>
<h5 id="2、配置nginx-conf中的server"><a href="#2、配置nginx-conf中的server" class="headerlink" title="2、配置nginx.conf中的server"></a>2、配置nginx.conf中的server</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">user mengday staff;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line">        client_max_body_size 1024M;</span><br><span class="line"></span><br><span class="line">        # 默认location</span><br><span class="line">        location / &#123;</span><br><span class="line">            root   /usr/local/var/www/html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3、访问测试"><a href="#3、访问测试" class="headerlink" title="3、访问测试"></a>3、访问测试</h5><ul>
<li><a href="http://localhost/">http://localhost/</a> 指向/usr/local/var/www/index.html, index.html是安装nginx自带的html</li>
<li><a href="http://localhost/test.html">http://localhost/test.html</a> 指向/usr/local/var/www/html/test.html</li>
</ul>
<blockquote>
<p>注意：如果访问图片出现403 Forbidden错误，可能是因为nginx.conf 的第一行user配置不对，默认是#user nobody;是注释的，linux下改成user root; macos下改成user 用户名 所在组; 然后重新加载配置文件或者重启，再试一下就可以了， 用户名可以通过who am i 命令来查看</p>
</blockquote>
<h5 id="4、指令模块说明"><a href="#4、指令模块说明" class="headerlink" title="4、指令模块说明"></a>4、指令模块说明</h5><ul>
<li>server : 用于定义服务，http中可以有多个server块</li>
<li>listen : 指定服务器侦听请求的IP地址和端口，如果省略地址，服务器将侦听所有地址，如果省略端口，则使用标准端口</li>
<li>server_name : 服务名称，用于配置域名</li>
<li>location : 用于配置映射路径uri对应的配置，一个server中可以有多个location, location后面跟一个uri,可以是一个正则表达式, / 表示匹配任意路径, 当客户端访问的路径满足这个uri时就会执行location块里面的代码</li>
<li>root : 根路径，当访问<a href="http://localhost/test.html%EF%BC%8C%E2%80%9C/test.html%E2%80%9D%E4%BC%9A%E5%8C%B9%E9%85%8D%E5%88%B0%E2%80%9D/%E2%80%9Duri">http://localhost/test.html，“/test.html”会匹配到”/”uri</a>, 找到root为/usr/local/var/www/html，用户访问的资源物理地址=root + uri = /usr/local/var/www/html + /test.html=/usr/local/var/www/html/test.html</li>
<li>index : 设置首页，当只访问server_name时后面不跟任何路径是不走root直接走index指令的；如果访问路径中没有指定具体的文件，则返回index设置的资源，如果访问<a href="http://localhost/html/">http://localhost/html/</a> 则默认返回index.html</li>
</ul>
<h5 id="5、location-uri-正则表达式"><a href="#5、location-uri-正则表达式" class="headerlink" title="5、location uri 正则表达式"></a>5、location uri 正则表达式</h5><ul>
<li>. ：匹配除换行符以外的任意字符</li>
<li>? ：重复0次或1次</li>
<li>+ ：重复1次或更多次</li>
<li>* ：重复0次或更多次</li>
<li>\d ：匹配数字</li>
<li>^ ：匹配字符串的开始</li>
<li>$ ：匹配字符串的结束</li>
<li>{n} ：重复n次</li>
<li>{n,} ：重复n次或更多次</li>
<li>[c] ：匹配单个字符c</li>
<li>[a-z] ：匹配a-z小写字母的任意一个</li>
<li>(a|b|c) : 属线表示匹配任意一种情况，每种情况使用竖线分隔，一般使用小括号括括住，匹配符合a字符 或是b字符 或是c字符的字符串</li>
<li>\ 反斜杠：用于转义特殊字符</li>
</ul>
<blockquote>
<p>小括号()之间匹配的内容，可以在后面通过$1来引用，$2表示的是前面第二个()里的内容。正则里面容易让人困惑的是\转义特殊字符。</p>
</blockquote>
<h4 id="静态服务器"><a href="#静态服务器" class="headerlink" title="静态服务器"></a>静态服务器</h4><p>在公司中经常会遇到静态服务器，通常会提供一个上传的功能，其他应用如果需要静态资源就从该静态服务器中获取。</p>
<p>1、在/usr/local/var/www 下分别创建images和img目录，分别在每个目录下放一张test.jpg</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        set $doc_root /usr/local/var/www;</span><br><span class="line"></span><br><span class="line">        # 默认location</span><br><span class="line">        location / &#123;</span><br><span class="line">            root   /usr/local/var/www/html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location ^~ /images/ &#123;</span><br><span class="line">            root $doc_root;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       location ~* \.(gif|jpg|jpeg|png|bmp|ico|swf|css|js)$ &#123;</span><br><span class="line">           root $doc_root/img;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义变量使用set指令，语法 set 变量名值;引用使用变量名值;引用使用变量名; 这里自定义了doc_root变量。</p>
<p>静态服务器location的映射一般有两种方式：</p>
<ul>
<li>使用路径，如 /images/ 一般图片都会放在某个图片目录下，</li>
<li>使用后缀，如 .jpg、.png 等后缀匹配模式</li>
</ul>
<p>访问<a href="http://localhost/test.jpg">http://localhost/test.jpg</a> 会映射到 $doc_root/img</p>
<p>访问<a href="http://localhost/images/test.jpg">http://localhost/images/test.jpg</a> 当同一个路径满足多个location时，优先匹配优先级高的location，由于^~ 的优先级大于 ~, 所以会走/images/对应的location</p>
<p>常见的location路径映射路径有以下几种：</p>
<ul>
<li>=    进行普通字符精确匹配。也就是完全匹配。</li>
<li>^~     前缀匹配。如果匹配成功，则不再匹配其他location。</li>
<li>~    表示执行一个正则匹配，区分大小写</li>
<li>~*     表示执行一个正则匹配，不区分大小写</li>
<li>/xxx/  常规字符串路径匹配</li>
<li>/    通用匹配，任何请求都会匹配到</li>
</ul>
<h5 id="location优先级"><a href="#location优先级" class="headerlink" title="location优先级"></a>location优先级</h5><p>当一个路径匹配多个location时究竟哪个location能匹配到时有优先级顺序的，而优先级的顺序于location值的表达式类型有关，和在配置文件中的先后顺序无关。相同类型的表达式，字符串长的会优先匹配。</p>
<p>以下是按优先级排列说明：</p>
<ul>
<li>等号类型（=）的优先级最高。一旦匹配成功，则不再查找其他匹配项，停止搜索。</li>
<li>^~类型表达式，不属于正则表达式。一旦匹配成功，则不再查找其他匹配项，停止搜索。</li>
<li>正则表达式类型（~ ~*）的优先级次之。如果有多个location的正则能匹配的话，则使用正则表达式最长的那个。</li>
<li>常规字符串匹配类型。按前缀匹配。</li>
<li>/ 通用匹配，如果没有匹配到，就匹配通用的</li>
</ul>
<p>优先级搜索问题：不同类型的location映射决定是否继续向下搜索</p>
<ul>
<li>等号类型、^~类型：一旦匹配上就停止搜索了，不会再匹配其他location了</li>
<li>正则表达式类型(~ ~*）,常规字符串匹配类型/xxx/ : 匹配到之后，还会继续搜索其他其它location，直到找到优先级最高的，或者找到第一种情况而停止搜索</li>
</ul>
<p>location优先级从高到底：</p>
<p>(location =) &gt; (location 完整路径) &gt; (location ^~ 路径) &gt; (location <del>,</del>* 正则顺序) &gt; (location 部分起始路径) &gt; (/)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">location = / &#123;</span><br><span class="line">    # 精确匹配/，主机名后面不能带任何字符串 /</span><br><span class="line">    [ configuration A ]</span><br><span class="line">&#125;</span><br><span class="line">location / &#123;</span><br><span class="line">    # 匹配所有以 / 开头的请求。</span><br><span class="line">    # 但是如果有更长的同类型的表达式，则选择更长的表达式。</span><br><span class="line">    # 如果有正则表达式可以匹配，则优先匹配正则表达式。</span><br><span class="line">    [ configuration B ]</span><br><span class="line">&#125;</span><br><span class="line">location /documents/ &#123;</span><br><span class="line">    # 匹配所有以 /documents/ 开头的请求，匹配符合以后，还要继续往下搜索。</span><br><span class="line">    # 但是如果有更长的同类型的表达式，则选择更长的表达式。</span><br><span class="line">    # 如果有正则表达式可以匹配，则优先匹配正则表达式。</span><br><span class="line">    [ configuration C ]</span><br><span class="line">&#125;</span><br><span class="line">location ^~ /images/ &#123;</span><br><span class="line">    # 匹配所有以 /images/ 开头的表达式，如果匹配成功，则停止匹配查找，停止搜索。</span><br><span class="line">    # 所以，即便有符合的正则表达式location，也不会被使用</span><br><span class="line">    [ configuration D ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~* \.(gif|jpg|jpeg)$ &#123;</span><br><span class="line">    # 匹配所有以 gif jpg jpeg结尾的请求。</span><br><span class="line">    # 但是 以 /images/开头的请求，将使用 Configuration D，D具有更高的优先级</span><br><span class="line">    [ configuration E ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /images/ &#123;</span><br><span class="line">    # 字符匹配到 /images/，还会继续往下搜索</span><br><span class="line">    [ configuration F ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">location = /test.htm &#123;</span><br><span class="line">    root   /usr/local/var/www/htm;</span><br><span class="line">    index  index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：location的优先级与location配置的位置无关</p>
</blockquote>
<h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><p>反向代理应该是Nginx使用最多的功能了，反向代理(Reverse Proxy)方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p>
<p>简单来说就是真实的服务器不能直接被外部网络访问，所以需要一台代理服务器，而代理服务器能被外部网络访问的同时又跟真实服务器在同一个网络环境，当然也可能是同一台服务器，端口不同而已。</p>
<p>反向代理通过proxy_pass指令来实现。</p>
<p>启动一个Java Web项目，端口号为8081</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://localhost:8081;</span><br><span class="line">        proxy_set_header Host $host:$server_port;</span><br><span class="line">        # 设置用户ip地址</span><br><span class="line">         proxy_set_header X-Forwarded-For $remote_addr;</span><br><span class="line">         # 当请求服务器出错去寻找其他服务器</span><br><span class="line">         proxy_next_upstream error timeout invalid_header http_500 http_502 http_503; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>负载均衡也是Nginx常用的一个功能，负载均衡其意思就是分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。</p>
<p>简单而言就是当有2台或以上服务器时，根据规则随机的将请求分发到指定的服务器上处理，负载均衡配置一般都需要同时配置反向代理，通过反向代理跳转到负载均衡。而Nginx目前支持自带3种负载均衡策略，还有2种常用的第三方策略。</p>
<p>负载均衡通过upstream指令来实现。</p>
<h5 id="1-RR-round-robin-轮询-默认"><a href="#1-RR-round-robin-轮询-默认" class="headerlink" title="1. RR(round robin :轮询 默认)"></a>1. RR(round robin :轮询 默认)</h5><p>每个请求按时间顺序逐一分配到不同的后端服务器，也就是说第一次请求分配到第一台服务器上，第二次请求分配到第二台服务器上，如果只有两台服务器，第三次请求继续分配到第一台上，这样循环轮询下去，也就是服务器接收请求的比例是 1:1， 如果后端服务器down掉，能自动剔除。轮询是默认配置，不需要太多的配置</p>
<p>同一个项目分别使用8081和8082端口启动项目</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">upstream web_servers &#123;  </span><br><span class="line">   server localhost:8081;  </span><br><span class="line">   server localhost:8082;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line">    #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://web_servers;</span><br><span class="line">        # 必须指定Header Host</span><br><span class="line">        proxy_set_header Host $host:$server_port;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>访问地址仍然可以获得响应 <a href="http://localhost/api/user/login?username=zhangsan&amp;password=111111">http://localhost/api/user/login?username=zhangsan&amp;password=111111</a> ，这种方式是轮询的</p>
<h5 id="2-权重"><a href="#2-权重" class="headerlink" title="2. 权重"></a>2. 权重</h5><p>指定轮询几率，weight和访问比率成正比, 也就是服务器接收请求的比例就是各自配置的weight的比例，用于后端服务器性能不均的情况,比如服务器性能差点就少接收点请求，服务器性能好点就多处理点请求。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">upstream test &#123;</span><br><span class="line">    server localhost:8081 weight=1;</span><br><span class="line">    server localhost:8082 weight=3;</span><br><span class="line">    server localhost:8083 weight=4 backup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例是4次请求只有一次被分配到8081上，其他3次分配到8082上。backup是指热备，只有当8081和8082都宕机的情况下才走8083</p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h5 id="3-ip-hash"><a href="#3-ip-hash" class="headerlink" title="3. ip_hash"></a>3. ip_hash</h5><p>上面的2种方式都有一个问题，那就是下一个请求来的时候请求可能分发到另外一个服务器，当我们的程序不是无状态的时候(采用了session保存数据)，这时候就有一个很大的很问题了，比如把登录信息保存到了session中，那么跳转到另外一台服务器的时候就需要重新登录了，所以很多时候我们需要一个客户只访问一个服务器，那么就需要用iphash了，iphash的每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">upstream test &#123;</span><br><span class="line">    ip_hash;</span><br><span class="line">    server localhost:8080;</span><br><span class="line">    server localhost:8081;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-fair-第三方"><a href="#4-fair-第三方" class="headerlink" title="4. fair(第三方)"></a>4. fair(第三方)</h5><p>按后端服务器的响应时间来分配请求，响应时间短的优先分配。这个配置是为了更快的给用户响应</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">upstream backend &#123;</span><br><span class="line">    fair;</span><br><span class="line">    server localhost:8080;</span><br><span class="line">    server localhost:8081;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-url-hash-第三方"><a href="#5-url-hash-第三方" class="headerlink" title="5. url_hash(第三方)"></a>5. url_hash(第三方)</h5><p>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    hash $request_uri;</span><br><span class="line">    hash_method crc32;</span><br><span class="line">    server localhost:8080;</span><br><span class="line">    server localhost:8081;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<p>以上5种负载均衡各自适用不同情况下使用，所以可以根据实际情况选择使用哪种策略模式,不过fair和url_hash需要安装第三方模块才能使用。</p>
<h4 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h4><p>动静分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">upstream web_servers &#123;  </span><br><span class="line">       server localhost:8081;  </span><br><span class="line">       server localhost:8082;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    set $doc_root /usr/local/var/www;</span><br><span class="line"></span><br><span class="line">    location ~* \.(gif|jpg|jpeg|png|bmp|ico|swf|css|js)$ &#123;</span><br><span class="line">       root $doc_root/img;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://web_servers;</span><br><span class="line">        # 必须指定Header Host</span><br><span class="line">        proxy_set_header Host $host:$server_port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page 500 502 503 504  /50x.html;  </span><br><span class="line">    location = /50x.html &#123;  </span><br><span class="line">        root $doc_root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><h5 id="nginx的内置变量"><a href="#nginx的内置变量" class="headerlink" title="nginx的内置变量"></a>nginx的内置变量</h5><p>nginx的配置文件中可以使用的内置变量以美元符$开始，也有人叫全局变量。其中，部分预定义的变量的值是可以改变的。</p>
<ul>
<li>$args ：#这个变量等于请求行中的参数，同$query_string</li>
<li>$content_length ：请求头中的Content-length字段。</li>
<li>$content_type ：请求头中的Content-Type字段。</li>
<li>$document_root ：当前请求在root指令中指定的值。</li>
<li>$host ：请求主机头字段，否则为服务器名称。</li>
<li>$http_user_agent ：客户端agent信息</li>
<li>$http_cookie ：客户端cookie信息</li>
<li>$limit_rate ：这个变量可以限制连接速率。</li>
<li>$request_method ：客户端请求的动作，通常为GET或POST。</li>
<li>$remote_addr ：客户端的IP地址。</li>
<li>$remote_port ：客户端的端口。</li>
<li>$remote_user ：已经经过Auth Basic Module验证的用户名。</li>
<li>$request_filename ：当前请求的文件路径，由root或alias指令与URI请求生成。</li>
<li>$scheme ：HTTP方法（如http，https）。</li>
<li>$server_protocol ：请求使用的协议，通常是HTTP/1.0或HTTP/1.1。</li>
<li>$server_addr ：服务器地址，在完成一次系统调用后可以确定这个值。</li>
<li>$server_name ：服务器名称。</li>
<li>$server_port ：请求到达服务器的端口号。</li>
<li>$request_uri ：包含请求参数的原始URI，不包含主机名，如：”/foo/bar.php?arg=baz”。</li>
<li>$uri ：不带请求参数的当前URI，$uri不包含主机名，如”/foo/bar.html”。</li>
<li>$document_uri ：与$uri相同</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>反向代理</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql</title>
    <url>/2018/11/12/Mysql/</url>
    <content><![CDATA[<h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><h3 id="2）-常用指令"><a href="#2）-常用指令" class="headerlink" title="2）.常用指令"></a>2）.常用指令</h3><p>1.将数据库打包成.sql文件</p>
<pre><code>mysqldump -u root -p database-name &gt; filename.sql
</code></pre>
<span id="more"></span>

<p>2.执行.sql文件</p>
<p>方法一：在mysql的bin文件目录下</p>
<blockquote>
<p>mysql -u root -p -Ddatabase-name &lt; .sql</p>
</blockquote>
<pre><code>方法二：source .sql
</code></pre>
<p>3.授权给某个用户</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAj4AAAAkCAYAAACJ4DB4AAAABHNCSVQICAgIfAhkiAAAHyNJREFUeF7tnQdYVFfax/93ht6LgIAKKiBYIqgIihUbKCpYkyiJGjW27PftbrLZ7/t2k03ddHezJtHVNVETNVZssaFiwS6oSO/Sexk6zMz3zjAq4JQLDIp67vPwPMO9577nPb/znnPf0zkpXWhxDR46GtY2tvI7vr6+LR89/H316tWHvxNiozBwiLfScOwmI8AIMAKMACPACDAC3YmAoDspw3RhBBgBRoARYAQYAUagKwkwx6cr6TLZjAAjwAgwAowAI9CtCDDHp1tlB1OGEWAEGAFGgBFgBLqSAHN8upIuk80IMAKMACPACDAC3YoAc3y6VXYwZRgBRoARYAQYAUagKwkwx6cr6TLZjAAjwAgwAowAI9CtCDDHp1tlB1OGEWAEGAFGgBFgBLqSAHN8upIuk80IMAKMACPACDAC3YoAc3y6VXYwZRgBRoARYAQYAUagKwkwx6cr6TLZjAAjwAgwAowAI9CtCDDHp1tlB1OGEWAEGAFGgBFgBLqSAHN8upIuk80IMAKMACPACDAC3YoAc3y6VXYwZRgBRuCFJSCwheeMEEzyMAb3wkJQk/CO8OH00cc3CHPHOkGoRjR79GIR0Hkek8uZjsLqj1+GhyJ1jdE/4d0t0Wh8HhOrKk16VnB26wlxRjyyqqSqQnXqPh/OfMJ0Sokuflm352D4unJIvRaD3IaOR6YVOU8gT9uTQn232fj9cm/Uh2/Et6eyIVb6sgBm7lMwd6YP3OzNoCeuRmleCiJ2/4LIXInSNzp+k4PVxLfwXrAY+977HpcqOmr32pHDj0+L1AocMGzKWJgdOo+z8dUdx6DqTR72w09nzXnKT44qRVXc7xAfI/Qd5Q8/UQ4OX8xUYaMq4uvwbe3YT4ejf6ovPhtpfy4dH2n1Hez+LAP6nCmGL1oF/6dqCE8ncoHDGISuGIK76xO6zPHhw5lPmKdDiF+snIM3gufqYs+te+T4dPRDCmhDzpPIU35UZKE46FvZwdrIBE125tSaVu74cMaemL8sAM7pJ7B3UxLKJPowszREZWX7WOr1HIbpc6bC29UGBvXFSL5yFHuPxaCkqbXGTY1NkNLnramNFybo4Y1Fr4+BJQWvvvErtl3IRROlwXRYKN6eXokdX4Uhpe6RLFVytM2Hv7zOh9RsP9rKU35yOp+i7itBrf0I7DHtT+8gqHfLPqhG3P3p/7D5Rj0lioNRHx8ETB+Lof3tYK7TgLKcBFw+EobwxEqyb8Wl2wNDA4MR4OMGexMONUVpiA4/hMPXclGvpHjp0jdh2bq58Kj4DZ99eRr58naH9uNSm/ZukmXPpeMDSQ21KmsoT2tQIbMjdnUNAT6c+YTpGu06LpUzwtC5i+BRdgXn7xehqFQXlRaD4D/LB+ZxuxB2t+ZR5aMuFm3JURfHU3smReW17fg81xri/Byo6gzjrB3QU78MUSfDEZWmvE9IUxI4y+EIfetlOKQew05y5Mv1nDB2wSKslP6Arw5ntujJlaKutg5SsRi1rWp+IfpOCIB9/H/w9TU3rHvbH+5Xf0as/ksICXbEnR2/tnJ6QLmrXI4mTVs+58enPRK7Piw/nTXnKT85XZ+epxWDBvuh4TdDAwkyT2zEzlsiRV1C75QpSpGgB7yDp8Gl4iqO78hEOWcDz4AZCFqui/IPt+KGSObV6MFl9iosHVGG8D0b8XMhh54jpmPeqyshrPg7dse3/vAJbX2xZG0AHKVtWgpaj0tD2p9WlrSJVyuOj6D3BKx4zR8uNgZoLE5DTFID+ngNgHVjNi7/ug2HYisB4xFY/uGrsD2/Hn8/nIXmTm5dDAr9G1Y4XcbXnx5DFt3kDBzhGxwM/6FOsDHRgbiuGhUFt7BvQxjiHrTIBGZw9Z+J6X6D0MfaAFxDFUrzsxF97Bf8Rl3ESpzdx3FzVhg8zg0NsdFILq7n987jUprvCMzhPmU2Zvh5wNFCH6ivQklBFumzE8cV+nBGzhgdOA5ern1gZ2kGEyMdSOtFSDn6HTZGFMp5cKaeePmtEHjamMJAKEZ1cQZunw7Doas5zR48ZwyPoEUIHOoAG0sTGOpIIMpPwrWjB3A8prS5G1fognl/W4vxVs3Ttya/sx6T5VpKUXV5I/7ySwLv7l6N+qji0VX3BRZyzkFjPOBgCoiy4xB59DDCE8qb7YkPHz66cSYgy4OtdwjWTjKEvgGHxeuGoKo4F8mpJtRG4uv4aEkO3zzVxIdP2mV2qMFWpXyGktvo3POP3yh6XsVIP/Ap1p8phpSGLgLffRtj0jfhvd2JzXap44llX71Gwz0f45/nSslqdeEyJQiDqs9h/fYIZMnr7XyEnRyEj+b6ov9vmUhoUZeLq0SoEjVB1GoUTQBzC2NU5YogqaxAle4gWBiZYsis2egdswtfpzzeOlIuhx9A3sO7enYYMWsOArz7o4d+A0oyS6BDnQBlLaMhm+47LojqOg842ZpAWpGFexFHcDAiDfIRbD42z8N+JFrKU/CRI0ufpnTJwvDhwy9LIOwzEav/MhdO9I1qKEnDrRMHcPh6vtxh53h+m3hGJQ+m1n44QxgZSlGWm4FcZePnkiJc+O5jXCQHvtmME5BcbQOP33mir4MANxKpASHoiYEDrVB2/Rccj0qXl52cvKP03V0H9349IIjPUbxL6TPsj5lvzIDRhS3YY74Ub/RtkRItx6Ux7bIAVL8OXrAWoSMEiNqxAb/eFbVQ6Mn81I7jY94L/WxLcI6ck2zPV7DMrw7hmzYhf/grWDTfH3cSwpBek4h7qWIsHOCGHoIsFMpylCo+l36GECUmI0+ew0I4T1+GhUOLcWrfZsQW1UNgaAYbazEKHzYp9dF/9hqsnqCHxFMHsTW5DE0GHpi+bCJce5LTwXdsXN8azsMD4T9vNkribuDSxUhcjytAbasKk08m6MMleA1WjgXuHtuDY5mUiaZDELRkLNxIH5njI7s4UxeMGjcEuBKGA0eKUFknho4hfb2LSh8aqLQmmwrkr7hRJkI9jNHbJwghryxBQ/5nCEuXmbYebF3c0af+IrZvjUU1zNBv3EwELFuMqk83IKKIlBdn4uQ//47IPv5Y9foAJGz7N87myBIlhaRW4SDwSZbsDY368BSklWAGcA1ZjZV+EkQd2YWjeRwcfAIwY/UamGz4BgeSZV4xDz58dJEU4ta+rYgyccWMlS/Dy0SCqtt7sflIUvPHho8MWRhtyeGVp3z48FNco61W38bOT9KgLzDB8MVrFY51G9lqdG4QlfFvaOj0w3BPM2SfuY5ssSGcxgUjeOIgamAYUfyp1DjikFD+qKkjyY3CiRNSFLQqxxKUlYpg08cRJnm9YddQhpj+MxHiHIfdX6agTklLSbkcfvykfPjQh/+lhauxeKgI145sx75iIWwHjMaUfi3j0IPzjDVYO7aJwuzBb1l1MHUdj+DZK7C4/gtsuizjyMPm1eTFgzqBl85q5DzMUz5pJ501posXH375IQ8lrEfWxf0ILxSjh9dUBIWuhkHdF/jlLjWUeX2b2hEXBVVrP7omMNWvRx014M0MyyCqFT9WHmS9lo/MkoOBuTkMJMUoKlEYtrQCxTTOa+E+BH0MMpBORizs0RdOptW4Tw70Q/PnzOC5cDE88/Zj/aks2M5/PB1ai0shWm3aZWEENnAd2BNGRoAHDV3jWXV85OmVilCQmYlYvfuo8zNCfjqNNyIVc0bYwkYPSK+tQtydNIgXDMYgy7MoLJFCYN0fLlb1SE3IpPF2ORGYmhnTIHwcUhNTkVnVnH3p8mfNF2fuhanjbFFw6mtsOZajaCUaYRQFtWgRTuPPumQc/eYDnHMYhJFjRmHMa+9iZm0qbkVG4uLlGGRX8euW58y8MHmMDQpOf4Ud4bkKfUwwWkKTFB9TohF5d68iOk6FbHExkqKKH76VlaML1xFL0a+fJbh0aiErnkjKMhATmyTv4k/KoQ/eByEYNMAY54tk3aaNEBUXotqkhpg2oaa0AAWtvwKPaaXyBk99VL6vxQeyfJ9CnHOPf46d5wrkBTshKR86dn/CtKleCE+5AupXlF/q+fBUioZTAlYvh7/gLL75TxMWvr0cqyXf49ujGeSUtuPSihzNecqLj5IPvOqUqLFVSS3KC2vJm6+DSNUYl5bsUGDdG72MRci4Xw5jr0V4c44jYndtwX7hRKxbaCbvIWl5SUWpuHylbarEyDh3FHHL5uNPS2uQePoWBszyQ/yub5BUqxyKcjlt5ar4nwcfznIYJgw3Qcahf2H3+RJ52U5IlMJlXP+H9QZn6oWAiVZI2P0J9t2oai7/mXnQcXofoSMHw+LKxYe9Q+ptXrP9UKtIO3nKQw6fdJXz4KOCvtLb4vTLOHpescAlIRc69v+DoAleOBpzCeVSPt8mpWJV3lRnPwJjPUhKG+G64M/46HUBavMTcfW3AzgWVaR0AY7QZiReDhmIsogfcLlYYa/k+Fzbtxcuby7Auv/ri7v3imH5kjukp3/EwdgHQyMcLEbMw1znBOz88g4qpALYqtS4+UHH43okWF3a5aHEGQjfsR8N7kDi+ZZfdw3KafGxVnp8WukjlVIB5cDJ1mM++C2Q/4PKOzeROGchhr5khQjqxjZ2dYVDUzLOJz+oPRsRd/wAbq2chzUfDELa3SjcunEdN+MLH7bKBA7O6C0sw424fN5DNqp5SVCdG4Nze2IQEWaJfiOnYV7wEvxpfCQ2vL8XSW2GQ5XJETg4obdOOW4mFHRaH4Fpf4ybOQ2+7g6wNOJQL6qHri51fevqyJe3KquipVUlKKmj3g9jIwrzYLxYmabtv9cRfdofC783ZJx7Ub5fTy5+1Jqhbtqk5FJM9+4NeyE5Pkr8yQ7zaSxG/PVLqMuKQHaOFPsPGaNPZpHKuSwqU6EtOSojaH7Aiw8Pe9YQzRN/zFlYUoOmEhWV+nCfOBgGyftpiCIDNQNqqLw93rRQpaC07A72fk1/NO9q4Ct/xLzk87jgvQbvhxqh/HYYftoXQx9AVW9r/77AzhH2gnJcS1fd+yVwpLpO3xAmiz/AN4sf6cAJhOCKLWFOlUKZEp07bPPaT6ZSiXzSVcmDj1LhfG5KS5GWWgqBD80/I8e5vInPt4mPYH5hJMWR2PxhJAXmoGfRB55T52He66ugW/0F9ia2blbpOY7B66tmwT55N747ktai0UUTyM1sYKVfjrhLN5EhdIKFxAC9hvvAncpHFPUMccaDMXO2M5L3f0EDIUoMpY26nYmLX8ofhJJClHIJx1La95Y2Q3eN4yMh50cJZ2n1PVyLCcYSby+a6xMJR4++kKQcRGLNo8BNBdex49M4nB3kheHDhmHqCn9MzzyNrZtPIOVh5smcK21dAhj2dIe332iMHjkQNnXpuHHhLgqUfESVxigQUD+VGGJKc6cuzhp+S1ciuEcyfgv7CfH5NTQU6o7py4M0VO80hEVRc3JPs+X1tPTpFIUueFkVHw1RSauRcf4IMhTBMiIOP/yt4c3Wj7UlRy61k3naLsWfRGCJ3HYFQtXbiXG6+jQw0oRGGuYyNRWgLq8cLaqLdirJwdCd9nRxS8ahIw6YF5iMrZ8nw+ftuZh4Kw4HOzj5up1KPAze3EBsW25bSKMyzUlKcOWnzTiX2zrvpeIaWiFHYZW+rsrmu4n98EmX3NplDWilCewocsV7JFMml3A8IMLn29TJSJW8LkVDeSau7z8Ix0HrMGKYMw4kKua6UdoNnCdh5eqpMI7egW+pcV7ecvhW1wUzaF6t8PyX+PGUrAc8EhfOXEPIH9di/owYxG6/B8FAH3hZmEKw5AN4LmmOXuY0C7jp+POX/bHnw024LN/yofNxtasXXAmJJ31L646POH43/vcPzcl4bMMoaS3iLt5E2e98MMqtBGZuNFSzP/bxeRPiKuTcvSj/O243AavenYVZo25gfTi19mkSc57EG/36W0GQXvSo9a+UnGxZKxUffX1a2g40tiz3QjM4DRuFsX6+8OpvjMqkm7i062tyzHLAc5RLHqOkMB9F0uHo62wBLkM2GbODl9AeffvoIjf8KMKj8pvTpWOCUmqN8G/Xtoi7sZG6TQ1o9UAHK4526aOG80OV+IRRzU6Sm0lzPEbCxZUm7qU3D3XJxordXK0gzslCHl9HVXUUHXxCS6JdRmOsO4ckcuZT5CsuuuhSk6dPh08jGqhQcYZGMGxbvvggIKdQRMPZhjY2MOPilfdeNDWQHVP51a1HOXk8eoYGNPEciqFxPpE8CsMZuiFo/gCk7vsGaWavQZ+GGHJEWcgsMKHhd1ltpW0jUs1Hll9ZZM9uHj0hTFcM2bdJzoMwzr30UBp9X+kwSLsIqLGfR3JU69yuuEhbVbbBJ10cDz7t06dFaKENBrhRvZF9/1G9wffb1OFI1bwo88PaPObMaaHLimkwpT3o/vVrLNru/sAZ26GnWROKC8oezRGtzUJqbiPGWlrIy2NFzD589tGRFrIFcApcg1cdo7D5P+eQpqirtBGXsuXzalIMXWsXvNRPiPt3ElGkcrhcnYTOPdO646NJncb0S7h0fzSmLZpNTncidse2XIVFKzgmh8CjIQlJ2aWoadKBeb8+sBA2orCq2aeUlkfj3M3JWBG4FK+ITyG6iEMP11HoT0NCJW0jJ2POz6uAgHpzpo2sRHytEaxpv5HIu+RYCHth1DRPGCecxX923UR8QW2HnBZpSRQu3JuE0BlLsUByCndKhLDu7wtnqkdL2+qj7n9JAbJyxfD0noKxOZFIK2+AgFa4Weq0LRLqhDx6JinJQV6dCYZODUSKIAkimkjXUzcXF6NzNTiLChnt0Ucd5wcq8QmjJmnSiiicvkQrMwKWYFHTSdzK52A/MgDTHIsRuSG6uWLoGCo1sfJ4JHTG5NB58O8BeOvn4uP9NI+Nx2sdCaI2T/nw6Uik6t6R1iE3uxic/2hMH1WBu1WGtHAhG5du5/GzMZpbkXA3DY3zJ2FhYDUNeVdAYkTlnfLxQeNWWlJM5ciTFjg00PB2OjDdByNtY3FF1mugTre2zziaCxc0FwPTDuJrqnPqB1agwZRWV1IDyIImhJZXdEGuqeMjy6+LE7B26htYzp1EZEopGg36wJIS9UATmc2fjBiLtVNWYI3hGVyKy6NGmS5MbS1RQ3NT4krb52SrtZ8HvNTp3Japuv/VyeGRLnl518BHXfRtnwksnTBwgAi1utZw9ZuKSfZFuHhAUW8oAqv/NrWV2NH/deBM8fdruo/cUtp6wcAa/Xwnw8+yDFejMhR5T4t8JgWR1cdg92WaEmJvT0tdmi9pXTkKS2tpdWI6UvJ0MDloHsbUX0BKOWDuMhaBQ4TIO5kmrw/lYVvsTSVbPGRWI4G0iVYdF5YrFvJoJ6520aBFTZPfXINARw7F4f/Ehwcz2vW6NgI/cccHNDP9ysloTFw1Eri8G/dajj1yehDqGMN1zHxMsDKill0jTc7NQ9LJbQi7oZi/Qq3Ee3t+wI46WgYasJg+NrQMNKNYxceGJjWe2YczjnPg98py+DWWIytyD27G5KO2IR6/fhKndEiuXWBpktmtn/8NgznBmDRzCUZRy7TkfrPLI5W27JvUIFW2rHDbNhiFTMUE2nQxmJa7SxpqUF1+H3FFVEA0vP7Y47pYHNl5HiazR+GVVZNoHmop7kfuxfXbuVAxn7O1iHbpo4bzQ8X5hHksFS1u1CP54PfYXBOCmZNexUoTGpfPjcfpjWE4JV/R9ZQu4pRMqwF9R9DqomRNPZCd1FFtnj4NPhJkn92L470WYMKCZfCRla/Le3DjTh4/GyOrLr20Ez+azsPMMQvxZqAupGTzFQUpiC5sbuhISlORUhKEYQN7Q3RgH/b1fQNz//o55tIAM2rugRbE8Lr0XQIxf3AmDn6p6GFOjMDJ0Qtpb5NhkOYcx44uGeZSx6ceKWHfY6NoJgL9ZmNZgCEETbXytN9SpJ32xUDa4e/wr9LpCBzrj4V+ptAnh6I8PwVnU2RzRNpZK6i1nwcY1enMC7UikDo5fNLFhw8ffRpQlJqCfO+ReG3NeOhQA6wkMxbHfjiKc8ltBmjUfZv4RMUnDO3hY2DuAC/v0Qi0MoYu7WRekpWE8M3HaHNChT6cOZydLCG06IFF7w5vJbUpdhf++sNVVElycHrLNgjnUONvxR+wQE+C2vI8JJ/9CQdO82zcyiQ/ybgepERK++wV05YgDrQlC81NfRoXJ6WrZcSDh46GtU3z3G9fX1+lOl29evXh/YTYKAwc4q00nKqbAttJ+O8/j0Di+q9wLItnzaVKmOz+Y3t/qAvc9c84q/H43fszINr2V2yNetZGP7ueD4uBEeBPQICeU/4L70ytw8HPN+ESrWrRNaaeGp1G2q+nBo3taFvwj5OFfFEJaP3b9KKCVJtuDsb9ZmD1uuHI3vw5bbb45BuuT6zHhzPogV52+jQfoA9GB0+BedTPOJ+tBadHLeAn8VAXvb3HwLExD8WV9bT5mx08Jk5CX2qN/kQbObKLEWAEOkNAgvzz+3HqpTUIWfUquN2/4XpaOarpqAxd6vRhjk9n2LJ3ZQSe329TN8xf2p/JK/QdLPaSIOHwjwhLePJOj4zKE3N8BL1ly/LGwVpajsxbB7Fx/73HJzV3w3zSqBJlpI2LF6Z5Tqcl6DQ8VVeJgvTb2P39cdzposNBNerEAjACzxOBhvs49f33qJm3ANPfeg/zZfOQaUlyxD8+wQHaFJVdjEBnCDy336bOQOmqd2mYK/XMdnx1IBN57VlFpGV9nspQl5bTwMQxAozAC0JAoGcKCzPaAK6W9vapbmzvLJcXhBJLJiPACKgj8MR6fNQpwZ4xAowAI8CHgKRBRBMj+YRkYRgBRoARUE5A9c5hysOzu4wAI8AIMAKMACPACDyzBJjj88xmHVP8hSYgsIXnjBBM8jBu3342LzS0bpx4mivYn/Zu8XOgDcnY1Q4Ceug9fiYm9JUd2cMuRoAfATbUxY8TC/VMERDAzH0K5s70gZu9GfRor4zSvBRE7P4FkbkP1j/zCaOlROtZwdmtJ53NF48sbU14p03Ahk2hg3APncfZ+GotKfr8i9F3m43fL/dGffhGfHsqW8X+X0+YA2eKgfPX4A1fDteLLoLLrWBzl/hmgcAU9i7DMHuWOyw3/0CrhBSHufJ9n4V7IQloz/ERmMN9Km0uN8YD9rS5XFVuAiIPH8TpBNqN9VlGq9MDLwXOQoDPAPQ0Aapom/vrxw/jxJ3i5m3zhf0w5/11GHTrH/jk0H15WjkjN4T8fiV8REew/vvzyNfm4ZB0yKLz+GDM8X8JvegsC1F2DM7uO4gLGbQh1LPMWYu6c8aemL8sAM7pJ7B3UxKdaaQPM0tDVLbY951PGG2pJHAYg9AVQ3B3fYL2HB9tKadGjq7tcCxY9TJc437AR/u6bkdqNSpo+REd7GhlB2taCt9kZ0772HYHx4dOzB4XitdHC3FjywbsuVfZuhxrq7zzkcMnjJZzpNPi6Cyz69u+A7f0Lbyy9FUUfLmFTjB/pr84nUbCBGgmoCXHRxfOM97EivFS3Dy0DQfyBejlOwMz33wTet/+A0fSn9H9bGQnOVNLbJlnOc4f3Iq9hXRMwohAzF62Bqb//oqO21DibAh7wDc0FOMM7mLbdxe06/RQZ66l7yK8Oac3sk7tw5Z0oO/EWQhZvQh1n23BNWVHNWu2gecuBGdNpy7rlyHqZDiiVOzIyyfMcweGZ4IEJr3gNX4Kpk0cAjs65I52w39OLtrt+9p2fJ5rDXF+DrpDrcSZj0DwjH4oPfMt9rd1erRW3vnUG3zCdFMzaCrG9Z9/Ru93ViNo9lDEbI1GVx6Z100pMLXaQUArjg9n4ompE2yRc/wL/HqxUN7rkZpaDH37dzCFzsOK2HQdIs4Bge++jTHpm/DebsUJtMp2XKax7r7jgjDdzwNOtiaQVmThXsQRHIxIe7jvD2fkjNGB4+Dl2gd2lrSLK+2fI60XIeXod9gYUQip8Qgs//BVOgF+Pf5+OEvR46SLQaF/wwqny/j602PI4tEo4KxGYqqPCRL3/BNhV5u7n9PT88HZ/S/mThuJ03ERaLXARNZlPXcF5rkU4/iG3Ygu13IfDA1vjPb3AG5vx7ZjtyE77SM+Qwzb90MxcbQDbhzL4d27pomhHI/AAu5TZiOIevEcTGW9S3GIPHoY4QnlFI8QAxd/hOUWR/D+d1daVzR6Xnjj87mo+ff72BUvpg3CHOEbHAz/oU6wMdGBuK6atua/hX0bwhDXjv2rOFM6uO+tEHjamMJAKEZ1cQZunw7Doas5kB+SJ3TBvL+txXir5qlrPf/4DfzlhUGM9AOfYv2ZYkj5hJG9wsMOZWffWAyg83Gm+MDDmQ7a1JWivqoEaeE7sPkc5UWbuCa/sx6T5fpQj+jljfjLLwnNQy184tKzw4hZdEyLd3/0kB3TklkCHdrPpkwuT5uXAPbj5mOmewEu/rQd5nNew9B2i2+HbWjKU4pbo60SP4+gRQgc6gAbS9oGX0cCUX4Srh09gOMxpXLGnOkorP74ZXgoarxGOvzx3S3RrQ/+5CFHjkLWu03lYgbVUY4W+nSyBJ19VJCF6GM7cZyGHfmXetqVetR4eIhv48fwrMcPIdVWeecjh08YnnbAq7zzsXlN5auFPtLaFJw4FoPhoRMw0uYOzhTyqOB5pocFe/4I/D9sn30UwiCViwAAAABJRU5ErkJgggA=" alt="img"></p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAb0AAADRCAYAAABYb2zRAAAABHNCSVQICAgIfAhkiAAAIABJREFUeF7svQ1QVFe6NbwAu1G7TWiMDQY0EB1MtMsrxoHR4BjJS3AipCKmQsyr4xscb5gxmCB1A9YIUwGnBKeQuRJmyDViOfheJRUxFTBX4n1h/CQxkCiOhRq5GoxCgm2kMXajnubnW6e7gf7jRwV/JntPOXSfs/c+e6/T2es8z7OefTy6WSCKQEAgIBAQCAgEfgIIeP4E5iimKBAQCAgEBAICAQsCgvTED0EgIBAQCAgEfjIICNL7ydxqMVGBgEBAICAQEKQnfgMCAYGAQEAg8JNBQJDeT+ZWi4kKBAQCAgGBgCA98RsQCAgEBAICgZ8MAoL0fjK3WkxUICAQEAgIBATpid+AQEAgIBAQCPxkEBCk95O51WKiAgGBgEBAICBIz81voFtyc1Acco+A1ApJb4TY1sc9POKoQEAgcH8hMOr+Gs6tj6ar6StcP2/sv6HCD97hT8J+ot1nSqDfBTyUFY8xTi07Kn+PlhI/+OavxVhlf90aIdV/hfbqo+gKXQ5NuB88WLWr6QTaz7f21wgeE2ZitOYSScLspo4Ko0KmQNFzTf0JGOsvuak38CGP4LlQBatdK5kO4nLa3+Gd+kc8FNh3+kbpW2itXwxtRpQDRq4duD/SUZ2NS++2QpX7PnyD3dcRRwUCAgGBwP2CwANPeuaqQrSWG+Dp42ahN7eiyzQP40tIerJF0qaEQst67d9AakSfdWKxVkzW7wFzoGgrwrXyKHiFWfv0UPnBS38IP372FcwN52BubEIXVPAKmYPRwZfQCT8LYXSd348fi7+23NuuNpKfjy9g++sJBTwj1sLTnIsfyt2RmR9Um3bCd5r1p9HVsA+G976Bd8RM67Y5htO4ftwE5dNz4CUTo3QJNz87Dc9Zz0ChkdsY0VFzBF2RBRhL0pNJ2L6Yq/fjhvQ41FrH496hM4GSXWirW4BHQvtleVujVlyvPIqO3i6MuFl+GpgwB56NB3GNmPYWZSBGRzzJWYsiEBAICATuHwSGn/RMp/Fj0Q4Y606js40WjU8glKFL8HDCYoxWjdDEZyTCn5aKl1P33XW5aM61+iq7avNxqWQStPkJcF7au+vegz7/c3TbG2Alb0NfIneoxKiYjfAx74KxhqQRlwD161PgHUwidLreqIj1eDRCPngRhnW58FiXgu4tm/j3LzIMtrINAcudGur3QZ/yidNBflXMhDopBWP5sftMIb47eREqfldbSO/v0Ndewqj4FBtRXkJbM61P11545BxJ/BxGRSRBaSY5muz8tz5RGBdxDjcNF9FhsLCnrSjhoVJbCbb32NcwvZeLmwFPQam1oagl8fO8ufZz9MDXrf8aN/UzMV6Qnh2e4qNAQCBwPyAwvKQnnUZr2tsw6f0wOiYR4wKU6Gw4CNOn+bjcaIR2Szy874dZO43BI3w9AkO/wpW0/VCm/wHjLGv/RbSlv4OOmD/jkXA1bhTxUMA8PBQ9z4Xs7LvrliSSpxzjIrFY/rLwb5dEElHyH0nU05l1edxtaf8cbevO4ap80nQJXWYJV1N+h2uy+WQ2oYOWrLTld7hpeZiQ0NVshkeIa08dlUVoN8yET4zE/l5C+2XXOqg6iutOh72WFGDiiilOVqMCyvg/YkK4mz5shzrpIv5OxksUgYBAQCBwnyEwrKTXUb0DpmY1xqRaicIy18gojFH9Bvp9H+FaPUlPNwIInCxEy+sM0jkXkkK3eZ7zUffflY8znvYVTLWtGBfti26669ob1FC7i4+574FHP8eVFZm43mPypCRba6a8ROdjINSMe2mGGPfyDE2ENtc1VtlVl48fSlR4ODMF3m640sNnkiNJmb5CW8lRdGtephv0SajeOwA6XYdcnN2kZFvcyF+G5vf676Jbksc9RNz770acEQgIBAQCw47AsJIeAugqW67AGFpG9kWpexIe+/7OOJfsVnOzUt/ptGQLLO4p62JPi+hmgwFeM57AKMul/Aa9YrepFZ2SGaOCJgHN38Bs4NJecQidwc9DqWilO1Bps9iscUB3SsVeclDQBZq9EYrSbHTEvYyOoq8wdt1MtKcM3fTpbtyHy/kHGSt0Ld1tF3lQDSPdjCbX04T3CTyUvhYqm/XXXpyP67JlF2CtLI9TqimBscFta1uPkzA2Lqofd7QC3is2w2eA+F9X9SZcLnU3OHFMICAQEAjcWwSGlfRGTYuCj02IYT+tjqaLJA1feE0YAcKTL+QzE2MjnrG6HZtKcK3oIsa9nmiNfdkG0jUAztcLV+PKZz0ksAEt5T2Vd+Dyqh0kjBfx8AweO5mL7+NyXXualYaAjGds72myxsI8ZOGKyubOZGysp3TUFaGt0knIYmY8jdZhDzoeMoknTHGTBmDE9aJNaA9ZTlelk0XXcwGqWhS22KmZ5GP4VIL3rEDctHdp0jXabRoozWCgc2a6rL/CjQEeJbroypYfNkQRCAgEBAL3GwLDSnr2k+uSrSeTAea6j3B119fwDEvDQ24I8U4BsVpdVBFW7rcQByj17zJfwo2K/eiyWXqjo+cMKMcfm7IXY1JsI5HookwgsSXtxvjwHhqSGNM7AoS8jPGvzbWQm1SyAVfbF1u/ayY5vZjQyLlTBELycU5O6GpkikWtRHGPXRvnvEAlY6I6koZ0Am1b9tn1YYJZTncwfw5TudMDBEUv41KWWEQl1mKEueYbeMash0/ALlzqJXKSa0QCRSa3j3wXhSqcQf8dXB7Iiuy/mTgjEBAICARGGoERIr1zaEtbw/iePHxaHs+lYUIipfUjMRuzTCsX0b7rECTtFFp7FHwwgiZ9RvckP0uNj8NrENIDY1BdPewkC1HkccriE7o1LUVOnuNxjH0co6c9aSG4Lo18bhK8+d1ZxYnmQ7SE5sBXpcANWnE3akH3KfrqaefBJy2hT9RjYA5dxkFXgQsoVKk7AY+EP0AdZENviXVI9v/ffXIHrpScoMrT/qQaYxPzoFQxglfh2KadMbkrVfTh9luewMPb/4yH7MWcvXUpZCGRPjKIkOX60L25/Y5CnBAICAQEAsONwAiR3iTK+jdiNF1oHQ1H0F7BBOaGrzE+KxFjba634ZpIF+X3srQeCsah1jHWJJXg+5QTGJf5R6jb9qEl6cSgl7qxaw0uO+fObXkV3/W0fDoD42WOs6gvByu0Osu+gnLFHyzW5bj4OWhv/NqNq9KuH00UJuRH9dOxiblwRegcCDemGwDMt3MuJDx5DH15ddYKY17fhonLnc1Lu8acp2ylui8UsmyJ5WPGQIVPEIoFA1UQ5wQCAgGBwD1BYIRITwmlbo7VARb+DPPA/NCS8gFVhAswJoGilmGbKq0yEqun1q1JMuSrjF7O3Ll4umL1wCjtObS+zhy7pJ3w0dJq1DLxnEZWe/ZQr6OGd+If2dZ6eWXoYosr8wc5ifu2igajEzbCd0b/7sTu2k34Ln+onZOU647IGQ8DFAVGhT6DMS6wzoGm8D/xsMW6losRN4o3wahcDt94qwXc2ykDiyP04xpg3OKUQEAgIBAYGIFhXJckuuLo1jP4YWzkTIcFzyN4JhRjP8D1pku0eJ5k3O3vuJL9CTwTMuCrc7OTysBjtjsrb+lFt2Ho4KIJS6K1j8sqbu2Llk13bSEuc/uxR3LnWElZaaBC8m3cXPgX+EVL6GiTr+M7OGGbmQietsxJWckcujYNNZe3Uwy4Ufg2LvVrebFPKlbdWnpuL3eJruBcJrHznvi4qyBb5wZ4pzmT3jkYS7+G18IF6K7IR3tAAh6JpDuZKk9Tej4MAZuhjZvSG9u8UfZ7/HDyGTySFjUybm13QxfHBAICAYHAIAgMI+nRjVZdhKtVKnQE/4X7MPZZJt0Ub0jcKsSTVpPFymN6QLfpBExZb6GLLsnx4UMgE3cTkc6ho9kXiiD1wO5DtvUITcGjodZOXFIO2M+PpSegiPkLRisv0n6RyyQ8tHwBWrbsQnvoU5CauTNLYD+kaT82ullV6xiDs9/ui0n7VzN2uZtB77GOit/jcn0UHklxjn3S0kvcPIyWnnxJph0s39xPgvkJ/JCwyWWsnTWypW7AQxFzAao3b5qWoDuSYpzgeExIaUJLdiYMIdswnnmYnbQivXVTgF2FMFQ+BW3krWQGulxaHBAICAQEAsOGwDCSnhJjlrwMZc17fPInmUVHwTuAZCRvjSXnvI2diYdjbK7NQMawsjW4kvEO2rckcyeUPO77eOsLY3fDCUjMi5O3+LrhBEn3ySJcKjoIs8qqthwIMYmWixGLMWGhbDH2Ras8dfEUkORSCUqRDKbg4ZD+XYx9/XPHFZK70oH0Lg1qIcpK147L7sQldEcWZ+LyQJZe2zle3k1Mb6BJ39K5i7i273MgbL2FzJ1T5r1Ck/BI+jl46WR8Pofh9ffgkVYAn4WH8MMuPjRwz9H+N+++pYGIygIBgYBA4I4QGEbSozUVuMRCZm27PiJRFOF6O2M/Y/2g0L0ITTz3rOzdf5Jj1szB+Mz16E7jDibZG9CaTmvmllydEq5XcYPlkNeZRE0LMiaKghb2a9NneARFMdeNGyEHPWFTSUroNBio7FSgm6/CkRO8e4oyej38wqky5Q4uZr2s/qRVajnph4cyUvBj+m/QPWMtd5bpbdL/B/PXuJa4CNdcanBHFh7zkJWgdEeam1oxyqIAZeHm0dfrLsIjYJLVLcx0D8lAc4mpF91s5R2XhIeCXDrsPdDNXVr0uzg/5kPK0/dgCkVPrl5/rTqq9+FHuoZdC3MG2Yn9D6OjshDGRoqT3phHXIwWAu9q5gbYZ7jpds9zAHMSOxu5GTe3nbtpVkHFDcDHxL0IpbzRNTeiHjsC6SquYxdHBAICAYHAwAgMK+nJl/IMfAa+jAcNqWj4BoT0FPzw7leMLw3FinLsdVToAozzkffCVGJs7GLryR5jSTUJYygg6SsGXMtZiWsN1iNy3mBvCgXz4mTLrItWqj6fKQKBC/BwkK2liUTCvUTHJi0YmjDDsiPLZjzkYOmdgMG2I8so3Vwodu2AYe0hONh1crvlMy2E0skNsH+wva0BxKWzeAN+cJy6yzcvxueMWRtISQoo4um6HNClyARzWuA33IpZTOjks4r9D2NUeCJ8NRJGWx5a1Bgd/QxGFTJNYj0T912KgnG/9VBZ6i6BdteSQa1cly7EAYGAQEAgMEIIeHSzjFDf96Zb0zmYagxQRNrUo3aj6KK0X1YtempofdIyGXKRc/ec0hU6+e68m+ZAjAm2j0e24kbdJW6BxlfqOHUvb0Tdm/LQ8yojbiBtKQqKbGSV6C0MachjZ8Wups9hPK+Bim898JIVl/IriIKjMNaemHs75Pk6vh4phG9PGMSytW6ubZuDZR49m2rfyuhEXYGAQEAgcPcQ+OcjvbuHnbiSQEAgIBAQCDxgCFhDVw/YoMVwBQICAYGAQEAgcDsICNK7HdREG4GAQEAgIBB4IBEQpPdA3jYxaIGAQEAgIBC4HQQE6d0OaqKNQEAgIBAQCDyQCAjSeyBvmxi0QEAgIBAQCNwOAoL0bgc10UYgIBAQCAgEHkgEBOk9kLdNDFogIBAQCAgEbgcBQXq3g5poIxAQCAgEBAIPJAKC9B7I2yYGLRAQCAgEBAK3g4AgvdtBTbQRCAgEBAICgQcSgeHdcFoywWAyoffF2gNBolBApeJ+kO72m2wsw9YKH8Qlzof9ixkG6q7nnOFYMUpN0Vg13+3GkoN3wTnom5vQ1NSIxvMmaBfGYn6g4yCbDu9FfeAiLApW8W0Ier6+SGubhwHH9tZAtWgRprnZt1I6cwAV5nDE6uzfy6fH4cJScLJwO2R9DYoPqxC3VAfHLiU0HihCfXACYqe5A7FnqpwP36ag1boZkAsaEgysbLLbTrOnipJz1Pa8FYIHm2rK0BwQi3C7GyTxvhUeC0Yix+puRJL+DOr4xoWQ8GmQEZAMTdC72fRavpaP0sxx2A9ECaWKb2+wdWzSN7pt6zIlvik3gO9BdDceS12pCQcKy6F6pR/8XTrkAUMNthfVQ5ewCnw5hygCAYHAA4TA8JJefSHeyK7hxsO97y/oFwozXzsUnvYBUsKdq0g4VlqKOiQh0fnUEL5rNGNRn7sVB6ZtxKKBeK/pMPZWnERzmwkmvsuuzdAGQxv/chH20QYiMDgYAUFB0JLEuVO03ZXPoLy4AkhZymMSagpTURuZhlCu3uGxWjTWVkMVuQgqkm99YDyJsaetAZXFpWiInW/tq+kYDtSTjczNqK6RMQuAKYC4qYIxf/60XoKTGqtR2RCGOKe56w/nY1PxMWBaEHRpi2D3zl7Hmk2VyE2tgDYxAyluWdW+ej2KknNxRksStz9s0qN52lp8kBKCpkYztME+aKzcw3lbSc9EMmvU89UMcr3SahQHrkA4O1BoA6A8U4mK2pNobCKZ8lUWIbowqEJIeiSLhvJCFNeT3JqaIGlU4G1AIAnKJyIeoXxdUvGZPtIz80kqIH4L8pbKLEui2pSJ6sBwy8OFvr4STT4RmM2HE4m4VrcFI1J+sCChHavRYNX/TYHLz0yeH89X5mZaxqAxz8C0lPkY6CdjgURqxF7+virawhHcUAPeub6i0EI3O9jp4cS+gvgsEBAI3GsEhpf05NmEJODdjYssT/L9Fz32JifjvK2CVL8XuaUnwWWTxYSm+jYgoBzZmeVuulBgRlwKllpeWOqmBMciMbIWxTWNWBQb7KaC9ZDUWIWSOh8kxEfQgvGBxoeLrfzXrenZ1410rBzHNLHYaPd+OIVCA6muFDURK6wVzWdQUa6HLsNujI3lqDDNx1qZDSzFzDc+mEib1lmDb1wwySZWbxM9DmxIRXFDG2scw7/+7yKowpPwH2uDcaw4F0XHApH47n9AVZ6JTannsSIlwcUitVwmMBYZ6/XYQJIo1OQgUTeIxafUYVXeekeSqNmE/13N9d5Uh6LcRsS/a5unbSaG+iqUVZ5BmzIQ2tlatFUUo9CkQmhMHLTlFTBEZyAjJdCFDHQrNiKHfdSQePQxYagrVSFt/XwrBLE7sMjWv/yncfsb2Gr3nU8HCI6IRkwAUG84DCmEn4mtqaYJdQ3hiI4JgcJUg8aa8w6ter5IfOgpyi3EMe0K5PzHbDQWbkBqagMSU0jY2n5+W4Z6FGfnohI6hAebUVdNUGzF1FSPurYQrNuyHvMH/vG7HY84KBAQCNwdBIaf9G5j3MoAHaKjA7m4S2goK8SZkOVIjA3sxyWlgE+AbVEyHcamf81HnY03HC+dipeLe45wAU7agvXOq5FWR6sq3GUx7n8KTagoaYRuRRK0elqKx+ietVT2QXiYGYV1JoTwm/lMFZp1cVjVyy8GHN5Tg8BXchBAF2exfhoWahQIoDUpL94NimNQBgUj2GJmkPT1EqbR2lq08V0oM1PRGP8uVpFkTY0HkPtGNqpNIYhLCCMTnIFpRhziDHtQuO41lEYkYv1aV2tFpVuFjMRNWMdFPvRdWj0D8p4e1WVlcHi/bIPbt832whQYmYgVhmTkK1cghdZu095UZLfFW1zMZRVKaANcCc/SuLEShWV1aDrTSMI3oa1JgfytDQiLW0UC7+3ezQeZ8HRopouVjmFCGA5tQyFSS8yYFhGCUFU9ykrrLe0C5oeCvNhbJMMZVJcUobhSj+D49ciJ1UH22gYm5UBTlkt830BZZBxeiY+ErtedK9GdSyIvrIY5IglbVs12fKjjb2HThnqEJdBFKgjPDm3xUSBw/yEwcqR3ZjveyKx0fFEqI3RxOTmweKjsi2YaZsv+J/0BlDUHY0XOUkt8y1SzFZn1EcjhIuO2qOYjZcfsAWKIEs4UpyP3TCji3AVf6jnG13qZ0e0l5IOK4HhszFgERWURyhTRWK9tRuX2YtTp1iOa581tzWjWxvBzM6q4eKsQhpgZJtQ3GaCju85kizMmBjSiJL8cpvhptECqUEuDVi7KaWS0k1WoOim76o5BteI/kBHJlVhiDEwfgrDmXGQ2xCONc5gRl4YwQx1OnqxFbc+IZessI5LUq+rXPafi+wCltmpsL45GaKL7mJu1Oz56tLVBHpocc7NYb9rZiAuhqxK2N/D2XNf2V5LnHMw5VDcypmtAVbWJ1wi0uI2thqzspnRjPenrUE8Cj9FJOM/4qIEPIUH6UpzkxQciPUNNOaqbnQKPciCZbnUXx7pEC+xMBAKnmXA4NxWF9EcGk9SSVtQhf88mvGFhzZ6iRWRSIgJOlmLr60VARApy1oZDI8cqS9vojt8CXUM+snPbkJQUCTnUK1uM+dlFaKM1myUYz+mXIb4KBO4/BEaO9GS7LfAV5OXE2hbiRhS/kQuG8vopBtQw5mWKXN8bi5NFIo2MlfWzZFr6USpV8rtZ3RZ95Vbk12ixImsVnLUeFrFNyCvI4KI2oOEj96yQyaQJe8vq0damZ4ysGHptPLbEBqBRNijo9qqsa6C7shE1zXr4VFTBxCd+xYwYkp4ZlSXVaNY3IDedopeQJLwrx31mJ0GztwhNOrrT9IXIp2WUEa3H1nUSQntMsYZaNAWHYwUqUNpm5tvdw6FTFKOqXUkRECc9NgQLFwXwurQ4zxSjQpUA948HEupr6qEMDYPmMOvF5YAGWT+F8bAVHBPPnin8V5TMSMGK+T2WtTvSo2VYuAllTXJ3x/DGchJgEGOCdBduCI6gI1CP8vTlnAELQTfLxKSNRQ5dpLKdq9CGYJqPHsoQLS3eEATzZl+mtVtPF24pRS89xcSYoOUJg0UVspDjd/wh6StyUa+i1evGQ6CyuCuVmB23FhtJ+ORXlkXYEdvTu9Pf+bOxaEUTGqVAq0UXvBQbZT+sXCgcim7IRvq6esRFm1Gx5wwCVpDwFgW7o/V+LiAOCwQEAvcKgREkPeuUHJ+8XZ7De+dtqinEVloImhnFyMy0Hpao0DObSvm9qndB0UZT4OLOanNCUH94EzYUmxCXkYFFzpalpa5ELtPSpdjv6u/UowpL8z7AUir3ctPLEJ20lHYrFZSspWAcce1SEkvhOtRwiiazFjFJK3qJNjbnA8QaKpGZXoOFVKRS80lLrwaK8AiYigtRrtFDr+AibtYgPMEqApHHd6ziMJrPnMGmMxSImHOxYWwiF9zDFqKM9DmPsuJqhHAFL62NQNKERjT1NxXG4qrqFIhIW4vwqmTkUgATmTLbDdnLRCKhjoRVSsGKSU9xz7FUpJYroeA1NzqraSwI0TpKyUOk5fMx5L5WgYjemKAeZalViMmhe5ZsdnjTa6iO/L9Y76AqoTv3MnshL9lTql523QanIH6GpWM0V1B0Yv0IpSYQwcSsLDUZZZiGQJKYJPlwJIzT9hjupiacUcQ5xJdVwSHQ5/5vbKD+p6doIjPw7ioTtr4mu437jit0iXg3w80PRxbjLAxHwLFS7KlciBUZeVjkTqrb15X4JBAQCNxHCIw46Q11rqqQWKx6nVYXxSQ94k9TrR4NjTrExoT2uq1U8go3YJGl/NnYVCIhloQX24+s0WCgRULFoESXavaGEnCNd1sUIRQ6rI+0xXCoGswthikmCaGmY6ipt2OZpjLs0esQEdAETUQTCnMPU0Ay367dHkjhFIBUF+NAcBzjanrk51bTg0bRSE0yjrXz8lRuhveaakpMY8wpy+zDNvnINcRRoBOMxgYzXaAnUcf2bebBsLBOqenAHtTQFZzDxTlYG4eANziGptmubmamCEjycwmVmLqEFISUb0BZSArWavngQUZwcija8DKhZjstPYtV1kY1rAGNG9hOnk54NGOcigEtIDMFPrWhjAVqTWgsK0FpvYRAK4NCGzIbs2146IIzEOrkvJUkJTSMi84IGOty79qbDTjT7HpTJZMS4Sk7sJb9Gg5QvHJerkMLVNIhcUcGImVIj23Fa6X2s2UqB036umO1qK6oRN1luc1YTJDd2UWZpNqeokBIfAZWze7H9eAySnFAICAQuNsIjCjpmRtLkZ5caSMsM+gZtFkEbqap0YFKf4diYHwHBgoTuPINaRmR5Jy3TBQ1hCAxh1ZNf5YPr9LW3MYFU8t+KaIw65CQk0DXoeP1zXWFSK5g3qHlsIlrYSbeO0mzpJGCB8awdNFxVuEKCbAwtxbTEhMxtmg7VBSUvNKQjvxKHWNzKlqAHBMDVSpTFeoiIhCpoJiCAb0AEnJ9xXbUMXWhTVWB7dutA/DRxWIpB68K1NGOkQUsdOEaZHWnbIrIIo6FWKhl/IzkN2ih2Ke4nPGoxDiLOxGaSKyILEdm4QHMp8rWASL2b2LupJZznUAL2IcEoPRhfp78od+igo45hj4NzTD7GFCaWY3QFXRpmwMQHNBmFbKQt/srCj4AJC21qmxj14YgYOu6vlilXSPZunOxu5QKaOmylVMVnIukakBls/PR2/nOuDCVo+nVSqZbUJlqCkBM+lpEughWTHTzZqLRTd7h7VxVtBEICARGBoGRI71pK7DlvThHkYmckO6yWDDr6vB2lFL56FzMzVxIDRUo3FrncEolKyMjHZdAWdlYmEuLjaKTjBzmrQ20TjM+R8EgtBE9q7ECGq3GNc3Cx34xJdlEJyKLaRAhwT3JznTZVXNoZhOCmEaxaJqEvZaR0k2ZmIUQpjLIJSB6LXLiGa+S1YAk5ia9gYpGxvUCeJLu0j3NWro1g5hrZ72ewkcmP1o+laWoqDmDMw0NjIyZUM5FN4x/G6rKmRBvoMvTDZiWK/YUOZ+tkAnsq/Bur2STFuQrKzD7ja3YWkZSto+BNZ+HXhPAeJ4lQOdamEsYsVBlwclez6lStaGquBIzsqKZPK6ioKYBpaUGpKSomEDO3LUB7oW+mqrL+r6nDRNjuLNtlp7jAAzcMEDJPD67zriRQFN1FSrcwWBopmWqc50Dj8gCGwM1NiaTqyXo2oB4rfoPfLBKPnOMbtBSi+qWPwGnwvvFodmFIZ0riO8CAYHAfYDAyJEeLRIN3YdDKSoNF5FgV9JrM9Uz10rDc475dgo7MjLUl6F4Txlerln3AAAgAElEQVRq6PbTkWi2kAxdn/udRkHhSZ0+GNGyusX1sv0OWTONcTBDIxoO1+DMyZM4Kc3ADK6bCp/5WGRxw+ktu8xYrs+/PeuiJiAAbXUk78pKHOOqOHtVBl2Vsg3HOFXmHihJpmHn6dpTxCOlVw4vu9fGIijyFSwM2YP89lVIiQzA4RpaVtHxzE+jEvQM9ZtkzoAg4uwyDwqDaJkW6cORltfjnrVNjRL/RCZipzJ4mu+zsTdpXd/YSA9rBFRNNX2uzLYG1JxvtBCIUjkNkXJOPr+dsXVl+VyyHWdCE5GgMVmsNCWttxgF44KldMcGzEDIADdES4Vk3qq++3ts6xtuLT1QhVmcXovoHSlOYh26ZN35XfvlM4pkitKRbvtpakniveAxr6+Q9+MMBVTQEYfeOYoPAgGBwD8LAsNPeo0VyN9U5yodd0DMRDWj2epu43GNLpJbc7lCalDUMDYUhmjuYuJu3dQfprijSE8raS3WTttDOX42suvDERoywWJxKOiYNNEaMJna0N5G96BPKOK5RZa+tByN0+KsFgjJQiK57uEuG1pn9yZ3GjFbHJhy4Y4qmW9ge1Mgpunocg2liEE3DU2FRUxEp9UkW3xyka204q2QRZ3KgAisoOvucOY6lCuZMB1NJST37ZIXU4nEUpxfiDptAjJIdFo678xUQaZuaETK+qXcaURJaf1SC0YmxqEUcszPUmgtyzvGBNJdKoMyjSIa8meT1cS01LAkXrPvSgPjVBvXYrab1VulS0BaggGZ+clIbVjPMfjgcKWJDw7ciWZCOMw9gKs4H1U01kaHWvumlcQIGMdkGQoL8/BCSch8MDHrq60EROznr13P+TDHMDTO1YK29GQt+upcJLux9OSuDSQfE5Pc5SI1cvcc2dUqf+YYTNz9hQhY0g9ecRO3lahmrWOagV7eg01lv+mACuFJ71pien3FZreqQrEijfe7v+3xLA0YxyvcigYXTM1o5gONaqF9v+KzQEAgcL8hMPykR6stInKwNAADU7ru3BGkUgVRRZmIpfKqPn8jwmOYMsBdMurPNzD2QuEFhQ5Kxn0UCutfFeNUGlpjNfRDRa6I6F2Mldw+Kjg0lO5Ix9tjZpyqpldSqKH6cQcinfIjfOjWXMFkcrdFoyUvaJhk7ri7iMxQ6Zm1CH4lAzkUp1jXT7o4E3Og3ZuJrcXTkDNgLl0jyjLptvThLiTM5Svm52O0iCPXykwlobmuCo0+FOAwt7B/Ny9dhYvWIy+4DNtrqWTlOHVxCdBQ7KIlkcrFYs0pKK7htmg9pXFPJnJrzCTeSJKN9ahGxwRv2RJj8jYiZfEKi0oWxUQg3r10trc/bXgiNq7os/TO7NmKRqaI6KiQLC1Kxb8W27ClanL2ivWWuF7j4SLsqeNxLdtVFmN7b2+OH0K0TSjdvh1KusOTYqeRnpWYn7EDto3g3LRiKojd/qJuKsgTQwB/K6FuSI+SXEt+oygCAYHA/YuARzfL8A1PdjXJBDOEHmWlICsOXJXWGfsbZGewIVxsoCqyQIRLmduL3MJ8BrrEHZ/jOCxL9l0uspVMq81lfb/Lw7gbl5MT7PkjGBRjib9bZX8/8CH9pu/GbMQ1BAICgf4QGGbS6+8y4rhAQCAgEBAICATuPQLifXr3/h6IEQgEBAICAYHAXUJAkN5dAlpcRiAgEBAICATuPQKC9O79PRAjEAgIBAQCAoG7hIAgvbsEtLiMQEAgIBAQCNx7BATp3ft7IEYgEBAICAQEAncJAUF6dwlocRmBgEBAICAQuPcICNK79/dAjEAgIBAQCAgE7hICgvTuEtDiMgIBgYBAQCBw7xEQpHfv74EYgUBAICAQEAjcJQQE6d0loMVlBAICAYGAQODeIyBI797fAzECgYBAQCAgELhLCIwQ6d3E+fINWP6r+QgPD+erf0pxxTKho8j+Fb/Lx/jvzfJrIzLNK6W/xfyXC/gq0/ukHMnEs89uwJE7GE7Dlhcx/81yOCN26N9sGBPPZzfcyRXuYHCiqUBAICAQeEAQGP5XC8kTv/kFCvKOYPyaYvx71HjuSj8O4yyAPIW0/6pBGt82t+XF3+LbBwSkOx7mxNmIigLG30FH6qd+iahHg1zeArDgT4dRw34PbZiPzDvoXzQVCAgEBAI/BQRGhvSufI8r0kQsmB2E8Va2+ylg2f8cg2KQltb/6aGceXTBOmQMpaKoIxAQCAgEBAL9IjC87s2GArwsuy6X5OGk9D/4S7zNldnr3ux3HL0nXF2T57Fz+Xwk7Pmur/GVo9j5b8vxq/nsf/6zeHH5m9hZf9Op82toKLW6WOfPfxG/LTjq4hrsfzTXUP7mfPzq37Yg+7cv41fPPotfvcxrHHVyLl77FG/O/xWyPz2EgjdfxrMcz/xnX0b2EVu9o9n4lc2VGz7f2b0pW7vz8dtyq+O3Zyzndy7H/OU7cd524HzBy73u4HA37s3+52B35mYDyrN/i5efpStUxuu32fj0vB1ePF+6QcZzPubTAt+yJxvL5yfAHvKb3x3CFs5Rxnz+sy8iIbMUDQ6Qf4dDW960XWM+nn0xAf9W6sbBfPMarly5gmvOt2tIExGVBAICAYHAnSEwvKQXsgYf1NSgZl8yZih/ht+V8LP8vSjujlx7jlO8iSMFG/D+lbnIKP4En5Rsx8bVc9m/49vLpe8PYk/9L5D212L8NflnOP+3HPzNzRo8EHytXxyD8jfb8V//7xP89dfAnrcz8akjR7G5EQf/sgd4ZTM++u//Dx/9NRkLxtte9/pUGv5Lnv+fF0Pt8gZYHZ775XjU7z9ii3fKIzmPQwe/xWNRCxBkG1jQmg8sGBbHT3RxbQ409r5zV1D+9pso+FaHNf9egn0lf8XvHqtHztsFsD4n3MTRvLeRVx+ENX8tQcnmJTCW78f/2MN57QhyfpeJYxN/jT8V70MJ5/jU+QK8mXWo90HiWnkONuwH4jaX4JOPSrA9/RU8pXYd4ZX9b+P5519Ezheu58QRgYBAQCAw0ggML+mN9Ggt/Rtx5Xsj1EG/wOyg8RjPOJduwSuI0Tn5UZWzsTo1Brogno9biaiJ36O+wVkGMvCAlbNfweqn5H69ERTzayxQfoF9R5xZT8LEJalYMzcI47y9MT5kLuaGeA/cse2s7rlfYnz9fvR2ef4QDn77GKIWBA2p/ZAqNezB344FYfXGNVigexSPPhqC55JXY+6VgyivZw+Mv+47eAWzf5NKDHk+5Dkk//oXDgT73cFtOKiMw8Y0GU+5zgKsWRcF7yPlOGKz2GTrjZPH7KcexfjxjyLoqefwynMhQxqiqCQQEAgIBO4WAiMT0xvR0Y/H3CUL8H7WW4g/T+LT6TB7bhSi5j5KauoryvFBmNh7QI3xtDrqjTLpDT3IqJ440a72RARNBL5o+J592EtS1AgJCbq9Geuewy/H78N+sl5MzHicP3QQ3z4WheHkvGsNDfheOoac58OR4zBKJX55hYzF+Ot30njoQvpwGcf5TFT2kfu39d9C+vYk4sP/5jTPGTDK1R4FghbEQUdr+rcvHsXs2To8Nfs5ind0GO/E/+Pj/oqauNuDS7QSCAgEBAJ3isADQXpGR88lxj+3ESVPNeDYkWM48kU5Ct56H6W/K0bRyqA7xcOxvdN13XeuBMWpt1l0iPnlRKySXZwxs/GFk2vzNjt1baZejD//vwzMdT0D2IVK3Z3uOab8RRb++9+fc3iwcKgfFIe/fvIL1NMlfPTIIZTmrcK2g+ko/vcYmRNFEQgIBAQC9wUC98i9aQ1wSZIrqyiVPCfdtIvQXcEVN15Jb7rS5sa8gnUbd+FP8ePxP4e+GOr6PWTgW8//T1+fN79FA3MsJobQ3BvGEhKzABPp4jx0lO5GujZjooJuq3cZN+mmBGd9yLiQEEyU6nGsv3jm+Il4lFbdt3au32sN52kd9g3jMd1jQMMXOObcufNIvR+lqzkGK9P+hOIM5mgcO2SLG9pVFEIWZ9TEd4GAQOAuInCPSG8invqZEg0Hy1H/HUmNrNaznloW6Stf4NN6memY5F76NxxptSfHKzi0swClRxrwHeNIVxoOofzYFcb4HhtGsYztDpzcg7zSenz3HQUmBQU4iF9gyVx71+Yw3KkQujMn1mNPzj58+7MY/PI2zaIQHeNn9eXY3/CdBc/e54SQJfj17CvYsyETpUfPW+ZSz1hcwYYtOCRX8uacmEt57P0clMttGVcs+Nsxh4k9GrUSCzj7nA17cIR1vjvfgKOf7kRmdnnvQ8H58gIUlB/Fefl+fteAgwfrIU0MQpBzePOLHLz4/PN4e79zbHQYsBRdCAQEAgKBQRC4R+7NcViQnIoFb+fht0v+QqtuNtL/+6+Ikd2EIb9G6iv1yHrzeRwc9xh0UTFY8Ngxu91VlFAbmcaQ8ybyrrQCyon42dxk/Cl5bv+ut0FA6O+0b9QSBB3agBU5XKAfm43fbM7Ac0PmvO+wJ2EJ8k729f5W+EHLl5/9rgS7el2xIRSuTMTf/vYtZiT/0tEVKKdEPJ+OL3o5Pwv/KzyLPUxE/PaPsE7X1/f4xalIPvY2ClYtQY6kRNTmw9i4QD7/KGI2/xXIK8DfNqxADiHznfgz6H4RhyiLwe2Np5I3Izkr09p2/GwseSUKjxXYmYbjFiB9+0a8n7cNmavy0Ao1Jj7GWGrc6t6Yp3IcU0S2ZaE053tKjdR4TBeF1M2/gbOU5do1mWl9MX6iG2ln33TEJ4GAQEAgMCIIeHSzjEjPD3Sncp7e83h/4l/xUZodszzQc7qFwdczv/C3V5D833/Cc86W2i1041qV6SaZtPIafo3iXSt70zJc64kjAgGBgEBgZBC4R+7NkZmM6PU2EaBLs/wQ3cXMGL95ha7WbYeAX0Rh7rASnjy2/8GReiUWrI4ThHebt0o0EwgIBO4MgXvk3ryzQYvWw4yA9D0OFmQj7/tWuiZ98bMFK/Gn1OduIbljqOPRYd0H/zXUyqKeQEAgIBAYdgSEe3PYIRUdCgQEAgIBgcD9ioBwb96vd0aMSyAgEBAICASGHQFBesMOqehQICAQEAgIBO5XBATp3a93RoxLICAQEAgIBIYdAUF6ww6p6FAgIBAQCAgE7lcEBOndr3dGjEsgIBAQCAgEhh0BQXpDglRCl+s2oUNqKSoJBAQCAgGBwP2DwD9FykKX/hK6tH6wTzrsbDoNqc3cL9Ie2icwWuvyZle39W8W/wb6iicxflcKxrqt8dM42Nn4OdobDI6T1c6BOtQPHfWfE+9+ngxUUzA6dBK8+oPJ8HdcTslFZ8xf4Bc3CR791RPHBQICAYHAHSLw4Cenm75Ca9o7kGakYELKM1BYAJFwvehtGE6q4enjSmzdbZfgEZ2HRxOedFpgL6G98gT3/4zC2MDBkDXiRvUhmH3mYpzOd7DK9+n5c2hNWgNTc8/wFPBetxfaCFfM5Bod1UVoKzfBy4Zpt4kPGyFpUIUqcKMkE20NKniqHNt2mwzo9nkRE95LdE960jm05eTjBmbi4RAjbp457RYrT+2TUGrcnhIHBQICAYHAkBEYYdIzoj13Na58RutgRhImZi12sMaGPMqBKqrmwDc9AZfTc3E5Xw2/pDl9i2tYEh5NmedEbK34MX1l31sI7PuWTsP4Xi7w+lyS3mAbIpMgS/LRHuIHNUnvwbROJmHcG5sxWjaIG0vQuoOEP1gJSYBfVpQF4+uFK/GDvqeBAl7RmzExYYoDFuayt9BS3k+nptNoy87EtQZaiIoTuJr1tvuKZjM8wtLgn/bM8P9+3F9RHBUICAT+SREYUdLrqqdlUGscceg8g5fgkZRvcCm7EFdj3odvsO2SzYdwteyS0/UNkPRc5XvqjPjo7ucLKKGYNtNiHXfz1UF3s3Q27oeB9+v6ZTM8w2ilp0XB2b7sNnwFQ84mmExR8H1dEN7dvD/iWgKBf1YERo70aDW1vXcQHgu5mH36id1LYUcGSq/QJGgLJYyyd4GZjOhovuh0QRO6+g/1jczg/pl6NV/EzcZz8OQd7egvhodzuFb4AW6agK7zxF81l/V7ioQbpW/jh10X4bVwLSbEqGDcsomWeis06+Ix1nL/6DquLMLVXQfRGbQcj6THY4zqnwlEMReBgEDgXiEwYqR3szwfJikK4+OehJGkN/JFScJzshVCFmN8ohv3ZvPn7t2bdzzIi2hbtxrXVM9DhaMwNRgxii5Wn4ivcfW9/TBLfhid8Ac8EimLNSS6fpfhSu0U+BRuxjineJVFPLPPDNWmnfCdZhsY3YE/Fu2Ase40OmWRDhnCK3gmxsS9Dk2oY1yx8wwtqR0f4EZjK7pVkzB6SSLGNLwDQ+0T0BT/EWpns2qoc2/4AFdSPuirPctdw0lQhDyOTpMaXqELGPOcY2fFKeEd9jJ8gp9gLNDqFh6dvRk/FubiSuInuBYxky/D/Tsk85NQvf4+JoT72RGmu2uJYwIBgYBAYOgIjAzp6fejrfQSRiduxFjVUT63j1RhzLA4F8ZGm2pQNQ8PpSzG6J7LnfwAP2Q7u+1ooTQO7N40V73HN7JbJTFyV92yYtHMeF/hVlzvnYoJkpOQsfdUwwl0LV+OcT67cO2zXPzQwAU8PhGKqiK07/oA1yNlFagSY6LnwfOzv6O99hLGRfvZgXQapuomIOBlqHoID5fwY/bbuNrgC+/oBIwLUqO77SIkqiZv1F1Ct41ALONt2ocfMt6DpJqJsctf5pUu4nr5O2gz9aOutLvyoB/l2Gz6YngpKRZiTO9Kb0yP19WfwPU6GyiaKb3Ck279RQp+pkBhI1qPwHlQy0IhqRU3idXNuqO4STcnzK0w13+FbvnzBAmdtfvwo2kOvINJoloNRjmJZAYdq6ggEBAICAScEBgB0uPraQqLIAUuh18ErQ+6uEauKOHBVAUveTHXH0V7HckGi/su5+MHxYwnXC6vmDGThHEC7Y1ToAq2N3l8MSrkCbo/uUif72vWLbvxzCZ0nv+G/fcVj8CZUAa5kRQGL8bDsVFQNLXi+mc70BX6GjTRT9LiouR/yznGFGmkaQEP3fMYPeEg2ito2UTH91pD3WcOMtZFbcdri/veBm8ioZykoGNhEiYkzOkTi8QlMB7HvnqHRTIq2UVLKRDq9M3Q2GKXclrBpZT3cMeeXTKXByHz4Gjlf33FjK5aPizUykf4wNDzzEARCuCHsbRYx5PAO2oK0brvBDpIhBZrVUEyCyGxLXwdE1LnYDStdVkVeqOOWNUc4VwO4tpl24+Idb0T/gytwwOC3RDER4GAQEAgMAgCw056nTXv4epJDVSZi12ECYOM5TZOy9YS3XZs2V3zDnPInLoIWEDymYfOGlpbFRo8lJRAj2ArrcNstJbTSlI9idF0D/bkj3WZAjEubTMUThZFT57ew9nOeXq0Gg1GS+K6l/36L7sd5aFofK2uOa3aSkoq2Z3XhK7eB4EnoY4IRPu+gzA1kfQsaRIkrU+PoEsxEw9F2Fl/CgU8SSTdjV/humGOLfZlna+jcvRrkiMvEPQyxtqJdTwCF/A7703jbcBsa9JtITCFHcHa90X1ZsxajK4vREfcTqY9WNWvXXW5+C7XSJytdUcF09UZNgljAyZhVPDj8O7BhqflWN/3jXSJp0RhTMQSyz9rIc5NfBC5LMFrhr1FfPtzES0FAgKBnyYCw7sji3QCbUWHgLBEPDztdoNGw38jRoXSTag8xFjUW9Az5nallgSYvY2J0H2EB7oAr2a9ipZCuteGOgS6ES+vWonWOqcGFkvIWjxIVB49fj2b9dNt52X0jl5MGmki0Z2zXpcYttfIKR7POxAblPMwbvlMeJz/CFdWxaJ53dtM0SjEjzUXHaxP2WXYKZOqbOU6DItW7ATHI0OdZk89y7iP56I5PhYX+e+HT52VsbQuF07CzXLmL1oaUbRS+Tmgi8Lonp8Dk9l94pgHqXucDxcUulBs1Gn5x4cQxio7OHaP3mM95yR4aBiXDGWu3v3zs7pV+ER9gYBA4D5AYFgtvZvlhWhvewLqmMfRZWi1LsZcwCwkYuYCxmOgtTPqbi9cyklQr8vDqHJaeLsopHiDMbHgwfLwhuPuDIFktLTAZlCpWLMfNxLWwrvuIG60qzA62i7f0DIUJUbHbsaj4acZNzuBG/WMg9V8hBtV+2F87o/wT5w54oKPbt5LjxlL4BP9uIXUpYp8p3gtUyAiXoR3yQ78WE+LTUvXZB3HneI4l+7GXWihGKbTLcS5aFnh5oTiqTsT4LjpUhwSCAgEfnoIDCvpdTbzyZ+xL+P6V13FKw07oF+1A6OWb8NEbjXVUbcVP5QAD6WudbRohuUeGNDRTluj7YjF8pRIEpLqRfhRJajVUh6f/xYumzdjQvT9sOWVL1QLZ+Lqu0dgql+Oripamj7zqGx0T8ryziQqxgdVjAGCu5kY0t6CsWofrifMpDVL8JR0qcryfu46I1tb3r14tqJDFoj0W2xuS0k259w9lfChhbFNL+5Wo46YZOnFs55KUjshi+Wg5hk8HPcB9EVF8Aog9toXoQ117M8jmPHe4hdhb/FKJW/jSvUk+GxJwhinZ4WOqg24XEF3qLth9TsfcUIgIBAQCLgiMKyk5x2zHuMjnC5i+hxXt3yCjoDnoVk+jxJ7a0xGXvC6Gz/BlTQDOtPXY1zg8K1o3WdKmC4gj+NzXKeic3RMCtMGbLL5iPWYAJn4uMj6bMMj4e7JxRWqkTviFU7FaVEmY1r56GQ8znPh8xjjAgdJR2IKgP1xpR+UFMSg2X5sT2DMDBUFNIco1Imn8tF6rrtJ/t7/HDzoDvUkTXbwwaUbthikQ3W6H0lwXtFuhDtO3XrHMM5a8TaVqxSwZC6xI96eikp40eJnXoeldHE3mB+rLkER/weota6720h6unu1JL3+hy/OCAQEAgKBISEwrOuIF0UKLhsyc+9FI0h6lKyPDp/Tu3ApwtdCm6nG5awP0JaxCR7Z8oI3pDG7VOo4sw9tu7iFVruEq7n74ZEQD9/UZ+Clo7rSTVKzQia+gHPwuCsuTpfhuh7gVmqqcA1dlUcYBQu0WHKO4hQ20R/E5XUfwSN0Lrx1UzBKIcF8kgKYWu5o8rRdzIxW2tj4l3GtllYYt/XqWiLvdHKOKQsH0UExTL/yTaYRjAliikU58+VUS7gZN+syv29M6BSrKMfwDZPRGScMGPwhoauZeYQWsQ7TDkiiXbpJ/bpeO+oK8QPvWZe8K4vbzaZJtsx39NI94X7vTlc0xRGBgEBAINAvAsNKev1epZ8TXtMSMCFdgj7jIxi4d6anrI4c3JCw603CzYp38EPR17RAKOVP9YN5Xz6TnIvgKcvgm89B4cNNp8l8HiSJbhNl9YwtdpGIu+iq667YD6+IBPjo7BbyzzLR9Jm7ATfhStxBXHE5pRgGC4Qq1Oe4a0nVJ+gKoGvTTnXZezkVk7kjHofp5CEYa/ejm55KjwlT4L0kAw/H04K2G5dHYDwmZCqZnP4R8wJz0a56nNbuH+DTKCenu0zAdmASHk5bj87893CdbSz5iMwTVORbSa/z5FeQFE9iXIB9eztFjuWwCeaarWjNP4iu8Aw8MuMgWt+jeKg5BeNp5ffoeWSxzY2TdOeWfoD2kxIU9BBMSOB5W9fdsouVihWZ+LuYZN9+Xg1lwv3girafu/gsEBAIPIgI3BevFuqwpBQ8Dp8UWhhuLLP+gWVyeuEGGAOS8EjslF5rokt/Gu3VzHWr+8aiDOwyWbcek1WUHkrGrix/+U/hhzGvr8dDtlQBiYnRDEkOvegPoW3H51CmlnHnkKE3c1ez+0whvl//ETxf2wn/2JGR5bfnL2Xc7HZ2ZDHClL0SBsV6buA9B+bSt/BDOS04Pjx4RRdwk2kNjNzE+0fFHHie/Bqespt7xUzLw4BMglfyaemHZmAiN//2bCphvuAOGpy0GsO4W0v8cqgcXNtGGLOXkZz74o+es2gFZrjuzekOR3FMICAQEAgMhMB9QXoDDfC+Pidd5G4qF+E5g3HDW7JQnWdlextFLYUcbrYkc659u99vn/R4Rc5VMk2y7LIi77xiqm/lxgB0WdN16UU3plQnv2bpKcs7Cr1Uji7QbgPbUkHrbXmgYd3GS4zt9v9+vW4TRTe0yi0Wn0rD/HV3McbbRUG0EwgIBH7KCNxT9+YDDzwX8rE2JeNtzcVCml+jo4HSfr5+yXNhirzG35+Fc+3JkfPQzoQ60n6YSihD+7fE5By7PhUp65LwBioeFLnIOXyiCAQEAgKB4UZAkN5wI3or/bV9hR+3cGsweSuup5OgeZ3uwVtpL+oKBAQCAgGBwC0hINybtwSXqCwQEAgIBAQCDzICwrB4kO+eGLtAQCAgEBAI3BICgvRuCS5RWSAgEBAICAQeZAQE6T3Id0+MXSAgEBAICARuCQFBercEl6gsEBAICAQEAg8yAoL0HuS7J8YuEBAICAQEAreEgCC9W4JLVBYICAQEAgKBBxkBQXoP8t0TYxcICAQEAgKBW0JAkN4twSUqCwQEAgIBgcCDjIAgvQf57omxCwQEAgIBgcAtISBI75bgEpUFAgIBgYBA4EFGQJDeg3z3xNgFAgIBgYBA4JYQEKR3S3CJygIBgYBAQCDwICMwQqRnxPGPt6Hygis0xrPVqD1rhMR3pTm/d9u1ttMRvnH7wtnjqK48jhaXxhdQ/XEt3FySnbSg9uNK8LKDF/kdbvdtaUXthx+itvV2BijhQvUBVF+4y/MzncCPxQdx4y5f9nYQGrk2Em5U78O1M0P5AY7cKETPAgGBACwvtx7+0lqNnQXVmJz6NPzl/86Vvpg81R/yq0UvlBWgQL0a0ce34fTSAmRF+vZdn6R29tRZtLS2opX/Ll26hFajEa0tF9By4QIuGgCN32T2NRU/952MV2fZtW2txe6d57D6hTBMdpiREae2pSN9t4RFk8OQPMvxBaeOk7+A/1yTii+js5D10lTLeO+fIs8jlSmGfbQAACAASURBVPO4gMmG6Zi+evotja+1MgfJG6vgu2wqIlZP7XdaUsU7aGteDN+EOdYfh34/9Om7YO57kXlvW4+Q16FNe8bhR9TJF8Z28d17ve/DM51De/kReMRFYbTS2rTbdIkvpFVBqb2/Xw7bXrgMVz7lj66nzEjCxKxJaHv997je5gyhEt6v74Q20vVX01GXj9bCS1BnL3FuJL4LBAQCdxmBESA9Cad278ZZf18oK3ZiJ1px6rgSK3cW4CX/ntlNxkupS5GanIWPp+fhhZ7jZ3cjPbUSvmGzMNnXF75+k/DkFDXUT0fD318mOytxOmJkRHVeOnafukBLTomCNWv4stNZWJ2zGrOUtIwK0pF3Kgzp2SrszVqDrNVZSF00Gbb11wnuyXghORZfpiYjFXnII/G5r3eX75J0AQdy0lFwaiqStyzDPzjf5NY1SE+OxORBB0gL72POeVsLIn63DC1705GqyUJ6P6SujFgCr/R3cLnoD9AmzLS8Fb2r7Qk8XLQeYxV98+6u3YTvKkxOQPAN8Ft+B1PY+/CP9esXpM7qXOgrnoLflvj7A99+R6qE4rVt8IudhO4azrecFWVPgHkSCWwzHtL2NJTQnr0S7W766agrxOXsv6OT566mxOKqQx0+SZhV8H5jG8nS7gHOTT/ikEBAIDA8CAw/6V34EAXV/liZugaRsyZDfTwHy2Rf5PEDOMAxn7tghFFZi8pJvnh66c+hpEUHEmRvUYdhZVYqwoY8PzWmx65EtDEHrZNXYnWsPxdSNXzPfoysnG047r8SOXkvYSrJISzPH3npyVhZEYmVa1Zi0VTXp3L19FfZzoA1JOSCqQWDWIZDHqRjRek48lZmoWXlNuQsGmixk12SO1FQ8CEfIl5CesFqhLH6ojxfbMvKwuqVFXiJJL8sgji7GwrJsjIvC3nH/bE6rwAvyCBE/gvyUlOx+h/LSJovYbrz5VUzMT4tEfqsErQbZmKcpd9v0F5chJv2BNv0DY/PcXfVB+8YrVFT5Qe4uuscRme/D99g+yko4SF/dXi44DGVGl69b3eX4GH3QGBt3Yr20lwYSk6gy2ceNFnroe4lSdag29eQnYvrquXwEYT34P1mxIgfWASGl/SMp1CQtRfKZTmYeioPyXlKTFafhTpsJaTPqlBF7mu9YCLpfYaqKusy7auOwCL7ldd4FlWMW7mPzTnirPSfhUURU+FLd6eSbtRZ0f4wtqoRFtaCvNW70UoylWg9pi7bbddQTYvxAsp2V2NW+iL0Gp/2NaYvw9Kpe/HnvJ2I3rYG0we1pm7x/isnk/CXwji9j6paamshhdlcs0bGJw/sRUVFJeN3kzHdfyqm+raialsOqnou5TuVlixQm/N/8PG2nyMyOhqxL0TCyuMSWkiWeTJZ+r5AslwGI12jOT9PRWokXbwFefiYlmPysr2Y9dJqrFlGi9GeNbVR0OZHWa+kl//wze6hMzHabprd+Brtjbc47/u1umoKVJFzYSLpORYJnbUlMLSp0d18Dt2Y6XS+Fcbct/FjgxndZj+Mie8BkZZfYTIMzQugyV+PUfW5+CH9bUgrXsfDYWrcrNiFH8tPwys6Bdq4mSMUY7hfwRbjEgjcWwSGkfSMqORCWjuV1hZ9btNn5aFgchZW5kym5fYCXuDi+yrOYtvKL3FOvRDJOS+5JRzAiAv/+Af/f/CiNExGZAQfwmk5fXlhOhb6f4mdeSpMjXyVsS+e6KcYL5xFK0nDHeFZmhjZ31kFFPgYBR/HouAlxyhhP93ewmFfhL30al99qZbjLsPPd5L0ZILl9SsqWuC/NAe7F00HTlWi2kWFo4T/rEhafi0U8OzG3i//gVaSHloqkZOeh8rWqXhhzTakR1qtQGnZQlTRbZsu5SCL7t0X0nci4viHyMvLwf9h+2U5BVg91YgbjU1cwDkGhR+U0/zo3pSLEp4+Gtirnrp9+n8S6G5jzM5Cliz6SyQLCR1NPKaxHuoyPUiqFpnQJM7BXfGFKukvGKskPg6nlRibuA1jiJvFSoxIgk9bLlq3rIHJYhEGYkzSemgiptjwdde3OCYQEAiMBALDSHpqRCZvo/XRgsqsdKzeHYbpxlr4vpCHHg+edKoClS0a+KkrUHb2JS6yzlPiYkj35uqsZMxyPjXAd2N1Bd2Y/4LYlnMwSiTNs63wNe7EyvRKrtdcnHlMCmNM7OkvUe2/BlPLslC1cCdS+/GhGmurcFwdidTVRuRt24nqRemIcOc/lM7iY7oNq4z+8Jda0OIvxykj4N9Si//My8P7jGVGp2bRRWrEhzk5+Mx/GdasjoT6FF3AOYx2LtuJbS9IqCzYhupLVKayzumnWSfyBWRtC8PxylP812KZuVrN2CaFOGFTGTOtpEpVtppJhrLLGL7yQ4SNMNUk/6WpWManAft4n3IyLb4sCVk7j+MCSU+mcd9ZL/F7JPs7C1/ZnNUfwbX39qHDZEKHeQ7GF6VgrOXqF3F91w7ctHzuK94BYF2qoXrdfKCbT4mO8t/jkhz/shQ5bkUez/iN44NM8ILejiTG+FoLD6KLx0aZz8HcRPGIdh5U0Rp01JyA1HAOnao58Mn6A8ZpL8JUuAmtFJh4L0nCw/HzoGz7CleLCtGuiIdvIvutzMWPdYAnSbazWYlxmZwHp9dZX4LWXUeBCYHWc3WH0LXwz/CPm9Q3KYdPSniFvQbfWF90123C9VLbSekcrq2jpe7UyjM0BX4p8+DR9BWMtSdgbryIjuZvYG6W4DVjDlSvb8ToIGJ28hD72oDv8iV4av0wagIfLgIX4KGEZ+7zGGc/MInDAoEHCIFhJD3OWhaf8H8vkfQMjDV9TJVmwUqbGITxpY8LuES/QBGFsgDp2w5gac4i1rYrchqDUs3/8CW6QanidF5V7Koqqd6c6m9lorP/OAuJ9fO2UenJEGFBjhLJqyUoZ6VidxYtvtosLK3gwnvuFE6zbxeudbhhragsq4U6Mg+Ri9QUfqzGzo8vIOJVV2vv7LYsbGtZSivtBc6Drt1llL9UzkIOXYivMi55aWUqTsnxTM79ImOLWRSeWOYbtgg/998JDomkTGs1eha2HbiApYy1RfYYULT2dpMYpYjpljbGs7Voicgj6bWijER7anqY1ZVJxeupWiOWziLpWUxXf3bvj9ZqWnkV7p3E29K/7J2x/8I1JFkb+2sXY8KWxUBTCb7PaOqtA8UTeIiEM5qkYaibgodXzIFX435aLrsYs5pkE7ywOqc6JmU31Co7K1C/Dy1JR6Aq2oxxduTYZeLNlQ0+VlVGvAzv0r/jZhjVoCQYmL7CD0nv4IbpffhlJMCDJNOa8haMFRcxbsUkqBIScL32HXT4TIG3fCntE1AoJmFcAhWi0n5cKpGgphBHHkZn3efW1BjD39Ga/Qk8UgrwSKj8u2nFj+kH4SzF6Zs0P9HC87CbSu85qlPHyG7KtgV4hCpXD17BXLwBV0lgssXnQV97Z5sKitAojInjGANIauznRtkmmC4nYHxcCsbFyXgZSYgXYdY3kdSfpGdBFIGAQGCkERhe0pP/O6aVs5Mii4/VK5FHF6bF2pDVhySBbcZFjLXNwnSsQcRKphH852TkvTq99+nWSMYy+k7hIt/C+m9gZ+sk2HjNAQeptQWts9JRIRMay6zk3ShL5oez26jaVJFQX8Xk2hxItXlYtqyA12+FNGvhkLCUTu2mEnQyYpPpVmR5YWUE9lIQU7koC456gwuoPU4X5MJZNuKeiidphVV+eZZiEdqpVJCuSV1EQQ9jZ6cjsTp1tSPBD2U0yqlYmk4rk3VPMS6X09OGKSARq2lNW9i7FlmxO116U/s/iad/7mdd8F3OSjhHZW1Zy3S8tdpZyeJSufeAV8g8eDOlQZ9Et52kxuhEWkmhflYXHmt1VssKx5lDUGVexNX038Ecs9tB4t9LMKrHoaQVaeborSKSSSQO4LrZaHEzeijnQB3hi8tVJMrYeHgbjuA6GD+T3adMhfDECVzb9Xd4LZmH0aHz6GYEumqZK8iY3HgL4Q2xyB6CopW4WCTXp7ka0hPTU2JU9PPozj6EDtViqFSnca1BgdEkOMt4tc9AE38RN5o4Xvm31ygnVhrQ/ikJmER4fYJjoqVHwFyoA+/v9I0hIiaqCQTuewSGlfSMJJrV6bXwfyEVBaut7jXpwgFLjKlW/QJyCnpEISSErJV0BSZjtSEP29ZYia+1pRVKf38bOagQkbwT6W5Cc2e3rcQat0YMLUUKYSo+nIyFNMyUYckOlt6gd4Puyg/zPqY8Mgc9YTx1xGos272SCspqhHEwfUumEZeMZrR+tht5l6zmgFGaylSLPtNAOWsllk0/gIIWFXxvYa0ddJxDqKCcSoGQW5NWwtkPU7GzZSreorLzhUFzHmzxN1rhHXoDvGL+AN+GQroXaZHTgrEs8vegjH7ueSgqPoHxzBJ4nv8KHpEp1viYioSTdgltdMdeXpVP9+RyaJKWYJSBNp1qklPsbaCBG9FlIrEn/RmaGQq6N/NxqVdFxHaqeVCH7kJb6Tkog3fhhoZWsp3qs7vpc/y44wi6ei7B3ERzs5qu4F242tB33W7DOXQEr0dg2jyHwcgPjweqWzF10SLY6Z0GGrA4JxAQCAwBgWElPXXYGuTtXEMvJxdE29qvpGDk6ZV5dKFZ3XS9Y/JfxLjVdKo0eyw9uum+vAD/n8vuUNtCO4QJyMKXUx/mYFvZKZxi9rqZSrwWSWmxHqXjBVjJtACLpTd9MEuvFdUU4uxsjUA6rdE+6vJn7t5LqFiTh5wDUykC6ZG/qOGnVDCcthLJfQmIDiM2Vu/G6Z8zdYMJ+TkfRty6IEaOTx4/juPs9YLsJnX1sA6OUMsBPlzshS9drWsYy2sh4aVSzLqM8cPBCY/Q1R2Fuf00DAlLudA/idHxSXgk9g+YoGQuX/rv0Z3OOFugOx/g4EO7oxqBUVDNoAry0/3wlPygSukbwyhdPB7JjkeX/nO0pm9CW8UcaH3oW2WsspeEBr04f0ttVK0GMeZGC7Jb4zxHJdWay2FMy4SeZOhNYYp9DY9p8dByDNZihCl7NdpmrIdf4kwH4m3PX4arPs45jRKqmV/658/M0Fz0x97kW4lwDzoxUUEg8JNGwFF0dsdQMD+uRSaaPJySeevsh5TLX8AsmfBaK5FF4qiVj0unaN0xf+6UP+X4tosyhvXZWV/MCutXU9nP6HjNyU/THZmH3e8uwxT/hVj5qlX6r5y1Btt2UiyyJsyyIKmnzMK/+DsvXnK33DatIBVZ1b5Um6a6iFaUU1cjfc1kHM+j7J9P39YymWP1xQWmFZx1x9Gc77Yv/wWrX32BOX+RaGG6wYdurVP2xiHJRM/NZ5wKrVaOfyf/VRmZujDJ3lwkhquXIjY2C7V8sJjan5fSPxLJa2bx+muwchkJmp5QmfBeknP23BYqOGuPopO5a9frLsFD+xTGLl8L3+zdCHhvMx6JlEUffKiIJvExtuchKz3vSaFyMnoeuquZPxjMWF7PGLiDjKHSeo88tXMwNsSqoPTSzYHC/BVMNY6uxX6Hzjhih14DhX1unXNlzRQoNK0k0scpUOnPlGfCPuN9huY5dHk6Eh5ARStFLqOCJzlZzEqELUvG0n/RMAWHD2zO1xXfBQICgdtGYFgtPQuZ5dViMq0rS26bkvlitV8yUUGW1k/Hk9zlpKyaCdYkwdWpcpyrb0eWlsq9XLwjmRDeMxd5Z5d0ZFW5Ls5GqjPtrR5/CkMsVMlwmnOxtLZ1MTlyjaVZbZndMkI3UgFJYO8pXyxlLPLVfshg8guMQZ6j5D9jJS4sy0KOHJtkgvma1jykM0nclzvGyLvGLFy2mqrVA9yGbS9ao1Otl1ZPoeikggnlOVAnM95Il++XLXSNflmGA9OX0g25EBGT2SY5Ff+IXopkkrZlCZV3lqEL0tHD28Oc07GygApVi/BnoMLUhgha4IxpfphD4c1xIy7SjUwVkGsj02m0ZWfCZF6Ah9dNgVT6NvQmLugRc9DVfALXL8ujIna0QLtMZv5jrIxCFRNVk6pAW3fNH1CEcrCvb8mATgpCrq77Da71DpRtmdLQ89VcdxBSmxkd/Ns+YzFGNTP+pmcdfjeFvgyl6SCuN/N72yG0NzGnzmZZeoa/iDFaAxQL7dSX3P+ss5zWVx1dmRSUdJlfxsPRPE/Xpm/SN2gtWoPv9k2iYpID7tlKzJKczvic2YDuqv1oZ5xudPOR/7+9swGK8sry/h+QRqCJfCjGrxWTFU2knBFdFQfXRBc/BqYizkScCsYKk5QmWUzQimKpTAlOiW6pMzEmWmZNjNQq1hu1XjFVylYiU64kKdRUQspI3gQtBQfCl9KN0A087/92N9DdNNCY7k2bnFvDSD/Pfe4993c7z7nn3HMuMEVPxbAuIZ01j2KVS1aB6cy9K0FTzg5o6zIRNsGm/Ew1XDxcgOHkabTqEhCZuxYhtpQNy74kf7TbF7jv9zhCpvSeQf2TifhV5BH8v1/17Hn3njC5IgSEwGAJeFDpUUnRmvn4n2hddeUoWKI5v7Oc3MTNOsz8zT/hzDVroIfuSSZFJzLY5dgXWJxFK+p/GvDrP/7eIbJS/8//gn95wvmFYMItWoXK5edOMdDFmbXzC+a8/ZHxNP8HGzeeQYMKEFmlnuaJJ59T2ZoSkUu3bKJLK7CrF+bWZe3H3sf34gj38CxS6ZkLt5UnnfQSZDETwBf3XH3yD9j54R/sPr/Ek1hesnsqEi8dOgP7K9Avxs4zdm306oNIqfDcLkxl+EPeIfzzf3EhwejPXz3pHJijWmpEZ3Q6hq9OtkZFzkpCe+UltFwsResnStEZrYEkgYwzpP9apSf46Rh0YovK9J/GyMSt/cZDWsU11zB5+81uV2Mgnxt5OKNnKGPpGpzV5RpUl1MxfJ+LcyuNTG2YshShNmViaSDiKQzf81RPW3a/6RLXcwHQdaEBzYzetBjXKjmdLtvQ3/VUbmWkaEBiOuf5S9RnMl2h1gD/RUsZhanGx2jNwn3oiFiNEaufIopk6BiZ2ZC/D/57NiHUyAjSdYfRMWEGoze3Y5R9Pp7xAupW72ZQjfoGccGyLBt6e/mVCCoVhguwY4bf27nTe2ST34SAEHhwAn4ay4M/7vwkA0nUfpqznnKu1vXZkqJgUyBOdQw8ZNrEtAS7uJCeGoYG7tvpeXqZc0fWlAW1p6heTAaexcn0tp9ZUekcDPhhfsKDDk39hQud25PkHXydjQ3QQiMtofyDK1SY5YEIidPj/lEqj5nrETFp0I2wS5WysIqW5NsY1UeeXpdFZkmv4LFj1r0AFdBjoNuXsjsJrnFx1xWB2vXs4MZmq02ld/FjA55c3BUZ/ECtyENCQAi4IOBhpeeiB7kkBDxK4BoasndzSROJIU9nIpKuywfZmDZfZc7hgfdgHsPk88w0BDtbWx6VWRoTAkLAVwiI0vOVmRA5hIAQEAJCwOsEHmSR7HWhpAMhIASEgBAQAt4gIErPG1SlTSEgBISAEPBJAqL0fHJaRCghIASEgBDwBgFRet6gKm0KASEgBISATxIQpeeT0yJCCQEhIASEgDcIiNLzBlVpUwgIASEgBHySgCg9n5wWEUoICAEhIAS8QUCUnjeoSptCQAgIASHgkwRE6fnktIhQQkAICAEh4A0CovS8QVXaFAJCQAgIAZ8kIErPJ6dFhBICQkAICAFvEBCl5w2q0qYQEAJCQAj4JAFRej45LSKUEBACQkAIeIOAKD1vUJU2hYAQEAJCwCcJiNLzyWkRoYSAEBACQsAbBH4WSq+Tf7HaVVF/8brT1Q25BsVG/XVvKUJACAiBXxKBh17paZ/tQNXKHWhxnjVjMeoyVqHhqvONvj93Xj+Mf2S8iPqrhr4rDXjHBGP+73F79yWfVbja7bP4YfUq/PBxw4Cj6beC8UvUZ/4Rdw5/OYixmiwKt722Bqbb36H1+jW0XC1Dy8ViNJ8pRMOB3ajL34yadS+iinNRN4i5MJ/bjNur30RLH4ugfsciN4WAEPhFEBjyixilG4NUiqAu7wQ6pmUjapqeT1iVV/9K8wkM27cLj0Tbd8CXea0JAdPGwXFFYUJHIy1Ps7m3NIGhCIjQW+q3f/Ym6otu967j5pUhKZR/VmSftTtvF6M+bx9M5kCg8CCMcZsQ6iB/n4863jB9h6b8bWipMgKh19BmnIrg0IGevYb61Vlo+YH1Atl/oA5+Oj38QC5NQMCUqdCNGYmA2MkISoxAwIiRGDJWN1Cj3fcDZ85B4OEDaP4kDSGLRrr9nFQUAkLgl0PAs0qP1lXNyt1UF04lPAlRh9cjxPm6Nz+rl6qbpeN6Iep2vgfzhNUYkfkUrE/qEJT2Z0Qt6q+RUASGO9033UJHLTAk1vml+w0a12/Afb7ce5epCD+6C2FUGn6h4xAQ7UIx8qHOigtoaxyJobOeoKJwVQIRENq3kjBTodbt+wgdE17A8PwZMO/bgobsDTBlZiN8WmQfbbrop7EMDXk7YKx9HGEbk9BewHa31iAye+0ACvQJRO77v4jUUdnZNatdP4DqnG+gX/dnPBLhoj8Xl9ouHoax0vmGAX7hZrQVceFA2RwZjUNIWhKG9o3HubGf5rPxGppPfoSWT4phGrMeo/OSEPDTSCK9CoGfJQHPKj0i8huTAH3KDMf/UAPH2RSJ5xh23P4SbT9QvVbUsFEd2ugiQwgtg1DlPuN18/dWl9vta2jt1rY6+I99HDo7i8T08TbUHeSzM9cjOjMJOp0BHUY9lQcV14QZcBdQ+/ULaK0yQzNegqlFjyEVJTDQCFJF01FRzVS/BUL3wtuImNbDQas4jB8O2iryckBcKobH9dy3/+3+AY756gyEZa7BUNdVXF7VastwV1lAn9dgyNPZiF79FMcJBGfvgv/BbWjMewmtv0nHsIxkhET0rxXauUBo4AKhLTAB4fmbEKYssbiRVILb0LDuG9xfswmRic5WLtBxcQdq6AZ1vY+oLGDg3vo/otnlCHTQpe/FiPldFqwJ7RdPwVg+EoFjlVVuVyImk7IR5q+/7LlorIG5it/BZQ+B0gt9AmEruWCqoNJzycIE8/UyWuqPI5jcH/r9CZdjlItCwHsE3H2nuy/BCL6UFyW7rSzcb9ixpuk8V/PnlMLj25L/M+Rfg2FCEoLxEe5X2NV9LwvKm2YtgRi68QxGzOq57x86Erq0XYhY9oRFUZvObEFNYQQi9v0ZejetDtWa+fPTuHexkUqvgcpWB+1iAe5abvAzXX8Rh9MsnfpHj4NurOVXS9GaImiR9Ci9njs//rf2ykswnDsN4ydqzy0CQ6jYwmbqYL56SSGzFL+ZadAbz3Jf7SDq15zAvcSlCFv4FIInOb1QacEaDu9A0/nv4fdrWoprZqCj6DAMKRnQR09FZP7bGMr7DXtewZ1zSXgkPR36ST3Wo/+0dERudL1XqlWdQP1bNQhenYlQZ8vZIqVarLhw2cZlYGT2nAEtVK38TVTnPbjL2IbKJ/5RVnHtpo8s8xmce6zPBZJPCCtCCAEfJOB5pfe/NMjgjHcxLoNKg4Est/cAUYWbbO7TtRYJtMazqOVLPDD3CCIn8QJdr7UZB7iH5CjgkFlrMNx2SQWy1BfcQtBq7nNF0GJ0vdR2bIAmk1ptB6/8K3+A+wdWoa42HY/mWN1SHR9vQHUBFYj73lbH9p0/mW+htbwBQXH9uSNNlOMl1J3noiBkLIam5WDYtBpadCdw92vnBvmZVlvEwfXQTh7GvXPvoeGT9xCQshejMuhGNdWg5RyvF5bArJuMkH/fj/D5jyOASrC5thRN675H+9btCKeSDMn4K3QzT6HpYAGaNjEw5dfJeGQlld8E7tvRbTuU89B6ZgfuOQentNymBWigW7IAHc6cJqQiaqV1QeJC8l/eJXoN1HepE6HwH3AP9ZeHR0YsBAYi8NAqvYEG5mdJV3D/xaDVMsBj5wl0TsuhG20k2s+8jn+8981A3QC/ycHY9V3Wxi20VTQgMHFqt3vXfIOKJzrBc+7dpstozlkF45RkuiOtCqW3kDoEL8tEeFwogmc+gSE2RT/ycGrvqvZXVv4ZoWkNaL1Ka26add+wrWgb6guNCFqUg5HpcyxuUUvRjUOYco/u3kDX5hb45zOghxbsEOWe3TcP96k8m46epRKdg+A1PTw6b5ShrSkJkRl2FlrlKZgqbkG3iAEo3ZaeCW2F22ComNOHS5QylB9ETfaJ/sek7tK92Wke11PPyD3J/H0wfl2DwKeXY0jtJbRWKMVLqz8lE8PiamA8V4y28u/QgUju7fI78TvuEbJewz71XCP8p/yWrNLJOBKmz7goOFWMVtMMDMvMRFg0g3xYr6WWCyKdcrdHIGTdXxA+wSpCx/WzaHyPY1Zu9PBQWqqNMFc2Img9LTc717ergflNSMOjh5+ipU5ZRem5QiTXhEC/BDyu9LQbp1C37qz1RUUfmn/MDIQuW25Z7Xu7WHLPjNxXqn2MVh9fdMql5+Ci5Bvb2ZKgUJ186dblHeTLmO7Pp+dYXLNa4nqMiO3tjuv4ZDcaLo7EsK3pdLqxRIzrca81foO2qkgETukKYmngy6wB/mMe71Y8P5rBiKWIWjMSLYcLGBhDa4ouy/CMVAQ7u2Kj6WYOvITGgzvQ4WCxMkBn2XqETWhgG4zeZKSpY9FjaDrv25Rb0LJdePRpHQJd7vWNRGjmdnQWfQOdQwRoJIIXrUdw4mp0hPLF7jxos5HBPjXd+1Fak3Lv8svSyDmzE0ft87maL9WcpupFPAbdFDv+zv3YfQ4KfcwSMGopoTMQuW45zH/aR6XGAJd07k3qjLh/dAeaT+3GPayGPjUT+rRGMtoBQ0EBjPPp7o6eg8hMRueuOYhOutKHUeGpopu1HMEXy+DHMYdRsd0/kItmUwZG7UmyfJfM52jddnmwa1WU8AFoi8iVFqzyEiiX5R1axu4WP+WSd7ey1BMCQsCBgGeVYPkPGAAAFslJREFUXug8ROVPZwRdJALUf5V0jRkPb2aEYBnauefTtdL13BwwoKGpkW+VW2hivlhH7WTo04GWAgZuhOvQSXlUQEpXUUEUzlGP7eUHmBd2GubQsXwBqT1Ca/GjMhvqrEh4y1xB5a2LxJBJT/QKJun4+gJMgZMtLz5LMX2DVkYYBj79GPv93nbxx//jP01ZU0m0pg7SmjqIusxiBGesRyTdjg6BDUa6Qrmf5/90AoZYXvg1aONnpdDDJhhpyZSgDQkYGmsbqPk2738DvxQwQKVLTj0VHlMpLjJ/7uR3fVtdDCzpKToMoQIYvoiRqK6Ga+JioOpWz1zUqkR5pnTwmql7vpSFxIdd7vGZoFEh+sUmI2LljF5z6qrLvq4FTElAyCTrgkyXlgDjF6Xwn/YUr1mf0KVMhWEnA2H4NaPjgFb7PIROOYwm5hXep/vXEiNFy7GlairCLAFIamyMIg1VFpy1BD5Nq9v2+/2iExwplW6aVeHZLss/QkAI/C8R8KzS4/pzSLRdwAH3H0IzMhh+nQtDURldPz/uBdXDxIAWrsrv8gXe3qTMAUbxPU2LZ2YCghnNFz7rEnPRduD+D6VoPkrLjS/GrkW+Y/QgXXknS9A+djmGb3wMzWt2/wjsdMddVe7Qx2GqNFhepJ1XqVTMzOWz5P15uugt1tTQmfPQuGc3jG/lonHMIURNcrIBGDkbnL7WlgpQhrqL9hGUTHFggMnwlY9bhVP7nkwFcFX8x0zF0MSxfSs99ZDxe7QWkWfodCqGkX0ro4gZjPDlgsTWkVbRiPuff0f3JoNoupWcmdGwZ9HqMsanEe287k/F0k7X4t3PlUYaqDByduEaPOLMx+ExlUqhIn/tLlr8ufbWcCRzAKeiaU8pg3/WIGSaDh2c5w5yDLI8FgndhJHQinajdvctPJKSxO8CF4GWe1SIKto4+rcqRVGKEBACPwEBDys9FyOg4gug60vjKr6dK1wX3kUXDw10iS6zaLp4UtdjGLgXV6CnC5Uvl67HeM+fby7/KZPReW4L/nE1iS7Ax1w0Ggl99iFGfCoX3IU+wuVdPObyko6BHNthasznnturMKWtho5RktqUtb1djy6ff7CLflQgkXmHEHK9Ebp+X+gP1n7XU/505/VrqavAFlrM7aFTMSyX+XZ9JJX7hdP6Kz+N+uzTPQKZVcqCOgwgC/cdxKSy4L6ks3WuLFaVCxnARPaOiku4/xldtr0OA7BriGaa6eo1dEzJGEDpuccoYFoyhobkovXjMu4BT8X9i0a6hHvyAodm/AWRgW/irgoK+p/30BjzW0RYchjp1rVYr9aDCNzrTWoJASHgSQIeVXqWcP3QrlWtk5jq9A1e0movoD7/I/hn5CAy7sEtoKBFay0ra+2z0l48tOsMKqgaiWAmO0eEf8lV+QHcrxzbexWvnuSJIJZVuPPWVq9W3bjAHKvwnP0IOsnQ/YJcug4ZSLJ1ntfTN0ClPdTmonNDyh9dRQViNP8wGY8k2typFoW3AU0V4zAsb3ufCk913BXlai9EV3J6WP5f3UtOb+QCysxcyDH8/lD5KZdj+Pq0fva5aOGmb+P+nYcK9wRDZ0Wg9TO6OG9zL9DInEW7NBTleQhd+Rf+GNBKy7npwEc8Xo2Wcg6Dg5SLVM6E9dBESDNCYPAEPKr02i/uw93oPztGoHFfSa3K/ac9ZlMuKoH7SxjzXkfnul2WI7N6r+QHP5CeJxpgKCxGR4wKnlF7eMyRy3ubt/niK+Q/SrnxpeMywOLHdNv9rHI7piLo3GW6V41oLTyF1ilpP91JIObvYNizGa3KxKbFY+Yhpc6etc5aJvCr48R4GkiHWYeAfs1xphZ8XgzDKUYxnltKCzoJHUe34C4VXphSeBOcW7eDWnuK0ZYFoFHnWHhB4/FsdzN/zyAS50Irbs0hjEjsWSB1fF1GO34cQlVfgzhb1bnlB//M6NiFCfDnqSnNBxnJmZhj58EwMaWErto4tWfHxUjiWgwrv4y6r5naAUa/jqHWu/gNGMvzgNGXDEBi7mUrvSZhdLP2O1UPPkB5Ugj8bAl4VOmpJGuzciMx3L1rD6Ol8ARfuNMRnmI7OmtsEkbkR6A+h+c27smim2svlaSLxOMHRG46l4+7X1Dx5KY6vdwj4M/cOzOt0faL+agpX4pHmWrgMtDiAfu2PEbF0ZTP/UQzV/8bJ6Nl33uoy9FhRK7aN+MRWYWbUXvOrgPmqHXSMvBaCaRFNIEvR9teWSBD4oPGOPXGdI2m3SXoVFbvzKVUJv1Jo0cIcxJ10wrRuK8ADevppgx8DPp85ur1p/BUk9FMVcid0WtfULtRwOPRbvGEmE3Q9wpcYdh/tL1HwID7H/O0lQk8lYb6w2q9GS2HWPdpyZmctWx/43Pvnt+kZASP+QjGilC6Lu2/vwaYThbAFP0X25msDVz0MbAlRp0Uw5NlFjJ/85PTPCHnAgJXP8UUEAbwMBjL9Uk1vWXRrtJlerCY9U+hM/xDDJ/VzyKj9+NyRQj84gl4VOkFxExHAJXOP1ZbgwzA48D8eJRXZH6G45mM3IeKyt0ELTsX9/N5/uPWXT/C1aleaPwP30RXEtMJ6g9eQ0Cqas/5ZTCOL3sdgw++gSmihi8Na1L5YL8BWi8zpasFE/O1mJR9+BSDV7ivtZVh8FQC6oSRxgq+8HTW6Ag/un/9HaJCeyJGByuLe/V5BFpqWr9uQ/+4tRhdYE3qd69NlY+XhhH75sCgjjH75BZaaF0HZ3Kvq4/csW5r0lUHjcrSY7RmUw3dli4q/HALZgbSBEfzpJvKE2j+gor73625jxZFd+MEflg5cL5e9zdCnW9ZUGyNVzl/EI2hPIItmm7wU2VUnJzHMwdwLyQdIeZi3D2pgpP43aLF3sLUkJDuuXscekbltlTwFCCHMTOYawKt1q0vwhhBLwYjVRG93JKXaImsnZSB4etMaDy6DzUrdsNvBL+X9m5+43c8e5On6FSpysznO0rntTo+zdaHHzkEjeCRd7T0ggZaZLhAKZeEwC+dgEeVnt+kNETvsR63NSDYiDmI2roedW+V0QpxVlADPs29HJurzEg/0ZgX4Pc1j9E6yPD8hXSv2vKfHFuhSyplDppyclHPvbah6ya77VZtO/kKaguYcmBxEdJl+uvUXm4ldbZk7Z4yBPyGLzW7vDl/MomyhL9f435OBIJSGMpvdwyapv7qQUHDAC5FN3i4qjI2DaMK3ZwPV88PdI0J6vrMt3m49g6y34eGo4/h0TWuQ/E7ynkazKlbfbYYQOvTXHjAenRbr1p0uS7chODfjWSaBqNDRyQjPNHOuhrD3MWtqX3vnZq+xN3sN61nsaq21fmWmX/lj31HtEKz+ePQN0+DYbJ9VC95rBc0JpervE5Hb4GyhHfxp4+HlLVHl+dI/nQVrZJ5ep98Z/0YykO8VzKlhD8uC63lEQeTXN6Si0JACAxMwE9jGbiaL9ZoYNQez5RkdKhuyhO0pLhC56kWQxgu3t8hvO2VPBHEyCCXOOdDkdVxW2UAI/NCnP/UTuN3XNHTIlN/HYDRhyokvbdbtAFtzMnTTfD0HmUP+w7K3tpEy42Rir37H+wc0XphEFAHT4sJ9cDBAe2V19A55omeE1sGK47b9Rv4p5v0TIa3LpQ6efB4K+dzqPNZoQ7tcR+y/HtoKu3CRe6l212zYneup4l/JimvBCF5axj9++NKV3K6bivdlXQ/SxECQsB7BB5ipec9KNKyEHBJQJ2mcm4yzwKNsJy6YpiwCdEe+Lt9ovRc0paLQsArBPozirzSoTQqBB5aAky70T55HbfTs9Cs41+N8IDCw+0LaCjs2kssRIvLZPyHlpgILgR8joBYej43JSKQEBACQkAIeIuAWHreIivtCgEhIASEgM8REKXnc1MiAgkBISAEhIC3CIjS8xZZaVcICAEhIAR8joAoPZ+bEhFICAgBISAEvEVAlJ63yEq7QkAICAEh4HMEROn53JSIQEJACAgBIeAtAqL0vEVW2hUCQkAICAGfIyBKz+emRAQSAkJACAgBbxEQpectstKuEBACQkAI+BwBUXo+NyUikBAQAkJACHiLgCg9b5GVdoWAEBACQsDnCIjS87kpEYGEgBAQAkLAWwRE6XmLrLQrBISAEBACPkdAlJ7PTYkIJASEgBAQAt4i8PNWes3n8drcpdhT7i18D0G7N44gfdYszLL8ZOB49UMgs4goBISAEPASgZ+30tONRkLSvyIu0kv0HoZmY1ah4LPP8FnhK5ioewgELtmCuQtyUepNUZuL8LJaDFV4sxNpWwgIAV8kMMQXhfKYTEFxWJET57HmpCEhIASEgBB4uAl43NJrLj+OLRlLsIDutLkLlmD5y3tQWm8PqRnlx7cgY+kCzJ01FwuWv4b9jhWA0lwsmPsGikqP4I30JdZ6S7egiO3UF72GuUvz4eCxbCvBlgUL8EZJs62jErwxt8ul17d7s57tb8lYyr7mYu6S5Xg59zxudIvqhpz9zf3lfCxZkoHXXmb7C5Yj9zi5LOeYee1IeRufrMD+5XORfqSnR9WcZXxLaOmoKpYLl3HkjXQsUeOZuwBL01+zPW+7jzZUnNyC9CUcA62Xl/ccR35673a7aj/wvxZX8RLkny/B/teWk5ma3+XIL+1iPhCvNtwoysXLXfNu493lbW07z3ErF+yGYpgMZ/F6l0s2/UjPnFSfx543MrBUjZXfnSX87uwpcfbXVuN4Bse/vwRF+S9j6YK55LaEn/mNqT6ODNXuv+XhiukOCld2fUdeRlHXMB4YkDwoBITAQ0FA82i5ru1+JlF7dscF7XpVnVZX+ZV24cMPtUt1PZ1UHntBm//MWu39S9e1qqpK7aszm7Vn5j+nvV9pJ8ilbdr8mfO1xS/s0M5dv6e1tt7TKssuaF/dY526M9raxGe0HV/11G+9sFmbP3+zdkHdty/3zlnq7rar23W7tWy39mziYm3NW1ZZqyovaR/ueF8rs1VwS06n7hw+lu3QFic+p71VVqld2PaMNjNxjXbseqV2bvNibfG2S5aqle8/pyU++5Z2vfvBOu3DNYnaM92Da9UubVusJb7wlnapkjwVrwvHtDMWENbSyn6eSXxW23xG8byundvGNmfO1J5zAGrpTHsu8QXtWFX3o4P7xcIykXO3RnvrUqV2r7VVq7t+Sbt0vdXSzoC8qo5pL3AuNp/5Squqq9Oq+OyZYxe0SmcpOJeJ87dpVkJON69/qO14/wz7rGQbtu8Ox/5WD0A+UKUde2Emvw/PamuPlWlVlLO17rp2gTJ3l3tntDXqe+HwnLMg8lkICIGfIwHPujfb7qCB1tj4+HjEjg6j0o/CvBh79+JlfHDkJuKzTmNVgroPjB6dhRfPLsUHZyuw6tVYu4VCGOaty8LC2CDLtZjp82z3EpAUvxPvFnHlHqfabsOnxdwBSsjBbGuTdm309Wszij84hfrZW/Gfr86D9bEELMtOsD0wGDn76oPX9bGYPT0GcfXjoSuPRXxsDKLiY2AorocyLGKSliHu3eMoqngV69TQq2mdlI9CUlYXMwPq7xigj5mN+JgoBJFn1Gi2190lx36qGPXxWdiYEmsZx+isl1BcsgF3+hHrwW+ZMCp1I15NiLE2EZsAKzE3eDXcoEyRSEmIw+goPh6VgNH20+2OULHLkG33zOiUF5F6fCVKyvmli1WN9hRT7ArkrJhOYixBsZjXNbXu9CN1hIAQ+NkS8KzSC4pHcvIobMhbjvSz0xEXG4+E5CQqPps2qv4WNxoM+Hrrv2HWVkem+lFO/iXdRMRPtCo8x5pUpEnx2PluEV2ccYhruwKrzptNpeBuuYmKm1TOK+JsCs/pucHI2V+XQXqLTEFBjCDR6cH/h07H/28zwaSeGz0PyfF78e7JcqzLjkP134vw7fhk5HS/2KOQkDoP7+a9jrQbVHxU8vEJSUhKGG0baz3uVJsQFRfTM46w8YgbpfOS0tMjloq7V3GH18QUrJj4GvYuX47ihHiuV+KRlLTQWVf1atrhQnMFTu7di+Ol5bjZYCFoKROb1XfHXunpMIqsHNVgd3X5RQgIgV8wAc8qPb56E7JP4PSyUly+cgWflhzCFu5lpb5zFOvibCpJNx7P/+cJOBh1LicgiMrC5Q2EzUtC/N53aRWpF95ZRvolIGd2H5VdNzHwVbflHLipvmtQgSfPxt69J3E5S4/yom8xMWU7YuweiFq4HYXTK3Cl9ApKPy3C/tffxclXjuLwKvtafffg2Ts66PqypgfixaCiVYdPY97lUlwpv4KS43m0+v+OXSe2Y15fbToI34bSvVSa5fOw9Z1dloVUELh/l56GIheD1OnVEkOKEBACQsCRgMcDWVTzUXR7LVzxKnLeeQcvjr9D5UezynJjImL0d6gQq3/cPITRQoprxqdFpfj07GW6NpMxOJ03HrHjgZuXyy1uxl7FU3L2arj3hbB5y6iyS3Hq+EmcvRmHlKTRvSoFRcUiIWUF1m0vwH+kReHbkk/5ulclCqNG61B/80bPOJpvovxOjxXU3ZguiJamSRmZni9u8wqjm3ohlq3Kxt+ObsRsQyldk07iKKOYcvYW8w4qKgyYuOx5LLQoPJa2PsbqxggtKrF3J248KVWEgBB4mAl4Vum1XcZxRg+WlFejvr4eN0rPouSODuMnjrIyCpqO51dNxLeHtjAKsBw3qqtxo7wEJ/dswRHqLvcLLcrkeDSX7GXkJ2gtxQ/Ctal6CUPS86mI+nQvNhwpQUV1PapvlKNoPy0uddtjcroxIrqE6cFEyduFuBOfjHkOPrl6lBzZj5OlFagmz/oK7vldqYc+ZrzNdReE2Xw46soH2FvEOtUVOL//ED41uOh39ETE6m+i+GQpbqi2mrvCQ13UHewld3iVn8SeI+dRfoN911fj8tlixq9aFx8O3Y0ahShTOUoYldnWZi8jFTzdtjdp8VoVfj0uc6wlrsY6kPxhozBKX48r5y+jnn14kMRAPct9ISAEfmICHnZvcv195zz2v3EId7h3h8iJmP38LmQv7PFfxaz4G97RUVm9/RpW0iLRRY7C+LjZWGXTi+7yCOPeVnzeVvxdn4yseEfXZsWepVhZeKe7qU//NAuF6hMDV/77bymW/a+g6evwzq4o7D20Fy+/ewcmuufi5r2IjbanPCXnwOMJwvSUJESdOouJyVRgDg/ooDfcwJGddOvVN9AEGoWJCVn4j6yEbiUfNH0jdmXlIXf/n5BqiEJ86gokT9zvmNJhaXM6XspJxZadG5BWSBNn4isoLFjl4EodWNa+awzIi+5Gw6fv4o0P8mD5aoznnt727VjhbNjGrEDWinLszE3Dvxrs5QzDwuwclG/Zi5UL9iMsLArjGQiUOuVbXOlbrD7ucPGVlYwtb7+O3yoWiMfW/34HKW65WftoUi4LASHwUBDwUyGpD4WkP2Mhm3kKydJcIOe0u/tb/cGw7XMlHUXBT7Lv159sck8ICAEh8NMS8Kx786cdy8PXe1sz6qtLcehQCcKSUgeRcvHwDVUkFgJCQAj4AgEPuzd9YUgPjww3jr+MtLdvYlT8Cmx9dfog9yUfnnGKpEJACAgBXyEg7k1fmQmRQwgIASEgBLxOQNybXkcsHQgBISAEhICvEBCl5yszIXIIASEgBISA1wmI0vM6YulACAgBISAEfIWAKD1fmQmRQwgIASEgBLxOQJSe1xFLB0JACAgBIeArBETp+cpMiBxCQAgIASHgdQKi9LyOWDoQAkJACAgBXyEgSs9XZkLkEAJCQAgIAa8TEKXndcTSgRAQAkJACPgKgf8Pjd1KJW2tkqwAAAAASUVORK5CYIIA" alt="img"></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ 快速入门</title>
    <url>/2018/10/17/RabbitMQ-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>ActiveMQ是JMS的实现，RabbitMQ是AMQP的实现</p>
<span id="more"></span>

<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p><img src="clipboard.png"></p>
<p><img src="%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20181017144332.png"></p>
<p><img src="%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20181017144512.png"></p>
<h3 id="二、环境搭建"><a href="#二、环境搭建" class="headerlink" title="二、环境搭建"></a>二、环境搭建</h3><p>1.在docker下面</p>
<p>docker pull registry.docker-cn.com/library/rabbitmq:3-management</p>
<p>2.运行该镜像</p>
<p>docker run -d -p 5672:5672 -p 15672:15672 –name rabbitmq01 IMAGE-ID</p>
<p>3.在浏览器输入:<a href="http://ip:15672/">http://ip:15672/</a>    即可看到登录界面</p>
<p>默认的账号和密码都是guest</p>
<blockquote>
<p>如果是在云主机上面安装的RabbitMQ,会无法访问，首先需要开启对应的端口</p>
<p>5672是用于tcp连接的,</p>
<p>15672是AMQP协议的</p>
<p>25672是Clurting的</p>
<p>接下来就是在对应的rabbitmq文件修改</p>
<p>1.查看rabbitmq的配置文件在哪里</p>
<p>whereis rabbit.app</p>
<p>最好先进行备份一下，不然后果无法想象</p>
<p>2.修改有一个属性是*-users:[&lt;<guest>&gt;] 的，改为*_users:[]</p>
</blockquote>
<h3 id="三、SpringBoot环境搭建RabbitMQ使用"><a href="#三、SpringBoot环境搭建RabbitMQ使用" class="headerlink" title="三、SpringBoot环境搭建RabbitMQ使用"></a>三、SpringBoot环境搭建RabbitMQ使用</h3><h5 id="1-步骤："><a href="#1-步骤：" class="headerlink" title="1.步骤："></a>1.步骤：</h5><p>a).引入rabbitmq的依赖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>添加以上依赖之后，springboot会对rabbitmq进行自动配置</p>
<p>注入rabbitmq的连接工厂</p>
<p>注入RabbitProperties 映射配置文件中RabbitMQ的属性</p>
<p>注入RabbitTemplate:给RabbitMQ发送和接受消息</p>
<p>注入了AmqpAdmin:RabbitMQ系统管理功能组件</p>
<blockquote>
<p>创建和删除queue，exchange, binding</p>
</blockquote>
<p>@EnableRabbit  +  @RabbitListener  监听消息队列的内容</p>
<p>b).在配置文件中添加rabbitmq的属性</p>
<blockquote>
<p>spring.rabbitmq.host=your.ip</p>
<p>spring.rabbitmq.username=guest</p>
<p>spring.rabbitmq.password=guest</p>
<p>spring.rabbitmq.port=5672(这个可以不写，默认就是5672)</p>
<p>spring.rabbitmq.virtual-host=/(这个可以不写，默认就是/)</p>
</blockquote>
<p>c).在Application标注@EnableRabbit开启基于注解的RabbitMQ</p>
<h3 id="四、拓展"><a href="#四、拓展" class="headerlink" title="四、拓展"></a>四、拓展</h3><h5 id="1）rabbitmq传输数据默认使用的是jdk的序列化器，我们传输数据一般使用的是json的方式"><a href="#1）rabbitmq传输数据默认使用的是jdk的序列化器，我们传输数据一般使用的是json的方式" class="headerlink" title="1）rabbitmq传输数据默认使用的是jdk的序列化器，我们传输数据一般使用的是json的方式"></a>1）rabbitmq传输数据默认使用的是jdk的序列化器，我们传输数据一般使用的是json的方式</h5><p>在自定义的rabbit的配置类里面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 替换掉原来默认使用的jdk序列化器，改成支持json传输数据的方式</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-开启监听消息队列-前提是开启了基于注解的RabbitMQ"><a href="#2-开启监听消息队列-前提是开启了基于注解的RabbitMQ" class="headerlink" title="2) 开启监听消息队列,前提是开启了基于注解的RabbitMQ"></a>2) 开启监听消息队列,前提是开启了基于注解的RabbitMQ</h5><p>在对应的service方法上添加注解</p>
<p>@RabbitListener(queues = “your.msgQueue”)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;zava.news&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveCustomMsg</span><span class="params">(CustomMsg msg)</span>&#123;</span><br><span class="line">       System.out.println(msg);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-使用AmqpAdmin动态创建exchange-queue-binding"><a href="#3-使用AmqpAdmin动态创建exchange-queue-binding" class="headerlink" title="3) 使用AmqpAdmin动态创建exchange,queue,binding"></a>3) 使用AmqpAdmin动态创建exchange,queue,binding</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 使用amqpAdmin创建exchange</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCreateExchange</span><span class="params">()</span>&#123;</span><br><span class="line">       amqpAdmin.declareExchange(<span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;amqpAdmin.directExchange&quot;</span>));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 使用amqpAdmin创建queue</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCreateQueue</span><span class="params">()</span>&#123;</span><br><span class="line">       amqpAdmin.declareQueue(<span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;amqpAdmin.queue&quot;</span>,<span class="literal">true</span>));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 使用amqpAdmin创建binding规则</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCreateBinding</span><span class="params">()</span>&#123;</span><br><span class="line">       amqpAdmin.declareBinding(<span class="keyword">new</span> <span class="title class_">Binding</span>(<span class="string">&quot;amqpAdmin.queue&quot;</span>,</span><br><span class="line">               Binding.DestinationType.QUEUE,</span><br><span class="line">               <span class="string">&quot;amqpAdmin.directExchange&quot;</span>,</span><br><span class="line">               <span class="string">&quot;amqpAdmin.abc&quot;</span>,<span class="literal">null</span></span><br><span class="line">               ));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis面试相关</title>
    <url>/2021/06/02/Redis%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h4 id="Redis的基本数据类型和使用场景"><a href="#Redis的基本数据类型和使用场景" class="headerlink" title="Redis的基本数据类型和使用场景"></a>Redis的基本数据类型和使用场景</h4><ul>
<li>string  （自定义的SDS，simple dynamic string）</li>
<li>list</li>
<li>set</li>
<li>hash</li>
<li>zset （底层的数据结构是跳表，增删查的时间复杂度和红黑树一致，都是logn，但是这个进行比较查询比红黑树快很多，而且不需要进行红黑树平衡的节点旋转）</li>
</ul>
<p>//todo 使用场景补充</p>
<span id="more"></span>

<h4 id="Redis的持久化"><a href="#Redis的持久化" class="headerlink" title="Redis的持久化"></a>Redis的持久化</h4><h5 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h5><p>(默认) 快照的方式，fork一个子进程定期将数据转换为占用空间小的快照（例如每十分钟）,dump.rdb文件，使用的具体指令是bgsave，恢复数据快</p>
<h5 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h5><p>将执行过的指令都存到一个aof文件里面，如果指令过多，恢复数据的效率很慢，但是顶多损坏一秒钟的数据</p>
<h4 id="数据过期策略和内存淘汰机制"><a href="#数据过期策略和内存淘汰机制" class="headerlink" title="数据过期策略和内存淘汰机制"></a>数据过期策略和内存淘汰机制</h4><h5 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h5><blockquote>
<p>Redis是使用<strong>定期删除</strong>和<strong>惰性删除</strong>两者配合的过期策略。</p>
</blockquote>
<p><strong>定期删除</strong>：默认每个100ms就随机抽取设置了过期时间的key，判断是否过期，过期就删除。因为key太多，全盘扫描会耗费很多时间，所以是随机抽取，但是这样的策略不够完善，需要惰性删除来配合。</p>
<p><strong>惰性删除</strong>：客户端获取某个key，redis会检测是否过期，是，则删除并且不会返回给客户端。</p>
<h5 id="内存淘汰机制"><a href="#内存淘汰机制" class="headerlink" title="内存淘汰机制"></a>内存淘汰机制</h5><p>由于以上两种过期策略都无法解决redis使用内存过高问题，所以有了下面的内存淘汰机制。</p>
<ul>
<li>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。<strong>默认策略</strong></li>
<li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。</li>
<li>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。</li>
<li>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。</li>
<li>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。</li>
<li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。</li>
</ul>
<h4 id="如何保证内存中的数据都是热数据"><a href="#如何保证内存中的数据都是热数据" class="headerlink" title="如何保证内存中的数据都是热数据"></a>如何保证内存中的数据都是热数据</h4><p>这个其实考验的是Redis的6种内存淘汰机制，我们可以将内存淘汰机制设置为allkeys-lru或者volatile-lru。</p>
<p>具体的操作是到redis的配置文件里面修改以下属性：</p>
<blockquote>
<p>maxmemory-policy volatile-lru</p>
</blockquote>
<h4 id="Redis中的事务"><a href="#Redis中的事务" class="headerlink" title="Redis中的事务"></a>Redis中的事务</h4><p>Redis支持部分事务，但是不满足像mysql数据库定义的事务的四大特性ACID，不满足的部分是强一致性。</p>
<p>相关的指令：</p>
<ul>
<li>MULTI：开启一个事务，MULTI 执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中。</li>
<li>EXEC：执行队列中所有的命令。</li>
<li>DISCARD：清空事务队列,并放弃执行事务。</li>
<li>UNWATCH：取消 WATCH 命令对所有 key 的监视。</li>
<li>WATCH key1 key2 … ：监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</li>
</ul>
<h4 id="keys和scan指令"><a href="#keys和scan指令" class="headerlink" title="keys和scan指令"></a>keys和scan指令</h4><p>使用keys 和scan可以扫出指定模式的key。</p>
<p>但是由于Redis是单线程的，keys指令会导致线程阻塞一段时间，如果是线上环境，建议使用scan指令，scan指令可以无阻塞的取出符合条件的key，但是会有一定的重复概率，需要客户端再进行一次去重，效率会比keys慢。</p>
<h4 id="为什么Redis是单线程，但是又能支撑高并发"><a href="#为什么Redis是单线程，但是又能支撑高并发" class="headerlink" title="为什么Redis是单线程，但是又能支撑高并发"></a>为什么Redis是单线程，但是又能支撑高并发</h4><p>因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，多线程会增加一个上下文切换的消耗和锁的竞争条件，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。在Redis6.0加入多线程，从Redis自身角度来说，因为读写网络的read/write系统调用占用了Redis执行期间大部分CPU时间，瓶颈主要在于网络的 IO 消耗, 优化主要有两个方向:</p>
<ul>
<li>提高网络 IO 性能，典型的实现比如使用 DPDK 来替代内核网络栈的方式</li>
<li> 使用多线程充分利用多核，典型的实现比如 Memcached。</li>
</ul>
<p>协议栈优化的这种方式跟 Redis 关系不大，支持多线程是一种最有效最便捷的操作方式。所以总结起来，redis支持多线程主要就是两个原因：</p>
<ul>
<li>可以充分利用服务器 CPU 资源，目前主线程只能利用一个核</li>
<li> 多线程任务可以分摊 Redis 同步 IO 读写负荷</li>
</ul>
<p><strong>总结</strong>：</p>
<ul>
<li>操作的数据都是在内存里面</li>
<li>单线程，没有上下文的切换消耗资源</li>
<li>NIO多路复用机制</li>
</ul>
<h4 id="如何保证Redis和数据库的双写一致性"><a href="#如何保证Redis和数据库的双写一致性" class="headerlink" title="如何保证Redis和数据库的双写一致性"></a>如何保证Redis和数据库的双写一致性</h4><ul>
<li>懒加载模式缓存可采取双删+TTL失效来实现；</li>
<li>双删失败情况下可采取重试措施，重试有业务通过mq重试以及组件消费mysql的binlog再写入mq重试两种方式；</li>
<li>主动加载由于操作本身不具有幂等性，所以需要考虑加载的有序性问题，采取mq的分区机制实现串行化处理，实现缓存和mysql数据的最终一致，此时读和写操作的缓存加载事件是走的同一个mq。</li>
</ul>
<h4 id="使用Redis的分布式锁（基于Redission，看门狗的使用）"><a href="#使用Redis的分布式锁（基于Redission，看门狗的使用）" class="headerlink" title="使用Redis的分布式锁（基于Redission，看门狗的使用）"></a>使用Redis的分布式锁（基于Redission，看门狗的使用）</h4><p>具体指令就是SETNX(SET IF NOT EXIST)：尝试给某个key赋值，如果key不存在则赋值成功，并返回1，如果赋值不成功则返回0；设置成功后会给这个key设置过期时间。</p>
<p>看门狗的作用：有可能业务时间大于-锁的过期时间，这时候就会导致事务无法提交；看门狗能给占有的锁自动续期，保证业务完成之后能够正常释放持有的Redis锁。看门狗就是单独开了一条线程去不断延长锁的过期时间，也可以设置最长的锁持有时间。</p>
<p><img src="2020051600372545.png" alt="redission"></p>
<h4 id="Redission和Zookeeper实现的分布式锁对比"><a href="#Redission和Zookeeper实现的分布式锁对比" class="headerlink" title="Redission和Zookeeper实现的分布式锁对比"></a>Redission和Zookeeper实现的分布式锁对比</h4><p>Redission</p>
<p>​        优点：redis性能很高，适合高并发下的加锁机制</p>
<p>​        缺点：如果加锁的redis master 故障，刚好数据也还没有同步到slave，那其他加锁的客户端则会再次加锁成功，则相当于有两个客户大都拿到了锁。</p>
<p>而zookeeper的分布式锁实现一般是由框架curator实现</p>
<p><img src="20200516010224632.png" alt="curator"></p>
<p>第一个客户端发起申请锁，判断是否为第一个临时顺序节点，如果是，则加锁成功。<br>其他客户端按顺序创建后续的节点，判断是否为第一个节点，如果不是，加锁失败。同时对上一个节点进行监听，如果上一个节点被删除（释放锁），则会反向通知该客户端来获取锁。这里不能都监听第一个节点等待释放锁，因为如果都监听第一个节点，该节点一旦释放锁，则会全部通知监听该节点的客户端，引起不必要大量的网络开销，也就是羊群效应<br>基于zk通过创建临时顺序节点监听机制，可以反向通知客户端重新获取锁，是目前非常规范分布式锁解决方案，实时性也非常好。<br>但是zk加锁也会有一个问题，那就是假如说客户端1加锁成功后，由于网络原因，暂时无法收到心跳，则zk会判断改客户端已经死亡，会主动释放改顺序节点，并通知下一个客户端来获取锁，也就会造成有两个客户端同时拿到锁。这就类似于因为网络原因，造成有两个master的脑裂是同样的问题。</p>
<p>综上：分布式锁，使用zk会更专业，但是如果需要高并发处理，则redis会更合适。</p>
<h4 id="如何实现Redis的高可用"><a href="#如何实现Redis的高可用" class="headerlink" title="如何实现Redis的高可用"></a>如何实现Redis的高可用</h4><h5 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h5><p>sentinel，哨兵是redis集群中非常重要的一个组件，主要有以下功能：</p>
<ul>
<li>集群监控：负责监控redis master和slave进程是否在正常工作。</li>
<li>消息通知：如果某个redis实例有故障，那么哨兵负责发送消息作为报警通知给管理员。</li>
<li>故障转移：如果master node宕机了，会自动转移到slave node上。</li>
<li>配置中心：如果发生了故障转移，通知client客户端新的master地址。</li>
</ul>
<p>哨兵用于实现redis集群的高可用，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作。</p>
<ul>
<li>故障转移时，判断一个master node是否宕机，需要大部分的哨兵统一才行，这里涉及到了raft协议分布式一致性实现的分布式选举。</li>
<li>即使部分哨兵节点挂了，哨兵集群还是能正常工作。</li>
<li>哨兵通常需要3个以上的实例，来保证集群的健壮性。</li>
<li>哨兵+redis主从的部署架构，是不保证数据零丢失的，只能保证 redis集群的高可用性。</li>
</ul>
<h5 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h5><p>Redis cluster是一种服务端的sharding技术，3.0版本开始正式提供。采用slot（槽）的概念，一共划分为16384个槽，将请求发送到任意节点，接收到请求的节点将查询请求发送到的正确的节点上。</p>
<p>方案说明：</p>
<ul>
<li>通过哈希的方式，将数据分片，每个节点均分存储一定哈希槽，默认分配了16384个槽位。</li>
<li>每份数据分片会存储在多个互为主从的多节点上。</li>
<li>数据先写入主节点，再同步到从节点(支持配置为阻塞同步模式)。</li>
<li>同一分片多个节点间的数据不保持强一致性。</li>
<li>读取数据时，当客户端操作的key没有分配在该节点上时，redis会返回转向指令，指向正确的节点。</li>
<li>扩容时，需要把旧节点的数据迁移一部分到新节点。</li>
</ul>
<p>在集群模式下，每个redis要开放两个端口号（不固定，可自定义），一个是6379，另一个是16379。</p>
<p>16379端口号是用来进行节点通信的，也就是cluster bus的通信，用来进行故障检测、配置更新、故障转移授权。cluster bus用了另外一种二进制协议，gossip协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间。</p>
<p><strong>优点</strong></p>
<ul>
<li>无中心架构，支持动态扩容，对业务透明。</li>
<li>具备Sentinel的监控和自动Failover（故障转移）的能力。</li>
<li>客户端不需要连接集群所有节点，连接集群中任意一个可用节点即可。</li>
<li>高性能，客户端直连redis服务，免去了proxy代理的损耗。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>运维也很复杂，数据迁移需要人工干预</li>
<li>只能使用0号数据库</li>
<li>不支持批量操作(pipeline管道操作)</li>
<li>分布式逻辑和存储模块耦合</li>
</ul>
<h4 id="如何处理Redis中的热key、big-key"><a href="#如何处理Redis中的热key、big-key" class="headerlink" title="如何处理Redis中的热key、big key"></a>如何处理Redis中的热key、big key</h4><h5 id="BigKey"><a href="#BigKey" class="headerlink" title="BigKey"></a>BigKey</h5><p>BigKey指的是redis中一些key value值很大，这些Key在序列化和反序列化过程中花费的时间很长，操作bigkey通常比较好使，意味着阻塞Redis可能性大，占用的流量也会变得很大。</p>
<p><strong>如何查看redis中的bigkey</strong>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 6379 --bigkeys</span><br><span class="line">/*</span><br><span class="line">该命令使用scan方式对Key进行统计，无序担心对redis造成阻塞</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p><img src="20201025121220395.png" alt="bigkeys"></p>
<ul>
<li>summary给出了每种数据结构中的最大的key</li>
<li>统计中只有string类型的size单位是字节长度</li>
<li>list,set,zset是以元素个数作为衡量标准，根据阿里标准，这些集合最大不要超过5000</li>
</ul>
<p><strong>如何优化：</strong></p>
<p>优化的原则，如果是string类型减少字符串长度，list、hash、set、zset等减少成员数。</p>
<p>string长度大于10k，list长度大于10240认为是big key</p>
<h5 id="热key"><a href="#热key" class="headerlink" title="热key"></a>热key</h5><p>热key指的是一段时间内访问频次比较高额的键值，大量的访问可能会把网卡带宽打满，也有可能导致redis宕机。</p>
<p><strong>如何发现热key</strong>：</p>
<p>方法一：凭借业务经验，进行预估那些是热key</p>
<p>有一定的可行性，比如说商品在做秒杀，商品的key就可以判断为是热key;缺点很明显，准确性不高。</p>
<p>方法二：在客户端收集</p>
<p>在操作redis之前，加入代码进行数据统计发送到计算系统。缺点会对客户端代码造成入侵。</p>
<p>方法三：在proxy层收集</p>
<p>proxy可以使Twemproxy，在proxy层做收集上报。缺点是redis集群架构可能不做proxy。</p>
<p>方法四：用redis自带命令</p>
<ul>
<li>monitor，该命令可以实时抓取出redis服务器接收到的命令，然后再代码里面统计出热key，也有现成的分析工具比如redis-faina。缺点该命令在高并发环境下，会占用不少内存，降低redis的性能。</li>
<li>redis-li –hotkeys，redis4.0.3提供了redis-cli的热点key发现功能。缺点如果key比较多，执行起来会比较慢。</li>
</ul>
<p>方法五：自己抓包评估</p>
<p>redis客户端使用tcp协议和服务端进行交互，通信协议采用的是RESP(Redis Serialization Protocol)，自己写程序监听端口，按照RESP协议规则解析数据进行分析。缺点是开发成本高，维护困难。</p>
<p><strong>如何解决</strong>：</p>
<ul>
<li>做二级缓存，比如说HashMap，guava，caffeine，在发现了热key之后把数据缓存到JVM内存中，应用做集群架构，可以做好流量支撑，足以应付。</li>
<li>备份热key，就是把key在多个redis上都存一份，有热key请求进来，在备份的redis节点中随机选一个。</li>
</ul>
]]></content>
      <categories>
        <category>面试篇</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ面试题相关</title>
    <url>/2021/04/16/RocketMQ%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>图为自己画的，错误之处请指出，在线图  <a href="https://www.processon.com/view/link/607952ccf346fb647a5702f3?pw=rifu">点我</a> 。该文档持续更新…<span id="more"></span></p>
<p><img src="image-20210416171452462.png" alt="image-20210416171452462"></p>
<h4 id="①如何保证消息可靠性？"><a href="#①如何保证消息可靠性？" class="headerlink" title="①如何保证消息可靠性？"></a>①如何保证消息可靠性？</h4><p>这里可分为三个方面来回答，这里主要考察的是消息传递的可靠性，不会发生消息丢失的情况。RabbitMQ的回答也是如此。</p>
<h5 id="生产者丢失"><a href="#生产者丢失" class="headerlink" title="生产者丢失"></a>生产者丢失</h5><p>消息发送也分为同步发送和异步发送，由于同步发送不会发生丢失的问题，这里主要讲异步发送。</p>
<p>异步发送分为两个方式：异步有回调和异步无回调，无回调的方式，生产者发送完后不管结果可能就会造成消息丢失，而通过异步发送+回调通知+本地消息表的形式我们就可以做出一个解决方案。以下单的场景举例。</p>
<p>1.下单后先保存本地数据和MQ消息表，这时候消息的状态是发送中，如果本地事务失败，那么下单失败，事务回滚。</p>
<p>2.下单成功，直接返回客户端成功，异步发送MQ消息</p>
<p>3.MQ回调通知消息发送结果，对应更新数据库MQ发送状态</p>
<p>4.JOB轮询超过一定时间（时间根据业务配置）还未发送成功的消息去重试</p>
<p>5.在监控平台配置或者JOB程序处理超过一定次数一直发送不成功的消息，告警，人工介入。</p>
<h5 id="MQ丢失"><a href="#MQ丢失" class="headerlink" title="MQ丢失"></a>MQ丢失</h5><p>就是Master收到了消息，此时数据还在内存中，但是还没同步消息到Slave时候发生了宕机，导致的数据不同步。</p>
<p>RocketMQ分为同步刷盘和异步刷盘两种方式，默认的是异步刷盘，就有可能导致消息还未刷到硬盘上就丢失了，可以通过设置为同步刷盘的方式来保证消息可靠性，这样即使MQ挂了，恢复的时候也可以从磁盘中去恢复消息，这个需要考察业务需要。</p>
<h5 id="消费者丢失"><a href="#消费者丢失" class="headerlink" title="消费者丢失"></a>消费者丢失</h5><p>消费者刚收到消息，但是还没消费发生宕机，MQ认为该消息已经消费不会重发。消费端需要设置消息回调，就是消费成功需要回传ack给MQ，让其更新消息的消费状态，在RocketMQ里面，消费者会更新offset给MQ，告知当前的消费位置。</p>
<h4 id="②RocketMQ是如何保证高可靠和高可用的？"><a href="#②RocketMQ是如何保证高可靠和高可用的？" class="headerlink" title="②RocketMQ是如何保证高可靠和高可用的？"></a>②RocketMQ是如何保证高可靠和高可用的？</h4><p>我们知道 RocketMQ 是一款高性能、高可靠的分布式消息中间件，高性能和高可靠是很难兼得的。因为要保证高可靠，那么数据就必须持久化到磁盘上，将数据持久化到磁盘，那么可能就不能保证高性能了。</p>
<p>RocketMQ 在兼容这两方面做的不错，先从磁盘说起，<strong>「现代的磁盘都是高性能的，写速度并不一定比网络的数据传输速度慢」</strong>。比如 SSD 固态硬盘在 M.2 NVMe协议下，顺序写的速度可以达到 1500 MB/s，就算是普通磁盘，如果性能比较高的话，顺序写的速度可以达到 450MB/s~600MB/s。</p>
<p>在顺序写的情况下是这速度，但是不人为控制的话，磁盘采用的是随机写，在随机写的情况下，磁盘的写入速度急速下降，<strong>「磁盘的随机写速度可能只有几百KB/s，这远远要慢于网络传输速度，所以它并不能满足高性能的要求」</strong>。</p>
<p>RocketMQ 在持久化的设计上，采取的是<strong>「消息顺序写、随机读的策略」</strong>，利用磁盘顺序写的速度，让磁盘的写速度不会成为系统的瓶颈。并且采用 MMPP 这种“零拷贝”技术，提高消息存盘和网络发送的速度。极力满足 RocketMQ 的高性能、高可靠要求。</p>
<h4 id="③Broker是如何保存数据的呢？"><a href="#③Broker是如何保存数据的呢？" class="headerlink" title="③Broker是如何保存数据的呢？"></a>③Broker是如何保存数据的呢？</h4><p>RocketMQ主要的存储文件包括commitlog文件、consumequeue文件、indexfile文件。</p>
<p><img src="image-20210417105606013.png" alt="image-20210417105606013"></p>
<p>Broker在收到消息之后，会把消息保存到commitlog的文件当中，而同时在分布式的存储当中，每个broker都会保存一部分topic的数据，同时，每个topic对应的messagequeue下都会生成consumequeue文件用于保存commitlog的物理位置偏移量offset，indexfile中会保存key和offset的对应关系。</p>
<p><img src="890b041845970ff38244f677e51eb441.png" alt="890b041845970ff38244f677e51eb441"></p>
<p>CommitLog文件保存于${Rocket_Home}/store/commitlog目录中，从图中我们可以明显看出来文件名的偏移量，每个文件默认1G，写满后自动生成一个新的文件。</p>
<p><img src="7c8eb3d9a6024e90346a88d7618757fd.png" alt="7c8eb3d9a6024e90346a88d7618757fd"></p>
<p>由于同一个topic的消息并不是连续的存储在commitlog中，消费者如果直接从commitlog获取消息效率非常低，所以通过consumequeue保存commitlog中消息的偏移量的物理地址，这样消费者在消费的时候先从consumequeue中根据偏移量定位到具体的commitlog物理文件，然后根据一定的规则（offset和文件大小取模）在commitlog中快速定位。<br><img src="5daa5e005b9ae74b51ea67756a97f9fc.png" alt="图片"></p>
<h4 id="④数据刷盘的方式"><a href="#④数据刷盘的方式" class="headerlink" title="④数据刷盘的方式"></a>④数据刷盘的方式</h4><p>因为操作系统 PAGECACHE 的存在，PageCache是OS对文件的缓存，用于加速对文件的读写，所以一般都是先写入到 PAGECACHE 中，然后再持久化到磁盘上。我们熟悉的其他组件，MySQL、Redis 等都是如此。RocketMQ 也不列外。</p>
<p>在 RocketMQ 中提供了<strong>「同步刷盘」</strong>和<strong>「异步刷盘」</strong>两种刷盘方式，可以通过 Broker 配置文中中的 flushDiskType 参数来设置（SYNC_FLUSH、ASYNC_FLUSH）。</p>
<p><strong>「异步刷盘方式（默认）」</strong>：消息写入到内存的 PAGECACHE中，就立刻给客户端返回写操作成功，当 PAGECACHE 中的消息积累到一定的量时，触发一次写操作，将 PAGECACHE 中的消息写入到磁盘中。这种方式<strong>「吞吐量大，性能高，但是 PAGECACHE 中的数据可能丢失，不能保证数据绝对的安全」</strong>。</p>
<p><strong>「同步刷盘方式」</strong>：消息写入内存的 PAGECACHE 后，立刻通知刷盘线程刷盘，然后等待刷盘完成，刷盘线程执行完成后唤醒等待的线程，返回消息写成功的状态。这种方式<strong>「可以保证数据绝对安全，但是吞吐量不大」</strong>。</p>
<h4 id="⑤消息堆积如何解决？"><a href="#⑤消息堆积如何解决？" class="headerlink" title="⑤消息堆积如何解决？"></a>⑤消息堆积如何解决？</h4><ul>
<li>生产者端：生产消息的速度过快，限制生产消息的频率。</li>
<li>消费者端：消息太多，消费不过来，可以考虑扩容来提高消费效率。</li>
<li>Broker:内存是否足够大？如果Page Cache够大的话，可以考虑提高Consumer拉取消息的频率。</li>
</ul>
<h4 id="⑥RocketMQ-为什么会重复消费？讲下-RocketMQ-造成重复消费的底层实现原理？"><a href="#⑥RocketMQ-为什么会重复消费？讲下-RocketMQ-造成重复消费的底层实现原理？" class="headerlink" title="⑥RocketMQ 为什么会重复消费？讲下 RocketMQ 造成重复消费的底层实现原理？"></a>⑥RocketMQ 为什么会重复消费？讲下 RocketMQ 造成重复消费的底层实现原理？</h4><h4 id="⑦如何保证消息消费的顺序性？"><a href="#⑦如何保证消息消费的顺序性？" class="headerlink" title="⑦如何保证消息消费的顺序性？"></a>⑦如何保证消息消费的顺序性？</h4><p>首先多个queue只能保证一个queue消费的顺序性，而且是队列结构，天然的顺序性FIFO，我们可以在发送消息的时候把需要顺序消费的消息发送到一个queue，在消费端也只开一个消费者。</p>
<p>如何保证消息都发送到同一个queue，在使用producer发送消息的时候重写MessageQueueSelector接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;orderTopic&quot;</span>, (<span class="string">&quot;hello!&quot;</span> + i).getBytes());</span><br><span class="line">producer.send(</span><br><span class="line">    <span class="comment">// 要发的那条消息</span></span><br><span class="line">    message,</span><br><span class="line">    <span class="comment">// queue 选择器 ，向 topic中的哪个queue去写消息</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">MessageQueueSelector</span>() &#123;</span><br><span class="line">        <span class="comment">// 手动 选择一个queue</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> MessageQueue <span class="title function_">select</span><span class="params">(</span></span><br><span class="line"><span class="params">            // 当前topic 里面包含的所有queue</span></span><br><span class="line"><span class="params">            List&lt;MessageQueue&gt; mqs,</span></span><br><span class="line"><span class="params">            // 具体要发的那条消息</span></span><br><span class="line"><span class="params">            Message msg,</span></span><br><span class="line"><span class="params">            // 对应到 send（） 里的 args，也就是<span class="number">2000</span>前面的那个<span class="number">0</span></span></span><br><span class="line"><span class="params">            Object arg)</span> &#123;</span><br><span class="line">            <span class="comment">// 向固定的一个queue里写消息，比如这里就是向第一个queue里写消息</span></span><br><span class="line">            <span class="keyword">if</span> (Integer.parseInt(arg.toString()) % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> mqs.get(<span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mqs.get(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 自定义参数：0</span></span><br><span class="line">    <span class="comment">// 2000代表2000毫秒超时时间</span></span><br><span class="line">    <span class="number">0</span>, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>面试篇</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot 发送邮件</title>
    <url>/2018/10/18/SpringBoot-%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/</url>
    <content><![CDATA[<h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><p>1.添加依赖包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>2.配置信息</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.mail.username</span>=<span class="string">528428122@qq.com</span></span><br><span class="line"><span class="attr">spring.mail.password</span>=<span class="string">***</span></span><br><span class="line"><span class="attr">spring.mail.host</span>=<span class="string">smtp.qq.com</span></span><br><span class="line"><span class="attr">spring.mail.properties.mail.smtp.ssl.enable</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<p>== 其中密码=授权码去自己的个人邮箱设置里面找 ==</p>
<p>3.发送</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">   JavaMailSenderImpl mailSender;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMail</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">SimpleMailMessage</span> <span class="variable">mail</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleMailMessage</span>();</span><br><span class="line">       mail.setSubject(<span class="string">&quot;通知&quot;</span>);</span><br><span class="line">       mail.setText(<span class="string">&quot;今晚加班哦&quot;</span>);</span><br><span class="line"></span><br><span class="line">       mail.setTo(<span class="string">&quot;13071679487@163.com&quot;</span>);</span><br><span class="line">       mail.setFrom(<span class="string">&quot;528428122@qq.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">       mailSender.send(mail);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMailWithHTMLAndFile</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="type">MimeMessage</span> <span class="variable">mail</span> <span class="operator">=</span> mailSender.createMimeMessage();</span><br><span class="line"></span><br><span class="line">       <span class="type">MimeMessageHelper</span> <span class="variable">helper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeMessageHelper</span>(mail, <span class="literal">true</span>);</span><br><span class="line">       helper.setSubject(<span class="string">&quot;通知，这个是可以发送html和文件的&quot;</span>);</span><br><span class="line"></span><br><span class="line">       helper.setText(<span class="string">&quot;&lt;b style=&#x27;color:blue&#x27;&gt; 带颜色的文本 &lt;/b&gt;&quot;</span>,<span class="literal">true</span>);   <span class="comment">//第二个参数为true,支持html</span></span><br><span class="line">       helper.addAttachment(<span class="string">&quot;test.png&quot;</span>,<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Users\\Lifu\\Desktop\\照片\\zava.png&quot;</span>));</span><br><span class="line">       helper.addAttachment(<span class="string">&quot;test.png&quot;</span>,<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Users\\Lifu\\Desktop\\照片\\rifu.png&quot;</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       helper.setTo(<span class="string">&quot;13071679487@163.com&quot;</span>);</span><br><span class="line">       helper.setFrom(<span class="string">&quot;528428122@qq.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">       mailSender.send(mail);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>邮件</tag>
      </tags>
  </entry>
  <entry>
    <title>快速使用SpringBoot 和Redis</title>
    <url>/2019/05/06/SpringBoot%E6%90%AD%E9%85%8DRedis%20%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h5 id="一、步骤"><a href="#一、步骤" class="headerlink" title="一、步骤"></a>一、步骤</h5><p>1.开启基于注解的缓存</p>
<p>在Application上标注@EnableCaching</p>
<p>2.在对应的serviceimpl方法上开启</p>
<p>@Cacheable</p>
<p>3.在配置文件里面配置Redis服务器的地址（默认端口为6379）</p>
<p>4.在自定义的CustomRedisConfiguration类里面</p>
<p>添加RedisCacheManager的bean</p>
<span id="more"></span>

<h5 id="二、命令注解"><a href="#二、命令注解" class="headerlink" title="二、命令注解"></a>二、命令注解</h5><h6 id="Cacheable"><a href="#Cacheable" class="headerlink" title="@Cacheable"></a>@Cacheable</h6><h6 id="CachePut"><a href="#CachePut" class="headerlink" title="@CachePut"></a>@CachePut</h6><h6 id="CacheEvict"><a href="#CacheEvict" class="headerlink" title="@CacheEvict"></a>@CacheEvict</h6><p>key:指定要清除的key</p>
<p>allEntries = true :指定清除这个缓存中的所有数据</p>
<p>beforeInvocation = false :</p>
<p>缓存的清除是否在方法之前执行，默认代表缓存清除操作是在方法执行之后执行，出现异常则不会清除缓存</p>
<h6 id="Caching"><a href="#Caching" class="headerlink" title="@Caching"></a>@Caching</h6><p>组建复杂的缓存方式</p>
<blockquote>
<p>@Caching(</p>
<pre><code>cacheable = &#123;
   
    @Cacheable(value=&quot;user&quot;,key=&quot;#id&quot;)
   
&#125;,
   
put = &#123;
   
    @CachePut(value=&quot;user&quot;,key=&quot;#result.lastName&quot;),
   
    @CachePut(value=&quot;user&quot;,key=&quot;#result.dId&quot;)
   
&#125;
</code></pre>
<p>)</p>
</blockquote>
<h6 id="CacheConfig"><a href="#CacheConfig" class="headerlink" title="@CacheConfig"></a>@CacheConfig</h6><p>作用：抽取一部分公共的配置属性</p>
<blockquote>
<p>@CacheConfig(cacheNames=”user”)</p>
</blockquote>
<h5 id="三、自定义KeyGenerator"><a href="#三、自定义KeyGenerator" class="headerlink" title="三、自定义KeyGenerator"></a>三、自定义KeyGenerator</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> KeyGenerator <span class="title function_">customKeyGenerator</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">KeyGenerator</span>()&#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">generate</span><span class="params">(Object o, Method method, Object... objects)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> method.getName()+<span class="string">&quot;[&quot;</span>+Arrays.asList(objects).toString()+<span class="string">&quot;]&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h5 id="四、自定义序列化器RedisTemplate"><a href="#四、自定义序列化器RedisTemplate" class="headerlink" title="四、自定义序列化器RedisTemplate"></a>四、自定义序列化器RedisTemplate</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> RedisTemplate <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span>&#123;</span><br><span class="line">       Jackson2JsonRedisSerializer&lt;Object&gt; serializer = <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>&lt;Object&gt;(Object.class);</span><br><span class="line">       <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">       objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, <span class="literal">false</span>);					<span class="comment">//这行代码可以使得生成的json没有[]</span></span><br><span class="line">       objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">       objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">       serializer.setObjectMapper(objectMapper);</span><br><span class="line"></span><br><span class="line">       RedisTemplate&lt;String, Object&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">       redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">       redisTemplate.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">       redisTemplate.setValueSerializer(serializer);</span><br><span class="line">       redisTemplate.setHashKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">       redisTemplate.setHashValueSerializer(serializer);</span><br><span class="line">       redisTemplate.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> redisTemplate;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="五、自定义CacheManager"><a href="#五、自定义CacheManager" class="headerlink" title="五、自定义CacheManager"></a>五、自定义CacheManager</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> RedisCacheManager <span class="title function_">cacheManager</span><span class="params">(RedisTemplate redisTemplate)</span>&#123;</span><br><span class="line">       <span class="type">RedisCacheWriter</span> <span class="variable">redisCacheWriter</span> <span class="operator">=</span> RedisCacheWriter.nonLockingRedisCacheWriter(redisTemplate.getConnectionFactory());</span><br><span class="line">       <span class="type">RedisCacheConfiguration</span> <span class="variable">redisCacheConfiguration</span> <span class="operator">=</span> RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">               .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(redisTemplate.getValueSerializer()));</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RedisCacheManager</span>(redisCacheWriter, redisCacheConfiguration);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>学习工具</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>SpringBoot</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot 设置允许跨域访问</title>
    <url>/2018/10/31/SpringBoot-%E8%AE%BE%E7%BD%AE%E5%85%81%E8%AE%B8%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<p>在SpringBoot项目中设置允许跨域访问</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Rifu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2018/10/31  13:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CorsConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CorsConfiguration <span class="title function_">buildConfig</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">CorsConfiguration</span> <span class="variable">corsConfiguration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorsConfiguration</span>();</span><br><span class="line">        corsConfiguration.addAllowedOrigin(<span class="string">&quot;*&quot;</span>); <span class="comment">// 允许任何域名使用</span></span><br><span class="line">        corsConfiguration.addAllowedHeader(<span class="string">&quot;*&quot;</span>); <span class="comment">// 允许任何头</span></span><br><span class="line">        corsConfiguration.addAllowedMethod(<span class="string">&quot;*&quot;</span>); <span class="comment">// 允许任何方法（post、get等）</span></span><br><span class="line">        <span class="keyword">return</span> corsConfiguration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CorsFilter <span class="title function_">corsFilter</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">UrlBasedCorsConfigurationSource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlBasedCorsConfigurationSource</span>();</span><br><span class="line">        source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>,buildConfig());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CorsFilter</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>跨域访问</tag>
      </tags>
  </entry>
  <entry>
    <title>Springboot集成Mybatis下PageHelper不起作用</title>
    <url>/2018/10/25/Springboot%E9%9B%86%E6%88%90Mybatis%E4%B8%8BPageHelper%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<p>最近在项目中使用SpringBoot集成Mybatis，但是Pagehelper不去分页效果的作用</p>
<p>在依赖文件中，去掉原本的pagehelper，改用集成的pagehelper：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper-spring-boot-starter --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>问题解决本</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Mybatis</tag>
        <tag>PageHelper</tag>
        <tag>分页</tag>
      </tags>
  </entry>
  <entry>
    <title>volatile如何保证内存的可见性</title>
    <url>/2019/04/13/volatile%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%86%85%E5%AD%98%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7/</url>
    <content><![CDATA[<h3 id="（一）内存可见性"><a href="#（一）内存可见性" class="headerlink" title="（一）内存可见性"></a>（一）内存可见性</h3><ul>
<li>JVM内存模型：主内存和线程独立的工作内存<ul>
<li>Java内存模型规定，对于多个线程共享的变量，存储在主内存当中，每个线程都有自己独立的工作内存（比如CPU的寄存器），线程只能访问自己的工作内存，不可以访问其他线程的工作内存。</li>
<li>工作内存中保存了主内存共享变量的副本，线程要操作这些共享变量，只能通过操作工作内存中的副本来实现，操作完毕之后再同步回到主内存当中。<span id="more"></span></li>
<li>如何保证多个线程操作主内存的数据完整性是一个难题，Java内存模型也规定了工作内存与主内存之间交互的协议，定义了8种原子操作：<ol>
<li>lock：将主内存的变量锁定，为一个线程所独占。</li>
<li>unlock：将lock加的锁定解除，此时其他线程可以有机会访问此变量。</li>
<li>read：将主内存中的变量值读到工作线程中。</li>
<li>load：将read读取到的值保存到工作内存中的变量副本中。</li>
<li>use：将值传递给线程的代码执行引擎。</li>
<li>assign：将执行引擎处理返回的值重新赋值给变量副本。</li>
<li>store：将变量副本的值存储到主内存中。</li>
<li>write：将store存储的值写入到主内存的共享变量中。</li>
</ol>
</li>
<li>通过上面Java内存模型的概述，我们会注意到这么一个问题，每个线程在获取锁之后会在自己的工作内存来操作共享变量，操作完成之后将工作内存中的副本回写到主内存，并且在其它线程从主内存将变量同步回自己的工作内存之前，共享变量的改变对其是不可见的。即其他线程的本地内存中的变量已经是过时的，并不是更新后的值。</li>
</ul>
</li>
<li>例子1：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">有一个全局的状态变量open:</span><br><span class="line">boolean open=true;</span><br><span class="line">这个变量用来描述对一个资源的打开关闭状态，true表示打开，false表示关闭，假设有一个线程A,在执行一些操作后将open修改为false:</span><br><span class="line">//线程A</span><br><span class="line">resource.close();</span><br><span class="line">open = false;</span><br><span class="line">线程B随时关注open的状态，当open为true的时候通过访问资源来进行一些操作:</span><br><span class="line">//线程B</span><br><span class="line">while(open) &#123;</span><br><span class="line">doSomethingWithResource(resource);</span><br><span class="line">&#125;</span><br><span class="line">当A把资源关闭的时候，open变量对线程B是不可见的，如果此时open变量的改动尚未同步到线程B的工作内存中,那么线程B就会用一个已经关闭了的资源去做一些操作，因此产生错误。</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<ul>
<li>例子2：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">下面是一个通过布尔标志判断线程是否结束的例子：</span><br><span class="line">public class CancelThreadTest &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        PrimeGeneratorgen = new PrimeGenerator();</span><br><span class="line">        newThread(gen).start();</span><br><span class="line">        try&#123;</span><br><span class="line">            Thread.sleep(3000);</span><br><span class="line">        &#125;finally&#123;</span><br><span class="line">            gen.cancel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class PrimeGenerator implements Runnable&#123;</span><br><span class="line">    private boolean cancelled;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while(!cancelled)&#123;</span><br><span class="line">            System.out.println(&quot;Running...&quot;);</span><br><span class="line">            //doingsomething here...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void cancel()&#123;cancelled = true;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">主线程中设置PrimeGenerator线程的是否取消标识，PrimeGenerator线程检测到这个标识后就会结束线程，由于主线程修改cancelled变量的内存可见性，主线程修改cancelled标识后并不马上同步回主内存，所以PrimeGenerator线程结束的时间难以把控（最终是一定会同步回主内存，让PrimeGenerator线程结束）。</span><br><span class="line"></span><br><span class="line">如果PrimeGenerator线程执行一些比较关键的操作，主线程希望能够及时终止它，这时将cenceled用volatile关键字修饰就是必要的。</span><br><span class="line"></span><br><span class="line">特别注意：上面演示这个并不是正确的取消线程的方法，因为一旦PrimeGenerator线程中包含BolckingQueue.put()等阻塞方法，那么将可能永远不会去检查cancelled标识，导致线程永远不会退出。</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<ul>
<li>提供内存可见性<ul>
<li>volatile是通过内存屏障和禁止指令重排序来保证内存可见性的，一个线程对volatile变量的修改，能够立刻被其他线程所见。可以解决例子1和例子2的问题。</li>
</ul>
</li>
</ul>
<h3 id="（二）防止指令重排"><a href="#（二）防止指令重排" class="headerlink" title="（二）防止指令重排"></a>（二）防止指令重排</h3><ul>
<li>如果一个操作不是原子的，就会给JVM留下重排的机会。</li>
<li>例子1：A线程指令重排导致B线程出错</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于在同一个线程内，这样的改变是不会对逻辑产生影响的，但是在多线程的情况下指令重排序会带来问题。看下面这个情景:</span><br><span class="line"></span><br><span class="line">在线程A中:</span><br><span class="line">context = loadContext();</span><br><span class="line">inited = true;</span><br><span class="line">在线程B中:</span><br><span class="line">while(!inited )&#123; //根据线程A中对inited变量的修改决定是否使用context变量</span><br><span class="line">sleep(100);</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br><span class="line"></span><br><span class="line">假设线程A中发生了指令重排序:</span><br><span class="line">inited = true;</span><br><span class="line">context = loadContext();</span><br><span class="line">那么B中很可能就会拿到一个尚未初始化或尚未初始化完成的context,从而引发程序错误。</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<ul>
<li>例子2：指令重排导致单例模式失效</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我们都知道一个经典的懒加载方式的双重判断单例模式：</span><br><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton instance = null;</span><br><span class="line">    private Singleton() &#123; &#125;</span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if(instance == null) &#123;</span><br><span class="line">            synchronzied(Singleton.class) &#123;</span><br><span class="line">                if(instance == null) &#123;</span><br><span class="line">                    instance = new Singleton(); //非原子操作</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">看似简单的一段赋值语句：instance= new Singleton()，但是很不幸它并不是一个原子操作，其实际上可以抽象为下面几条JVM指令：</span><br><span class="line">memory =allocate(); //1：分配对象的内存空间</span><br><span class="line">ctorInstance(memory); //2：初始化对象</span><br><span class="line">instance =memory; //3：设置instance指向刚分配的内存地址</span><br><span class="line"></span><br><span class="line">上面操作2依赖于操作1，但是操作3并不依赖于操作2，所以JVM是可以针对它们进行指令的优化重排序的，经过重排序后如下：</span><br><span class="line">memory =allocate(); //1：分配对象的内存空间</span><br><span class="line">instance =memory; //3：instance指向刚分配的内存地址，此时对象还未初始化</span><br><span class="line">ctorInstance(memory); //2：初始化对象</span><br><span class="line"></span><br><span class="line">可以看到指令重排之后，instance指向分配好的内存放在了前面，而这段内存的初始化被排在了后面。</span><br><span class="line"></span><br><span class="line">在线程A执行这段赋值语句，在初始化分配对象之前就已经将其赋值给instance引用，恰好另一个线程进入方法判断instance引用不为null，然后就将其返回使用，导致出错。</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<ul>
<li>防止指令重排<ul>
<li>除了前面内存可见性中讲到的volatile关键字可以保证变量修改的可见性之外，还有另一个重要的作用：在JDK1.5之后，可以使用volatile变量禁止指令重排序。</li>
<li>例子1中的inited和例子2中的instance以关键字volatile修饰之后，就会阻止JVM对其相关代码进行指令重排，这样就能够按照既定的顺序指执行。</li>
<li>volatile关键字通过提供“内存屏障”的方式来防止指令被重排序，为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</li>
<li>大多数的处理器都支持内存屏障的指令。</li>
<li>对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能，为此，Java内存模型采取保守策略。下面是基于保守策略的JMM内存屏障插入策略：<ol>
<li>在每个volatile写操作的前面插入一个StoreStore屏障。</li>
<li>在每个volatile写操作的后面插入一个StoreLoad屏障。</li>
<li>在每个volatile读操作的后面插入一个LoadLoad屏障。</li>
<li>在每个volatile读操作的后面插入一个LoadStore屏障。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="（三）总结"><a href="#（三）总结" class="headerlink" title="（三）总结"></a>（三）总结</h3><ul>
<li>volatile是轻量级同步机制：<ul>
<li>相对于synchronized块的代码锁，volatile应该是提供了一个轻量级的针对共享变量的锁，当我们在多个线程间使用共享变量进行通信的时候需要考虑将共享变量用volatile来修饰。</li>
<li>volatile是一种稍弱的同步机制，在访问volatile变量时不会执行加锁操作，也就不会执行线程阻塞，因此volatilei变量是一种比synchronized关键字更轻量级的同步机制。</li>
</ul>
</li>
<li>volatile使用建议：<ul>
<li>在两个或者更多的线程需要访问的成员变量上使用volatile。当要访问的变量已在synchronized代码块中，或者为常量时，没必要使用volatile。</li>
<li>由于使用volatile屏蔽掉了JVM中必要的代码优化，所以在效率上比较低，因此一定在必要时才使用此关键字。</li>
</ul>
</li>
</ul>
<h3 id="（四）volatile和synchronized的区别"><a href="#（四）volatile和synchronized的区别" class="headerlink" title="（四）volatile和synchronized的区别"></a>（四）volatile和synchronized的区别</h3><ul>
<li>区别：<ol>
<li>volatile不会进行加锁操作：volatile变量是一种稍弱的同步机制在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比synchronized关键字更轻量级的同步机制。</li>
<li>volatile变量作用类似于同步变量读写操作：从内存可见性的角度看，写入volatile变量相当于退出同步代码块，而读取volatile变量相当于进入同步代码块。</li>
<li>volatile不如synchronized安全：在代码中如果过度依赖volatile变量来控制状态的可见性，通常会比使用锁的代码更脆弱，也更难以理解。仅当volatile变量能简化代码的实现以及对同步策略的验证时，才应该使用它。一般来说，用同步机制会更安全些。</li>
<li>volatile无法同时保证内存可见性和原则性：加锁机制（即同步机制）既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性，原因是声明为volatile的简单变量如果当前值与该变量以前的值相关，那么volatile关键字不起作用，也就是说如下的表达式都不是原子操作：“count++”、“count = count+1”。</li>
</ol>
</li>
<li>当且仅当满足以下所有条件时，才应该使用volatile变量：<ol>
<li>对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。</li>
<li>该变量没有包含在具有其他变量的不变式中。</li>
</ol>
</li>
<li>总结：在需要同步的时候，第一选择应该是synchronized关键字，这是最安全的方式，尝试其他任何方式都是有风险的。尤其在jdK1.6及之后，对synchronized同步机制做了很多优化，如：自适应的自旋锁、锁粗化、锁消除、轻量级锁等，使得它的性能明显有了很大的提升。</li>
</ul>
]]></content>
      <categories>
        <category>面试篇</category>
      </categories>
      <tags>
        <tag>高并发</tag>
        <tag>volatile</tag>
      </tags>
  </entry>
  <entry>
    <title>使用SpringBoot的定时任务</title>
    <url>/2018/10/18/%E4%BD%BF%E7%94%A8SpringBoot%E7%9A%84%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><p>1.在主类上添加标注</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableAsync</span>        <span class="comment">//开启异步注解功能</span></span><br><span class="line"><span class="meta">@EnableScheduling</span>     <span class="comment">//开启基于注解的定时任务</span></span><br></pre></td></tr></table></figure>

<p>2.在对应的业务层添加标注@Scheduled</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * second ,minute ,hour ,day of month ,month ,day of week</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Scheduled(cron = &quot;0 * * * * MON-FRI&quot;)</span>  <span class="comment">//周一到周五的每分钟</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>定时任务</tag>
      </tags>
  </entry>
  <entry>
    <title>使用apidoc生成接口文档</title>
    <url>/2018/10/31/%E4%BD%BF%E7%94%A8apidoc%E7%94%9F%E6%88%90rest%E7%9A%84api%E6%8E%A5%E5%8F%A3%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>现在大家普遍使用的是swagger结合springmvc来生成api接口文档，对比apidoc，swagger有一个明显的劣势，便是返回的响应，无法生成文档描述，即无法描述响应体的数据结构，这对前后端对接，或者是与移动端/其他端对接来说，需要耗费更多的交流成本，沟通成本，即不可能每个接口都通过实际调用后，看返回实体获悉响应参数。</p>
<span id="more"></span>

<h3 id="二、环境准备"><a href="#二、环境准备" class="headerlink" title="二、环境准备"></a>二、环境准备</h3><p>1.安装node.js，官网：<a href="https://nodejs.org/en/%E7%82%B9%E5%87%BB%E6%89%93%E5%BC%80%E9%93%BE%E6%8E%A5%EF%BC%9Bwindows64%E4%BD%8D%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80https://nodejs.org/dist/v8.9.4/node-v8.9.4-x64.msi%E4%B8%8B%E8%BD%BD%EF%BC%9B">https://nodejs.org/en/点击打开链接；windows64位下载地址https://nodejs.org/dist/v8.9.4/node-v8.9.4-x64.msi下载；</a></p>
<p>2.安装apidoc，命令行下，输入npm install apidoc -g，参考官网：<a href="http://apidocjs.com/#install">http://apidocjs.com/#install</a> 点击打开链接</p>
<p>npm install apidoc -g<br>安装完毕，可在命令下使用apidoc -h测试是否安装成功<br>apidoc -h<br>3.apidoc指令能成功识别，apidoc环境便已经安装好了，这时可在项目中使用，所有的代码基于注释即可。</p>
<h3 id="三、整合项目使用"><a href="#三、整合项目使用" class="headerlink" title="三、整合项目使用"></a>三、整合项目使用</h3><h5 id="1-项目根路径下建立apidoc-json文件，配置好基本的文档信息。"><a href="#1-项目根路径下建立apidoc-json文件，配置好基本的文档信息。" class="headerlink" title="1.项目根路径下建立apidoc.json文件，配置好基本的文档信息。"></a>1.项目根路径下建立apidoc.json文件，配置好基本的文档信息。</h5><p>{<br>  “name”: “API文档”,<br>  “version”: “1.0.0”,<br>  “description”: “开发技术接口文档”,<br>  “title”: “API文档”,<br>  “url” : “<a href="http://localhost:8080/test&quot;">http://localhost:8080/test&quot;</a>,<br>  “sampleUrl”:”<a href="http://localhost:8080/test&quot;">http://localhost:8080/test&quot;</a><br>}</p>
<hr>
<h5 id="2-抽象一些通用的返回信息，自定义一些tag"><a href="#2-抽象一些通用的返回信息，自定义一些tag" class="headerlink" title="2.抽象一些通用的返回信息，自定义一些tag"></a>2.抽象一些通用的返回信息，自定义一些tag</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseApi</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiDefine</span> error_msg 全局配置失败响应信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiError</span> 1001 保存失败</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiError</span> 1002 修改失败</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiError</span> 1003 删除失败</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiError</span> 1004 上传失败</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiError</span> 1005 注册失败</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiError</span> 1101 输入参数格式不正确</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiError</span> 1102 用户名或者密码错误</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiError</span> 1103 用户名不存在</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiError</span> 1201 发送手机注册验证码失败</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiError</span> 1202 用户注册失败</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiError</span> 1203 机构不存在</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiError</span> 1204 注册验证码输入错误</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiError</span> 1205 手机号码已存在</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiError</span> 1206 用户名已存在</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiError</span> 1207 机构不存在</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiError</span> 1208 手机或者用户名已存在</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiError</span> 4101 token过期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiError</span> 4102 token签名错误</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiError</span> 4103 无效token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiError</span> 4104 token格式错误</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiError</span> 5000 接口内部错误</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiErrorExample</span> 错误响应例子:</span></span><br><span class="line"><span class="comment">     *     &#123;</span></span><br><span class="line"><span class="comment">     *       &quot;code&quot;: 1101,</span></span><br><span class="line"><span class="comment">     *       &quot;msg&quot;: &quot;输入参数格式不正确&quot;,</span></span><br><span class="line"><span class="comment">     *       &quot;res&quot;: &quot;&quot;,</span></span><br><span class="line"><span class="comment">     *       &quot;timestamp&quot;: 1489110927975</span></span><br><span class="line"><span class="comment">     *     &#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiDefine</span> success_msg 全局配置成功响应信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiSuccess</span> (success 2000) &#123;Date&#125;  timestamp     时间戳</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiSuccess</span> (success 2000) &#123;Integer&#125; code        响应码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiSuccess</span> (success 2000) &#123;String&#125;  msg       响应信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiSuccess</span> (success 2000) &#123;Object&#125;  res   响应实体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiDefine</span> token_msg 全局配置token鉴权请求头</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiError</span> 4101 token过期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiError</span> 4102 token签名错误</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiError</span> 4103 无效token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiError</span> 4104 token格式错误</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiHeader</span> &#123;String&#125;  Authorization 鉴权信息：为Bearer + &quot;空格&quot; +  &#123;token&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiHeaderExample</span> &#123;json&#125; 请求头例子:</span></span><br><span class="line"><span class="comment">     *     &#123;</span></span><br><span class="line"><span class="comment">     *       &quot;Authorization&quot;: &quot;Bearer eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiIxNDg5NjAiLCJpYXQiOjE0OTUxNjYyMzgsImV4cCI6MTQ5Nzc1ODIzOH0.Mv8BfTIGxGZ6AGkYqHFTRhp40x5xHV6k7Hpwo6OdgiA&quot;</span></span><br><span class="line"><span class="comment">     *     &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line">抽象一些返回的错误代码</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">AttendRestEnum</span> <span class="keyword">implements</span> <span class="title class_">RestEnum</span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiDefine</span> ATTEND_EMPTY_ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiError</span> 5001 规则不能为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ATTEND_EMPTY_ID(<span class="number">5001</span>,<span class="string">&quot;规则不能为空&quot;</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiDefine</span> ATTEND_EMPTY_VALUE</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiError</span> 5002 值不能为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ATTEND_EMPTY_VALUE(<span class="number">5002</span>,<span class="string">&quot;值不能为空&quot;</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiDefine</span> ATTEND_ERROR_EQUAL_VALUE</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiError</span> 5003 设置参数的个数不一致</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ATTEND_ERROR_EQUAL_VALUE(<span class="number">5003</span>,<span class="string">&quot;设置参数的个数不一致&quot;</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiDefine</span> ATTEND_EMPTY_LONGITUDE</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiError</span> 5004 经度不能为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ATTEND_EMPTY_LONGITUDE(<span class="number">5004</span>, <span class="string">&quot;经度不能为空&quot;</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiDefine</span> ATTEND_EMPTY_LATITUDE</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiError</span> 5005 纬度不能为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ATTEND_EMPTY_LATITUDE(<span class="number">5005</span>,<span class="string">&quot;纬度不能为空&quot;</span> ),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiDefine</span> ATTEND_EMPTY_DEVICE_SN</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiError</span> 5006 设备不能为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ATTEND_EMPTY_DEVICE_SN(<span class="number">5006</span>,<span class="string">&quot;设备不能为空&quot;</span> ),</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiDefine</span> ATTEND_EMPTY_ORG</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiError</span> 5007 机构不能为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ATTEND_EMPTY_ORG(<span class="number">5007</span>,<span class="string">&quot;机构不能为空&quot;</span>),</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiDefine</span> ATTEND_NOT_FIND_ORG</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiError</span> 5008 机构没有找到</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ATTEND_NOT_FIND_ORG(<span class="number">5008</span>,<span class="string">&quot;机构没有找到&quot;</span>),</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiDefine</span> ATTEND_EMPTY_MINUTES</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiError</span> 5009 使用时长不能为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ATTEND_EMPTY_MINUTES(<span class="number">5009</span>,<span class="string">&quot;使用时长不能为空&quot;</span>),</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiDefine</span> ATTEND_ERROR_MINUTES</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiError</span> 5010 使用时长不能为负数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ATTEND_ERROR_MINUTES(<span class="number">5010</span>,<span class="string">&quot;使用时长不能为负数&quot;</span>),</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiDefine</span> ATTEND_ERROR2_MINUTES</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiError</span> 5011 当天使用时长不能大于24小时</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ATTEND_ERROR2_MINUTES(<span class="number">5011</span>,<span class="string">&quot;当天使用时长不能大于24小时&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    ;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">final</span> <span class="type">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String msg;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">AttendRestEnum</span><span class="params">(<span class="type">int</span> code,String msg)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.code;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-在接口中使用自定义标签"><a href="#3-在接口中使用自定义标签" class="headerlink" title="3.在接口中使用自定义标签"></a>3.在接口中使用自定义标签</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@api</span> &#123;get&#125; /rest/area/getAreasByCode 行政区域查询</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@apiDescription</span> 根据行政编码获取行政区域,0获取省级行政区域</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@apiName</span> getAreasByCode</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@apiGroup</span> area</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@apiVersion</span> 1.0.0</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@apiParam</span> &#123;String&#125; code 行政编码</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@apiSampleRequest</span> /rest/area/getAreasByCode</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@apiUse</span> token_msg</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@apiUse</span> success_msg</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@apiSuccess</span> (success 2000) &#123;String&#125;   res.id    标识码</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@apiSuccess</span> (success 2000) &#123;String&#125;   res.name    行政地区名称</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@apiSuccess</span> (success 2000) &#123;String&#125;   res.code    行政编码</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@apiSuccess</span> (success 2000) &#123;String&#125;   res.prevCode    上级行政编码</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@apiSuccess</span> (success 2000) &#123;String&#125;   res.allName    全称</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment"></span></span><br></pre></td></tr></table></figure>



<h5 id="4-生成接口文档"><a href="#4-生成接口文档" class="headerlink" title="4.生成接口文档"></a>4.生成接口文档</h5><p>使用命令：apidoc -i ./ -o ./apidoc</p>
<p>然后就可以在apidoc文档的index.html看到生成的接口文档啦</p>
<p>参考博客：<a href="https://blog.csdn.net/chemphone/article/details/79193466">Spring项目集成apidoc生成api接口文档</a></p>
]]></content>
      <categories>
        <category>学习教程</category>
      </categories>
      <tags>
        <tag>apidoc</tag>
        <tag>接口</tag>
      </tags>
  </entry>
  <entry>
    <title>关于搭建vpn科学上网</title>
    <url>/2021/04/14/%E5%85%B3%E4%BA%8E%E6%90%AD%E5%BB%BAvpn%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/</url>
    <content><![CDATA[<blockquote>
<p>现状：现在市场上的翻墙软件多如牛毛，但找到一个好用省心的却不容易。如果你经常关注相关的信息，找到几十款科学上网App一点也不夸张，各个宣传也是八仙过海，各显神通，但大多数科学上网软件在国内根本无法使用，千万别以为找到中国能用的翻墙软件很容易，事实上要亲自一款一款去尝试也比较繁琐，能在中国大陆安全且稳定使用的翻墙工具凤毛麟角。</p>
<p>​    目前PureVPN、VyprVPN、Ivacy、Surfshark在国内都基本上已经失效；Lantern蓝灯VPN经常出现连接失败的问题；NordVPN除了安卓手机能直连其他设备只能手动配置连接，要找客服获取中国专用客户端；光年VPN国内少数地区可能有连接不上、速度慢的问题，选择时请注意避坑。</p>
</blockquote>
<span id="more"></span>

<h3 id="科学上网的方式"><a href="#科学上网的方式" class="headerlink" title="科学上网的方式"></a>科学上网的方式</h3><p>最近有要到github的需求，但是发现网络慢的很，加载的页面全是裂开，让人郁闷，于是有了下文。</p>
<p>如果需求只是看网页，下面简单介绍几种方法：</p>
<ul>
<li><p>可以有使用插件的形式，适用于chrome浏览器，但是也仅限于到google查询一下资料，如果是想到油管看视频，那还是算了。</p>
</li>
<li><p>lantern蓝灯是一个选择，不过开年费会员不便宜，而且这货经常掉，性价比就不用说了。</p>
</li>
<li><p>vpn是个不错的选择，特别是对于技术小白来说，只需要给钱安装就Ok了。具体推荐的vpn如下</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>项目</th>
<th>1.StrongVPN</th>
<th>2.ExpressVPN</th>
<th>3.NordVPN</th>
<th>4.PandaVPN</th>
<th>5.光年VPN</th>
</tr>
</thead>
<tbody><tr>
<td>综合评分（10分制）</td>
<td>9.0</td>
<td>9.5</td>
<td>8.5</td>
<td>8.5</td>
<td>8.8</td>
</tr>
<tr>
<td>网络速度</td>
<td>快</td>
<td>最快</td>
<td>快</td>
<td>一般</td>
<td>一般</td>
</tr>
<tr>
<td>价格</td>
<td>较低</td>
<td>较高</td>
<td>中等</td>
<td>中等</td>
<td>中等</td>
</tr>
<tr>
<td>运营时间</td>
<td>长</td>
<td>长</td>
<td>长</td>
<td>短</td>
<td>短</td>
</tr>
<tr>
<td>全年可用率（估计）</td>
<td>90%-95%</td>
<td>95%+</td>
<td>85%-90%</td>
<td>80%-90%</td>
<td>85%-90%</td>
</tr>
<tr>
<td>可用节点数量</td>
<td>多</td>
<td>较多（包含L2TP协议）</td>
<td>中</td>
<td>中</td>
<td>中</td>
</tr>
<tr>
<td>连通率</td>
<td>高</td>
<td>高</td>
<td>中高</td>
<td>中</td>
<td>高</td>
</tr>
<tr>
<td>建立连接时间</td>
<td>快</td>
<td>快</td>
<td>快</td>
<td>快</td>
<td>快</td>
</tr>
<tr>
<td>连接稳定性（相对）</td>
<td>稳定</td>
<td>稳定</td>
<td>一般</td>
<td>一般</td>
<td>稳定</td>
</tr>
<tr>
<td>隐私安全</td>
<td>高</td>
<td>高</td>
<td>高</td>
<td>中</td>
<td>中</td>
</tr>
<tr>
<td>APP支持</td>
<td>全</td>
<td>全</td>
<td>全</td>
<td>较全（不支持路由器）</td>
<td>较全（不支持路由器）</td>
</tr>
<tr>
<td>支付宝</td>
<td>支持</td>
<td>支持</td>
<td>不支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>退款时限</td>
<td>30天内</td>
<td>30天内</td>
<td>30天内</td>
<td>7天内</td>
<td>14天内</td>
</tr>
<tr>
<td>售后服务</td>
<td>好</td>
<td>好</td>
<td>好</td>
<td>一般</td>
<td>一般</td>
</tr>
<tr>
<td>镜像官网</td>
<td>暂无(<a href="https://github.com/vpnforchina/vpnforchina.github.io#%E5%A6%82%E4%BD%95%E6%89%93%E5%BC%80strongvpn%E5%AE%98%E7%BD%91">如何访问?</a>)</td>
<td>停止</td>
<td>无(<a href="https://github.com/vpnforchina/vpnforchina.github.io#%E5%A6%82%E4%BD%95%E6%89%93%E5%BC%80nordvpn%E5%AE%98%E7%BD%91">如何访问?</a>)</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>APP快速下载</td>
<td>可以</td>
<td>可以</td>
<td>可以</td>
<td>可以</td>
<td>可以</td>
</tr>
<tr>
<td>链接</td>
<td><a href="https://strongvpn.com/?tr_aid=5e51d8882415d">https://strongvpn.com/?tr_aid=5e51d8882415d</a>   须自带梯子</td>
<td><a href="https://www.fastvpncn.com/expressvpn">https://www.fastvpncn.com/expressvpn</a></td>
<td></td>
<td><a href="https://linkv.org/panda/">https://linkv.org/panda/</a></td>
<td><a href="https://lightyearapp.live/zh?invite_code=EPDqD9uVK4T">https://lightyearapp.live/zh?invite_code=EPDqD9uVK4T</a></td>
</tr>
</tbody></table>
<h3 id="使用vps搭建ssr科学上网"><a href="#使用vps搭建ssr科学上网" class="headerlink" title="使用vps搭建ssr科学上网"></a>使用vps搭建ssr科学上网</h3><p>接下来才是我要说的重点：使用国外vps搭建vpn，科学上网</p>
<p>推荐的vps有<strong>Vultr</strong>、<strong>搬瓦工</strong>等，这里我使用的是vultr，不为什么，因为之前大学时候同学就给我介绍了这个。</p>
<p>vultr官网<a href="https://www.vultr.com/">https://www.vultr.com/</a></p>
<p>首先是创建一个账号，切记密码要10位以上，包含大小写字母和数字。</p>
<h4 id="创建账号-充钱"><a href="#创建账号-充钱" class="headerlink" title="创建账号-充钱"></a>创建账号-充钱</h4><p>创建好后先去充钱，这里落泪，因为我本来是想使用paypal支付，因为网上都说用这个支付$10会送$25，但是今天上班没带卡，被迫使用了Alipay，就是我的支付宝，我冲了$10，最终账号余额如下。</p>
<p><img src="image-20210414144414732.png" alt="image-20210414144414732"></p>
<h4 id="选购产品"><a href="#选购产品" class="headerlink" title="选购产品"></a>选购产品</h4><p>充好钱后，开开心心去选你所需要的服务器，如下图</p>
<p><img src="image-20210414144936727.png" alt="image-20210414144936727"></p>
<p>这里我们选择日本的机房，不为什么，近。</p>
<p>接下来是选择系统和配置，这里可以centos7或者ubuntu，配置是1核1GB，为什么不选2GB?qiong</p>
<p><img src="image-20210414145129916.png" alt="image-20210414145129916"></p>
<p><img src="image-20210414145217551.png" alt="image-20210414145217551"></p>
<p>然后点击Deploy now。</p>
<h4 id="远程连接和初始化"><a href="#远程连接和初始化" class="headerlink" title="远程连接和初始化"></a>远程连接和初始化</h4><p>回到控制台，可以看到实例的状态，如图。</p>
<p><img src="image-20210414150707742.png" alt="image-20210414150707742"></p>
<p>马赛克部分就是分配的ip，可以在cmd连接一下是否连通，这里不阐述。</p>
<p>然后使用xshell或者putty连到到我们的vps，这里推荐使用Putty，xshell连接不上，不知道为什么。</p>
<p>接下来执行以下脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate https://freed.ga/github/shadowsocksR.sh; bash shadowsocksR.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这里如果报错wget:<span class="built_in">command</span> not found则需安装wget命令，没报错就等两分钟</span></span><br><span class="line">yum install -y wget</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">接着就是输入密码和端口，随意</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="image-20210414151451820.png" alt="image-20210414151451820"></p>
<p><img src="image-20210415110118260.png" alt="image-20210415110118260"></p>
<h4 id="客户端使用shadowsocksR连接"><a href="#客户端使用shadowsocksR连接" class="headerlink" title="客户端使用shadowsocksR连接"></a>客户端使用shadowsocksR连接</h4><p>windows:  <a href="https://github.com/shadowsocksr-backup/shadowsocksr-csharp/releases">下载地址</a></p>
<p>安卓客户端：<a href="https://github.com/shadowsocksr-backup/shadowsocksr-android/releases/download/3.4.0.8/shadowsocksr-release.apk">下载地址</a></p>
<h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>使用SSR来代理上网，特征流量容易被检测，导致被墙，可以考虑更换v2ray或者另外购买域名，具体方法我这里不便细说，想要</p>
<p>了解的可自行到github上搜相关关键字。</p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>vpn</tag>
      </tags>
  </entry>
  <entry>
    <title>各种JVM垃圾回收器详解</title>
    <url>/2021/05/19/%E5%90%84%E7%A7%8DJVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h4 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h4><p>这个被问的太多了，先来聊这个吧。栽过…</p>
<h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><blockquote>
<p>G1 GC，全称Garbage-First Garbage Collector，通过-XX:+UseG1GC参数来启用，作为体验版随着JDK 6u14版本面世，在JDK 7u4版本发行时被正式推出，相信熟悉JVM的同学们都不会对它感到陌生。在JDK 9中，G1被提议设置为默认垃圾收集器（JEP 248）。</p>
<p>从官网的描述中，我们知道G1是一种服务器端的垃圾收集器，应用在多处理器和大容量内存环境中，在实现高吞吐量的同时，尽可能的满足垃圾收集暂停时间的要求。它是专门针对以下应用场景设计的: </p>
<ul>
<li>像CMS收集器一样，能与应用程序线程并发执行。</li>
<li>整理空闲空间更快。</li>
<li>需要GC停顿时间更好预测。</li>
<li>不希望牺牲大量的吞吐性能。</li>
<li>不需要更大的Java Heap。</li>
</ul>
</blockquote>
<span id="more"></span>

<h5 id="G1中的几个概念"><a href="#G1中的几个概念" class="headerlink" title="G1中的几个概念"></a>G1中的几个概念</h5><h6 id="Region"><a href="#Region" class="headerlink" title="Region"></a>Region</h6><p>传统的垃圾收集器，分为了新生代、老年代、和永久代(方法区的实现)，他们是连续的内存区域，如下图。</p>
<p><img src="image-20210519172400375.png" alt="内存区域"></p>
<p>而G1的各代储存地址不是连续的，每一代都被分成了n个大小一致的region（总2048个），每个Region的内存区域是连续的，单个Region的大小可通过参数-XX:G1HeapRegionSize设定，取值范围从1M到32M，且是2的指数。如果不设定，那么G1会根据Heap大小自动决定，如下图。</p>
<p><img src="image-20210519172611759.png" alt="Region"></p>
<h6 id="SATB"><a href="#SATB" class="headerlink" title="SATB"></a>SATB</h6><p>全称是Snapshot-At-The-Beginning，字面理解就是gc开始之前的存活对象的快照。它是通过Root Tracing得到的，作用是维持并发GC的正确性。 那么它是怎么维持并发GC的正确性的呢？根据三色标记算法，我们知道对象存在三种状态： </p>
<ul>
<li>白：对象没有被标记到，标记阶段结束后，会被当做垃圾回收掉。 </li>
<li>灰：对象被标记了，但是它的field还没有被标记或标记完。</li>
<li>黑：对象被标记了，且它的所有field也被标记完了。</li>
</ul>
<p>由于并发阶段的存在，Mutator和Garbage Collector线程同时对对象进行修改，就会出现白对象漏标的情况，这种情况发生的前提是：</p>
<ul>
<li>Mutator赋予一个黑对象该白对象的引用。 </li>
<li>Mutator删除了所有从灰对象到该白对象的直接或者间接引用。</li>
</ul>
<p>对于第一个条件，在并发标记阶段，如果该白对象是new出来的，并没有被灰对象持有，那么它会不会被漏标呢？Region中有两个top-at-mark-start（TAMS）指针，分别为prevTAMS和nextTAMS。在TAMS以上的对象是新分配的，这是一种隐式的标记。对于在GC时已经存在的白对象，如果它是活着的，它必然会被另一个对象引用，即条件二中的灰对象。如果灰对象到白对象的直接引用或者间接引用被替换了，或者删除了，白对象就会被漏标，从而导致被回收掉，这是非常严重的错误，所以SATB破坏了第二个条件。也就是说，一个对象的引用被替换时，可以通过write barrier 将旧引用记录下来。</p>
<h6 id="RSet"><a href="#RSet" class="headerlink" title="RSet"></a>RSet</h6><p>全称是Remembered Set，是辅助GC过程的一种结构，典型的空间换时间工具，和Card Table有些类似。还有一种数据结构也是辅助GC的：Collection Set（CSet），它记录了GC要收集的Region集合，集合里的Region可以是任意年代的。在GC的时候，对于old-&gt;young和old-&gt;old的跨代对象引用，只要扫描对应的CSet中的RSet即可。 逻辑上说每个Region都有一个RSet，RSet记录了其他Region中的对象引用本Region中对象的关系，属于points-into结构（谁引用了我的对象）。而Card Table则是一种points-out（我引用了谁的对象）的结构，每个Card 覆盖一定范围的Heap（一般为512Bytes）。G1的RSet是在Card Table的基础上实现的：每个Region会记录下别的Region有指向自己的指针，并标记这些指针分别在哪些Card的范围内。 这个RSet其实是一个Hash Table，Key是别的Region的起始地址，Value是一个集合，里面的元素是Card Table的Index。</p>
<p> RSet究竟是怎么辅助GC的呢？在做YGC的时候，只需要选定young generation region的RSet作为根集，这些RSet记录了old-&gt;young的跨代引用，避免了扫描整个old generation。 而mixed gc的时候，old generation中记录了old-&gt;old的RSet，young-&gt;old的引用由扫描全部young generation region得到，这样也不用扫描全部old generation region。所以RSet的引入大大减少了GC的工作量。</p>
<h5 id="G1-的GC模式"><a href="#G1-的GC模式" class="headerlink" title="G1 的GC模式"></a>G1 的GC模式</h5><p>G1提供了两种GC模式，Young GC和Mixed GC，两种都是完全Stop The World的。 </p>
<ul>
<li>Young GC：选定所有年轻代里的Region。通过控制年轻代的region个数，即年轻代内存大小，来控制young GC的时间开销。 </li>
<li>Mixed GC：选定所有年轻代里的Region，外加根据global concurrent marking统计得出收集收益高的若干老年代Region。在用户指定的开销目标范围内尽可能选择收益高的老年代Region。</li>
</ul>
<p>由上面的描述可知，Mixed GC不是full GC，它只能回收部分老年代的Region，如果mixed GC实在无法跟上程序分配内存的速度，导致老年代填满无法继续进行Mixed GC，就会使用serial old GC（full GC）来收集整个GC heap。所以我们可以知道，G1是不提供full GC的。</p>
<p>上文中，多次提到了global concurrent marking，它的执行过程类似CMS，但是不同的是，在G1 GC中，它主要是为Mixed GC提供标记服务的，并不是一次GC过程的一个必须环节。global concurrent marking的执行过程分为四个步骤：</p>
<ul>
<li>初始标记（initial mark，STW）。它标记了从GC Root开始直接可达的对象。</li>
<li>并发标记（Concurrent Marking）。这个阶段从GC Root开始对heap中的对象标记，标记线程与应用程序线程并行执行，并且收集各个Region的存活对象信息。</li>
<li>最终标记（Remark，STW）。标记那些在并发标记阶段发生变化的对象，将被回收。 </li>
<li>清除垃圾（Cleanup）。清除空Region（没有存活对象的），加入到free list。</li>
</ul>
<p>第一阶段initial mark是共用了Young GC的暂停，这是因为他们可以复用root scan操作，所以可以说global concurrent marking是伴随Young GC而发生的。第四阶段Cleanup只是回收了没有存活对象的Region，所以它并不需要STW。</p>
<p>Young GC发生的时机大家都知道，那什么时候发生Mixed GC呢？其实是由一些参数控制着的，另外也控制着哪些老年代Region会被选入CSet。 </p>
<ul>
<li>G1HeapWastePercent：在global concurrent marking结束之后，我们可以知道old gen regions中有多少空间要被回收，在每次YGC之后和再次发生Mixed GC之前，会检查垃圾占比是否达到此参数，只有达到了，下次才会发生Mixed GC。</li>
<li>G1MixedGCLiveThresholdPercent：old generation region中的存活对象的占比，只有在此参数之下，才会被选入CSet。</li>
<li>G1MixedGCCountTarget：一次global concurrent marking之后，最多执行Mixed GC的次数。 </li>
<li>G1OldCSetRegionThresholdPercent：一次Mixed GC中能被选入CSet的最多old generation region数量。</li>
</ul>
<p>除了以上的参数，G1 GC相关的其他主要的参数有：</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-XX:G1HeapRegionSize=n</td>
<td align="left">设置Region大小，并非最终值</td>
</tr>
<tr>
<td align="left">-XX:MaxGCPauseMillis</td>
<td align="left">设置G1收集过程目标时间，默认值200ms，不是硬性条件</td>
</tr>
<tr>
<td align="left">-XX:G1NewSizePercent</td>
<td align="left">新生代最小值，默认值5%</td>
</tr>
<tr>
<td align="left">-XX:G1MaxNewSizePercent</td>
<td align="left">新生代最大值，默认值60%</td>
</tr>
<tr>
<td align="left">-XX:ParallelGCThreads</td>
<td align="left">STW期间，并行GC线程数</td>
</tr>
<tr>
<td align="left">-XX:ConcGCThreads=n</td>
<td align="left">并发标记阶段，并行执行的线程数</td>
</tr>
<tr>
<td align="left">-XX:InitiatingHeapOccupancyPercent</td>
<td align="left">设置触发标记周期的 Java 堆占用率阈值。默认值是45%。这里的java堆占比指的是non_young_capacity_bytes，包括old+humongous</td>
</tr>
</tbody></table>
<img src="8f235085005aac233ae71be06350eb07.gif" alt="memo" style="zoom:125%;" />

<h4 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h4><h5 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h5><p>一般我们都是使用CMS+ParNew进行搭配，这是一款以缩短停顿时间为目的的垃圾收集器，而G1和ZGC也都是以这个为优化和调整的方向。</p>
<p>常用参数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-XX:+UseConcMarkSweepGC：启用cms</span><br><span class="line">-XX:ConcGCThreads：并发的GC线程数</span><br><span class="line">-XX:+UseCMSCompactAtFullCollection：FullGC 之后做压缩整理（减少碎片）</span><br><span class="line">-XX:CMSFullGCsBeforeCompaction：间隔多少次 FullGC 之后压缩整理一次，默认是0，代表间隔 0 次 FullGC 后会进行压缩整理，即每次 FullGC 后都会进行整理</span><br><span class="line">-XX:CMSInitiatingOccupancyFraction: 当老年代使用达到该比例时会触发 FullGC（默认是92，这是百分比）</span><br><span class="line">-XX:+UseCMSInitiatingOccupancyOnly：只使用设定的回收阈值(-XX:CMSInitiatingOccupancyFraction设定的值)，如果不指定，JVM仅在第一次使用设定值，后续则会自动调整</span><br><span class="line">-XX:+CMSScavengeBeforeRemark：在CMS GC 标记前启动一次 minor gc，目的在于减少老年代对年轻代的引用，降低CMS GC的标记阶段时的开销，一般CMS的GC耗时 80%都在标记阶段</span><br><span class="line">-XX:+CMSParallellnitialMarkEnabled：表示在初始标记的时候多线程执行，缩短STW</span><br><span class="line">-XX:+CMSParallelRemarkEnabled：在重新标记的时候多线程执行，缩短STW;</span><br></pre></td></tr></table></figure>



<h5 id="GC执行步骤"><a href="#GC执行步骤" class="headerlink" title="GC执行步骤"></a>GC执行步骤</h5><p><img src="20201010095749684.png" alt="GC过程"></p>
<ul>
<li>初始标记。该过程是需要STW的，仅标记和GC Roots 直接关联的对象，这个过程在JDK7之前是单线程，8之后为多线程并行(没有用户线程在运行)，过程很快。</li>
<li>并发标记。该过程是和用户线程一起运行的，不会发生STW，主要是在【初始标记】的基础上，标记剩余的所有引用对象。由于该过程是和用户线程并行的，所以可能会产生误判或者漏标记的情况，后面通过三色标记法解决了这个问题。</li>
<li>重新标记。主要是整理在过程【并发标记】中已经被标记为可回收的对象重新被引用，会发生STW。</li>
<li>并发清理。这个过程如果有新的对象进来会被标记为黑色，不再处理，不会发生STW。</li>
</ul>
<h5 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h5><p><strong>优点</strong></p>
<p>低停顿，并发收集。</p>
<p><strong>缺点</strong></p>
<ul>
<li>对 cpu 资源敏感，会与服务争抢 cpu 资源</li>
<li>无法处理浮动垃圾，在并发标记和并发清理阶段产生的浮动垃圾只能留到下次 gc 清理</li>
<li>因为使用的是标记清除算法，所以会产生大量的内存碎片</li>
<li>垃圾回收过程的不确定性，即在并标记和并发清理阶段产生了大量的对象导致本次 gc 没有进行完却又出发了回收即 concurrent mode failure，此时会 STW 并转换为使用 Serial Old 进行串行收集</li>
</ul>
<h4 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h4><p>所谓三色标记，即垃圾收集器在标记过程中将对象分别标记为三种颜色：<br>黑色：通过 GC ROOT 扫描到且所有直接引用都扫描到的对象标记为黑色<br>灰色：通过 GC ROOT 扫描到但未扫描完所有直接引用对象标记为灰色<br>白色：为被扫描的的对象为白色<br>在回收时会回收所有标记为白色对象</p>
<p><img src="20201019214650906.png" alt="三色标记法"></p>
<p>对于多标和漏标的情况垃圾回收器基于三色标记法和对象的读写屏障提供了两种解决方案，增量更新和原始快照 CMS 使用的是增量更新，而 G1 使用的是原始快照。<br>增量更新：增量更新即为在并发标记过程中在黑色对象成员变量在更新引用时会将该引用记录下来，在重新标记的时候重新对该对象进行扫描标记。也可以理解为如果对象写入了新值就将该对象的状态标记为灰色。<br>原始快照：原始快照顾名思义即保留原始的信息，在灰色对象成员变量引用更新的时候记录下老对象的引用，在重新标记过程中将这些老对象全都标记为黑色不进行回收，这样可能会产生浮动垃圾，但同时也减少了从新扫描的时间，与增量更新各有利弊。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JVM，垃圾收集器</tag>
      </tags>
  </entry>
  <entry>
    <title>如何做好微服务的拆分</title>
    <url>/2021/04/13/%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%8B%86%E5%88%86/</url>
    <content><![CDATA[<h3 id="微服务实战：如何做好服务拆分"><a href="#微服务实战：如何做好服务拆分" class="headerlink" title="微服务实战：如何做好服务拆分"></a>微服务实战：如何做好服务拆分</h3><h3 id="服务拆分的前提"><a href="#服务拆分的前提" class="headerlink" title="服务拆分的前提"></a>服务拆分的前提</h3><p>说到微服务，服务拆分是绕不过去的话题，但是微服务不是说拆就能拆的，有很多的前提条件，需要完成前面几节所论述的部分。</p>
<p>首先要有一个持续集成的平台，使得服务在拆分的过程中，功能的一致性，这种一致性不能通过人的经验来，而需要经过大量的回归测试集，并且持续的拆分，持续的演进，持续的集成，从而保证系统时刻处于可以验证交付的状态，而非闭门拆分一段时间，最终谁也不知道功能最终究竟有没有bug，因而需要另外一个月的时间专门修改bug。<span id="more"></span></p>
<p>其次在接入层，API和UI要动静分离，API由API网关统一的管理，这样后端无论如何拆分，可以保证对于前端来讲，统一的入口，而且可以实现拆分过程中的灰度发布，路由分发，流量切分，从而保证拆分的平滑进行。而且拆分后的微服务之间，为了高性能，是不建议每次调用都进行认证鉴权的，而是在API网关上做统一的认证鉴权，一旦进入网关，服务之间的调用就是可信的。</p>
<p>其三对于数据库，需要进行良好的设计，不应该有大量的联合查询，而是将数据库当成一个简单的key-value查询，复杂的联合查询通过应用层，或者通过Elasticsearch进行。如果数据库表之间耦合的非常严重，其实服务拆分是拆不出来的。</p>
<p>其四要做应用的无状态化，只有无状态的应用，才能横向扩展，这样拆分才有意义。</p>
<h3 id="服务拆分的时机"><a href="#服务拆分的时机" class="headerlink" title="服务拆分的时机"></a>服务拆分的时机</h3><p>满足了服务拆分的前提之后，那先拆哪个模块，后拆哪个模块呢？什么情况下一个模块应该拆分出来呢？</p>
<p>微服务拆分绝非一个大跃进运动，由高层发起，把一个应用拆分的七零八落的，最终大大增加运维成本，但是并不会带来收益。</p>
<p>微服务拆分的过程，应该是一个由痛点驱动的，是业务真正遇到了快速迭代和高并发的问题，如果不拆分，将对于业务的发展带来影响，只有这个时候，微服务的拆分是有确定收益的，增加的运维成本才是值得的。</p>
<p><strong>微服务解决的问题之一，就是快速迭代</strong>。</p>
<p>互联网产品的特点就是迭代速度快，一般一年半就能决出胜负，第一一统天下，第二被第一收购，其他死翘翘。所以快速上线，快速迭代，就是生命线，而且一旦成功就是百亿身家，所以无论付出多大运维成本，使用微服务架构都是值得的。</p>
<p>这也就是为什么大部分使用微服务架构的都是互联网企业，因为对于这些企业来讲收益明显。而对于很多传统的应用，半年更新一次，企业运营相对平稳，IT系统的好坏对于业务没有关键性影响，在他们眼中，微服务化改造带来的效果，还不如开发多加几次班。</p>
<p>微服务拆分时机一：提交代码频繁出现大量冲突</p>
<p>微服务对于快速迭代的效果，首先是开发独立，如果是一单体应用，几百人开发一个模块，如果使用Git做代码管理，则经常会遇到的事情就是代码提交冲突。</p>
<p>同样一个模块，你也改，他也改，几百人根本没办法沟通。所以当你想提交一个代码的时候，发现和别人提交的冲突了，于是因为你是后提交的人，你有责任去merge代码，好不容易merge成功了，等再次提交的时候，发现又冲突了，你是不是很恼火。随着团队规模越大，冲突概率越大。</p>
<p>所以应该拆分成不同的模块，每十个人左右维护一个模块，也即一个工程，首先代码冲突的概率小多了，而且有了冲突，一个小组一吼，基本上问题就解决了。</p>
<p>每个模块对外提供接口，其他依赖模块可以不用关注具体的实现细节，只需要保证接口正确就可以。</p>
<p>微服务拆分时机二：小功能要积累到大版本才能上线，上线开总监级别大会</p>
<p>微服务对于快速迭代的效果，首先是上线独立。如果没有拆分微服务，每次上线都是一件很痛苦的事情。当你修改了一个边角的小功能，但是你不敢马上上线，因为你依赖的其他模块才开发了一半，你要等他，等他好了，也不敢马上上线，因为另一个被依赖的模块也开发了一半，当所有的模块都耦合在一起，互相依赖，谁也没办法独立上线，而是需要总监协调各个团队，大家开大会，约定一个时间点，无论大小功能，死活都要这天上线。</p>
<p>这种模式导致上线的时候，单次上线的需求列表非常长，这样风险比较大，可能小功能的错误会导致大功能的上线不正常，将如此长的功能，需要一点点check，非常小心，这样上线时间长，影响范围大。因而这种的迭代速度快不了，顶多一个月一次就不错了。</p>
<p>服务拆分后，在接口稳定的情况下，不同的模块可以独立上线。这样上线的次数增多，单次上线的需求列表变小，可以随时回滚，风险变小，时间变短，影响面小，从而迭代速度加快。</p>
<p>对于接口要升级部分，保证灰度，先做接口新增，而非原接口变更，当注册中心中监控到的调用情况，发现接口已经不用了，再删除。</p>
<p><strong>微服务解决的问题之二，就是高并发</strong>。</p>
<p>互联网一个产品的特点就是在短期内要积累大量的用户，这甚至比营收和利润还重要，如果没有大量的用户基数，融资都会有问题。</p>
<p>因而对于并发量不大的系统，进行微服务化的驱动力差一些，如果只有不多的用户在线，多线程就能解决问题，最多做好无状态化，前面部署个负载均衡，单体应用部署多份。</p>
<p>微服务拆分时机三：横向扩展流程复杂，主要业务和次要业务耦合</p>
<p>单体应用无状态化之后，虽然通过部署多份，可以承载一定的并发量，但是资源非常浪费。因为有的业务是需要扩容的，例如下单和支付，有的业务是不需要扩容的，例如注册。如果一起扩容，消耗的资源可能是拆分后的几倍，成本可能多出几个亿。而且由于配置复杂，在同一个工程里面，往往在配置文件中是这样组织的，这一块是这个模块的，下一块是另一个模块的，这样扩容的时候，一些边角的业务，也是需要对配置进行详细审核，否则不敢贸然扩容。</p>
<p>微服务拆分时机四：熔断降级全靠if-else</p>
<p>在高并发场景下，我们希望一个请求如果不成功，不要占用资源，应该尽快失败，尽快返回，而且希望当一些边角的业务不正常的情况下，主要业务流程不受影响。这就需要熔断策略，也即当A调用B，而B总是不正常的时候，为了让B不要波及到A，可以对B的调用进行熔断，也即A不调用B，而是返回暂时的fallback数据，当B正常的时候，再放开熔断，进行正常的调用。</p>
<p>有时候为了保证核心业务流程，边角的业务流程，如评论，库存数目等，人工设置为降级的状态，也即默认不调用，将所有的资源用于大促的下单和支付流程。</p>
<p>如果核心业务流程和边角业务流程在同一个进程中，就需要使用大量的if-else语句，根据下发的配置来判断是否熔断或者降级，这会使得配置异常复杂，难以维护。</p>
<p>如果核心业务和边角业务分成两个进程，就可以使用标准的熔断降级策略，配置在某种情况下，放弃对另一个进程的调用，可以进行统一的维护。</p>
<h3 id="服务拆分的方法"><a href="#服务拆分的方法" class="headerlink" title="服务拆分的方法"></a>服务拆分的方法</h3><p>好了，当你觉得要将一个程序的某个部分拆分出来的时候，有什么方法可以保障平滑吗？</p>
<p>首先要做的，就是原有工程代码的标准化，我们常称为“任何人接手任何一个模块都能看到熟悉的面孔”</p>
<p>例如打开一个Java工程，应该有以下的package：</p>
<ul>
<li>API接口包：所有的接口定义都在这里，对于内部的调用，也要实现接口，这样一旦要拆分出去，对于本地的接口调用，就可以变为远程的接口调用。</li>
<li>访问外部服务包：如果这个进程要访问其他进程，对于外部访问的封装都在这里，对于单元测试来讲，对于这部分的Mock，可以使得不用依赖第三方，就能进行功能测试。对于服务拆分，调用其他的服务，也是在这里。</li>
<li>数据库DTO：如果要访问数据库，在这里定义原子的数据结构。</li>
<li>访问数据库包：访问数据库的逻辑全部在这个包里面。</li>
<li>服务与商务逻辑：这里实现主要的商业逻辑，拆分也是从这里拆分出来。</li>
<li>外部服务：对外提供服务的逻辑在这里，对于接口的提供方，要实现在这里。</li>
</ul>
<p>另外是测试文件夹，每个类都应该有单元测试，要审核单元测试覆盖率，模块内部应该通过Mock的方法实现集成测试。</p>
<p>接下来是配置文件夹，配置profile，配置分为几类：</p>
<ul>
<li>内部配置项（启动后不变，改变需要重启）</li>
<li>集中配置项（配置中心，可动态下发）</li>
<li>外部配置项（外部依赖，和环境相关）</li>
</ul>
<p>当一个工程的结构非常标准化之后，接下来在原有服务中，先独立功能模块 ，规范输入输出，形成服务内部的分离。在分离出新的进程之前，先分离出新的jar，只要能够分离出新的jar，基本也就实现了松耦合。</p>
<p>接下来，应该新建工程，新启动一个进程，尽早的注册到注册中心，开始提供服务，这个时候，新的工程中的代码逻辑可以先没有，只是转调用原来的进程接口。</p>
<p>为什么要越早独立越好呢？哪怕还没实现逻辑先独立呢？因为服务拆分的过程是渐进的，伴随着新功能的开发，新需求的引入，这个时候，对于原来的接口，也会有新的需求进行修改，如果你想把业务逻辑独立出来，独立了一半，新需求来了，改旧的，改新的都不合适，新的还没独立提供服务，旧的如果改了，会造成从旧工程迁移到新工程，边迁移边改变，合并更加困难。如果尽早独立，所有的新需求都进入新的工程，所有调用方更新的时候，都改为调用新的进程，对于老进程的调用会越来越少，最终新进程将老进程全部代理。</p>
<p>接下来就可以将老工程中的逻辑逐渐迁移到新工程，由于代码迁移不能保证逻辑的完全正确，因而需要持续集成，灰度发布，微服务框架能够在新老接口之间切换。</p>
<p>最终当新工程稳定运行，并且在调用监控中，已经没有对于老工程的调用的时候，就可以将老工程下线了。</p>
<h3 id="服务拆分的规范"><a href="#服务拆分的规范" class="headerlink" title="服务拆分的规范"></a>服务拆分的规范</h3><p>微服务拆分之后，工程会比较的多，如果没有一定的规范，将会非常混乱，难以维护。</p>
<p>首先人们经常问的一个问题是，服务拆分之后，原来都在一个进程里面的函数调用，现在变成了A调用B调用C调用D调用E，会不会因为调用链路过长而使得相应变慢呢？</p>
<p>服务拆分的规范一：服务拆分最多三层，两次调用</p>
<p>服务拆分是为了横向扩展，因而应该横向拆分，而非纵向拆成一串的。也即应该将商品和订单拆分，而非下单的十个步骤拆分，然后一个调用一个。</p>
<p>纵向的拆分最多三层：</p>
<ul>
<li>基础服务层：用于屏蔽数据库，缓存层，提供原子的对象查询接口，有这一层，为了数据层做一定改变的时候，例如分库分表，数据库扩容，缓存替换等，对于上层透明，上层仅仅调用这一层的接口，不直接访问数据库和缓存。</li>
<li>组合服务层：这一层调用基础服务层，完成较为复杂的业务逻辑，实现分布式事务也多在这一层</li>
<li>Controller层：接口层，调用组合服务层对外</li>
</ul>
<p>服务拆分的规范二：仅仅单向调用，严禁循环调用</p>
<p>微服务拆分后，服务之间的依赖关系复杂，如果循环调用，升级的时候就很头疼，不知道应该先升级哪个，后升级哪个，难以维护。</p>
<p>因而层次之间的调用规定如下：</p>
<ul>
<li>基础服务层主要做数据库的操作和一些简单的业务逻辑，不允许调用其他任何服务。</li>
<li>组合服务层，可以调用基础服务层，完成复杂的业务逻辑，可以调用组合服务层，不允许循环调用，不允许调用Controller层服务</li>
<li>Controller层，可以调用组合业务层服务，不允许被其他服务调用</li>
</ul>
<p>如果出现循环调用，例如A调用B，B也调用A，则分成Controller层和组合服务层两层，A调用B的下层，B调用A的下层。也可以使用消息队列，将同步调用，改为异步调用。</p>
<p>服务拆分的规范三：将串行调用改为并行调用，或者异步化</p>
<p>如果有的组合服务处理流程的确很长，需要调用多个外部服务，应该考虑如何通过消息队列，实现异步化和解耦。</p>
<p>例如下单之后，要刷新缓存，要通知仓库等，这些都不需要再下单成功的时候就要做完，而是可以发一个消息给消息队列，异步通知其他服务。</p>
<p>而且使用消息队列的好处是，你只要发送一个消息，无论下游依赖方有一个，还是有十个，都是一条消息搞定，只不过多几个下游监听消息即可。</p>
<p>对于下单必须同时做完的，例如扣减库存和优惠券等，可以进行并行调用，这样处理时间会大大缩短，不是多次调用的时间之和，而是最长的那个系统调用时间。</p>
<p>服务拆分的规范四：接口应该实现幂等</p>
<p>微服务拆分之后，服务之间的调用当出现错误的时候，一定会重试，但是为了不要下两次单，支付两次，需要所有的接口实现幂等。</p>
<p>幂等一般需要设计一个幂等表来实现，幂等表中的主键或者唯一键可以是transaction id，或者business id，可以通过这个id的唯一性标识一个唯一的操作。</p>
<p>也有幂等操作使用状态机，当一个调用到来的时候，往往触发一个状态的变化，当下次调用到来的时候，发现已经不是这个状态，就说明上次已经调用过了。</p>
<p>状态的变化需要是一个原子操作，也即并发调用的时候，只有一次可以执行。可以使用分布式锁，或者乐观锁CAS操作实现。</p>
<p>服务拆分的规范五：接口数据定义严禁内嵌，透传</p>
<p>微服务接口之间传递数据，往往通过数据结构，如果数据结构透传，从底层一直到上层使用同一个数据结构，或者上层的数据结构内嵌底层的数据结构，当数据结构中添加或者删除一个字段的时候，波及的面会非常大。</p>
<p>因而接口数据定义，在每两个接口之间约定，严禁内嵌和透传，即便差不多，也应该重新定义，这样接口数据定义的改变，影响面仅仅在调用方和被调用方，当接口需要更新的时候，比较可控，也容易升级。</p>
<p>服务拆分的规范六：规范化工程名</p>
<p>微服务拆分后，工程名非常多，开发人员，开发团队也非常多，如何让一个开发人员看到一个工程名，或者jar的名称，就大概知道是干什么的，需要一个规范化的约定。</p>
<p>例如出现pay就是支付，出现order就是下单，出现account就是用户。</p>
<p>再如出现compose就是组合层，controller就是接口层，basic就是基础服务层。</p>
<p>出现api就是接口定义，impl就是实现。</p>
<p>pay-compose-api就是支付组合层接口定义。</p>
<p>account-basic-impl就是用户基础服务层的实现。</p>
<h3 id="服务发现的选型"><a href="#服务发现的选型" class="headerlink" title="服务发现的选型"></a>服务发现的选型</h3><p>微服务拆分后，服务之间的调用需要服务发现和注册中心进行维护。也能主流的有几种方法。</p>
<p>第一是Dubbo，Dubbo是SOA架构的微服务框架的标准，已经被大量使用，虽然中间中断维护过一段时间，但是随着微服务的兴起，重新进行了维护，是很多熟悉Dubbo RPC开发人员的首选。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9dc906ad06fbe90a3314b65d1b8daeac.png" alt="1.jpg"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>第二种是Spring Cloud，Spring Cloud为微服务而生，在Dubbo已经没有人维护的情况下，推出了支撑微服务的成熟框架。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/186d761f4a80253b37a87299cbcb3413.png" alt="2.jpg"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>Dubbo vs. Spring Cloud的对比，Dubbo更加注重服务治理，原生功能不够全面，而Spring Cloud注重整个微服务生态，工具链非常全面。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/4079c1503fe4e1eb7b8e4a45d9636463.png" alt="3.jpg"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>Spring Cloud可定制性强，通过各种组件满足各种微服务场景，使用Spring Boot统一编程模型，能够快速构建应用，基于注解，使用方便，但是学习门槛比较高。</p>
<p>Dubbo注册到ZooKeeper里面的是接口，而Spring Cloud注册到Eureka或者Consul里面的是实例，在规模比较小的情况下没有分别，但是规模一旦大了，例如实例数目万级别，接口数据就算十万级别，对于ZooKeeper中的树规模比较大，而且ZooKeeper是强一致性的，当一个节点挂了的时候，节点之间的数据同步会影响线上使用，而Spring Cloud就好很多，实例级别少一个量级，另外Consul也非强一致的。</p>
<p>第三是Kubernetes，Kubernetes虽然是容器平台，但是他设计出来，就是为了跑微服务的，因而提供了微服务运行的很多组件。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/807abfcefc8a1d48363a823f9174dca6.png" alt="4.jpg"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"><br>很多Spring Cloud可以做的事情，Kubernetes也有相应的机制，而且由于是容器平台，相对比较通用，可以支持多语言，对于业务无侵入，但是也正因为是容器平台，对于微服务的运行生命周期的维护比较全面，对于服务之间的调用和治理，比较弱，Service只能满足最最基本的服务发现需求。</p>
<p>因而实践中使用的时候，往往是Kubernetes和Spring Cloud结合使用，Kubernetes负责提供微服务的运行环境，服务之间的调用和治理，由Spring Cloud搞定。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/a5a2b647a8039f3f825454b62f140440.png" alt="5.jpg"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>第四是Service Mesh，Service Mesh一定程度上弥补了kubernetes对于服务治理方面的不足，对业务代码0侵入，将服务治理下沉到平台层，是服务治理的一个趋势。</p>
<p>然而Service Mesh需要使用单独的进程进行请求转发，性能还不能让人满意，另外社区比较新，成熟度不足，暂时没有达到大规模生产使用的标准。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/047e0f05d19a71dd4187b93c5c497b47.png" alt="6.png"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
]]></content>
      <categories>
        <category>架构篇</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>如何设计高可用架构</title>
    <url>/2021/05/16/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<blockquote>
<p>只是记录个人的一些理解，仅作参考</p>
</blockquote>
<h4 id="如何设计出高可用的服务架构"><a href="#如何设计出高可用的服务架构" class="headerlink" title="如何设计出高可用的服务架构"></a>如何设计出高可用的服务架构</h4><p>​    相信我们在面试中经常会被问到，有设计过什么样的架构来支撑公司的业务，这个架构有没有什么缺点或者美中不足的地方。</p>
<p>以下是我的一些总结，要想设计出一个高可用的服务架构，需要考虑以下几点：</p>
<ul>
<li>首先是要保持业务的稳定性(系统的稳定性是高可用的根本目的，系统持续可用，不会无故宕机，高压下仍能正常工作)</li>
<li>支持快速定位故障(除了故障能够快速发现和定位，通过报警机制，帮助工程师快速处理问题，不影响业务)</li>
<li>支持快速恢复业务</li>
</ul>
<span id="more"></span>

<p>下面是沿着这几点做的优化：</p>
<h5 id="把项目微服务化，对资源进行分离，并搭建主从架构-对应目标1"><a href="#把项目微服务化，对资源进行分离，并搭建主从架构-对应目标1" class="headerlink" title="把项目微服务化，对资源进行分离，并搭建主从架构(对应目标1)"></a>把项目微服务化，对资源进行分离，并搭建主从架构(对应目标1)</h5><p>根据DDD领域驱动设计对我们的项目进行划分，划分模块的上下界，根据业务可划分为核心服务和普通服务，它们之前不会相互影响，服务背后的资源，如缓存、数据库、MQ相互分离。</p>
<h5 id="服务的治理，动态伸缩扩容，服务的熔断和降级-对应目标3"><a href="#服务的治理，动态伸缩扩容，服务的熔断和降级-对应目标3" class="headerlink" title="服务的治理，动态伸缩扩容，服务的熔断和降级(对应目标3)"></a>服务的治理，动态伸缩扩容，服务的熔断和降级(对应目标3)</h5><p>根据业务量，对微服务的部署架构进行动态调整；对于有故障的服务，进行降级和快速响应，避免故障扇出。</p>
<h5 id="建立分层监控-对应目标2"><a href="#建立分层监控-对应目标2" class="headerlink" title="建立分层监控(对应目标2)"></a>建立分层监控(对应目标2)</h5><p>一共可分为以下5层：</p>
<ul>
<li>网络层，主要是处理带宽的问题</li>
<li>接口层，防止做机刷等</li>
<li>业务层，服务内调用超时监控</li>
<li>中间件层，主要是缓存redis，或者mq</li>
<li>系统层，主要是服务器配置等</li>
</ul>
<h4 id="关于DDD领域设计驱动"><a href="#关于DDD领域设计驱动" class="headerlink" title="关于DDD领域设计驱动"></a>关于DDD领域设计驱动</h4>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>高可用</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>学习之路测试</title>
    <url>/2022/03/26/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3>]]></content>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>开发中常用的网址</title>
    <url>/2019/04/12/%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BD%91%E5%9D%80/</url>
    <content><![CDATA[<h4 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h4><p><a href="http://mvnrepository.com/">Maven中央仓库</a>   </p>
<p><a href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/" >Spring Boot 使用文档</a>       </p>
<p><a href="https://hub.docker.com/" >Docker 仓库</a>    </p>
<p><a href="http://www.redis.cn/" >Redis中文</a>    </p>
<p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html" >ElasticSearch 中文文档</a></p>
<h4 id="前端框架"><a href="#前端框架" class="headerlink" title="前端框架"></a>前端框架</h4><p><a href="https://2x.ant.design/docs/react/introduce-cn" >Ant Design</a>    </p>
<p><a href="https://www.layui.com/doc/" >Layui </a>    </p>
<p><a href="http://www.bootcss.com/" >Bootstrap</a>    </p>
<p><a href="http://www.jeasyui.net/" >EasyUI</a></p>
<span id="more"></span>

<h4 id="学习视频网站"><a href="#学习视频网站" class="headerlink" title="学习视频网站"></a>学习视频网站</h4><p><a href="http://www.gulixueyuan.com/path/java" >谷粒学院</a>    </p>
<p><a href="https://www.bilibili.com/" >哔哩哔哩</a>    </p>
<p><a href="https://apppukyptrl1086.pc.xiaoe-tech.com/index">儒猿技术窝</a></p>
<h4 id="技术博客-amp-教程文档"><a href="#技术博客-amp-教程文档" class="headerlink" title="技术博客&amp;教程文档"></a>技术博客&amp;教程文档</h4><p><a href="https://kuboard.cn/install/v3/install.html">K8S详细教程</a></p>
<h4 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h4><p><a href="https://try.redis.io/">Redis命令调试    </a></p>
<p><a href="http://doc.redisfans.com/">Redis命令参考    </a></p>
<p><a href="https://gitee.com/qishibo/AnotherRedisDesktopManager/releases">Redis链接客户端</a></p>
<p><a href="https://cron.qqe2.com/">Cron表达式</a>    </p>
<p><a href="https://www.snipaste.com/">电脑截屏</a>     </p>
<p><a href="https://gceasy.io/">GC分析</a></p>
]]></content>
      <categories>
        <category>学习工具</category>
      </categories>
      <tags>
        <tag>网址</tag>
      </tags>
  </entry>
  <entry>
    <title>服务的降级熔断和限流- Hystrix和Sentinel</title>
    <url>/2021/03/12/%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD%E5%92%8C%E9%99%8D%E7%BA%A7%E7%9A%84%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="服务的降级熔断和限流-Hystrix和Sentinel"><a href="#服务的降级熔断和限流-Hystrix和Sentinel" class="headerlink" title="服务的降级熔断和限流- Hystrix和Sentinel"></a>服务的降级熔断和限流- Hystrix和Sentinel</h2><h3 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h3><p>关于api的降级熔断和限流的实现原理，以下是hystrix为例，hystrix为我们提供了两种模式的执行逻辑：</p>
<p>①线程池（默认）</p>
<p>②信号量</p>
<span id="more"></span>

<h4 id="如何修改执行逻辑的模式"><a href="#如何修改执行逻辑的模式" class="headerlink" title="如何修改执行逻辑的模式"></a>如何修改执行逻辑的模式</h4><p>在配置文件里面：</p>
<p>execution.isolation.strategy = ExecutionIsolationStrategy.SEMAPHORE</p>
<h4 id="关于两者的区别"><a href="#关于两者的区别" class="headerlink" title="关于两者的区别"></a>关于两者的区别</h4><p>①信号量模式</p>
<p>在该模式下，接受请求和下游执行需要在同一个线程内完成，不存在上下文线程切换带来的性能开销，所以大部分场景下都应该使用信号量模式，但是如果在一个业务逻辑里面需要调用到多个其他服务的接口，且这种调用不存在上下文的依赖关系，对于该业务的执行时间就是所有接口调用耗时的总和。为了限制对下游接口的并发调用量，可以配置Hystrix的</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">execution.isolation.semaphore.maxConcurrentRequests</span><br></pre></td></tr></table></figure>

<p>当并发请求调用量达到阈值时，可以快速失败，执行降级。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMTg0OTUxLWJiOTk0NjdhMTU1Mjg0NTYucG5nP2ltYWdlTW9ncjIvYXV0by1vcmllbnQvc3RyaXB8aW1hZ2VWaWV3Mi8yL3cvMTIwMC9mb3JtYXQvd2VicA?x-oss-process=image/format,png" alt="img"></p>
<p>②线程池模式</p>
<p>在该模式下，每一个command都会建立一个对应的线程池，用户请求会被放到各自的线程池中处理，达到资源隔离的作用，当线程池来不及处理请求可以执行快速失败的逻辑，避免问题扩散。</p>
<ul>
<li>优势<ul>
<li>减少服务发生故障时的影响面</li>
<li>接口性能有变动，可以进行动态调整</li>
</ul>
</li>
<li>劣势<ul>
<li>用户请求都是在线程池执行，会带来任务调度、上下文切换的开销</li>
</ul>
</li>
</ul>
<h3 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h3><p>Sentinel 具有以下特征：</p>
<ul>
<li><strong>丰富的应用场景</strong>：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。</li>
<li><strong>完备的实时监控</strong>：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。</li>
<li><strong>广泛的开源生态</strong>：Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。</li>
<li><strong>完善的 SPI 扩展点</strong>：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。</li>
</ul>
<h3 id="hystrix和sentinel对比"><a href="#hystrix和sentinel对比" class="headerlink" title="hystrix和sentinel对比"></a>hystrix和sentinel对比</h3><table>
<thead>
<tr>
<th align="left"></th>
<th align="left">Sentinel</th>
<th align="left">Hystrix</th>
</tr>
</thead>
<tbody><tr>
<td align="left">隔离策略</td>
<td align="left">信号量隔离（并发线程数限流）</td>
<td align="left">线程池隔离/信号量隔离</td>
</tr>
<tr>
<td align="left">熔断降级策略</td>
<td align="left">基于响应时间、异常比率、异常数</td>
<td align="left">基于异常比率</td>
</tr>
<tr>
<td align="left">实时指标实现</td>
<td align="left">滑动窗口（LeapArray）</td>
<td align="left">滑动窗口（基于 RxJava）</td>
</tr>
<tr>
<td align="left">规则配置</td>
<td align="left">支持多种数据源</td>
<td align="left">支持多种数据源</td>
</tr>
<tr>
<td align="left">扩展性</td>
<td align="left">多个扩展点</td>
<td align="left">插件的形式</td>
</tr>
<tr>
<td align="left">基于注解的支持</td>
<td align="left">支持</td>
<td align="left">支持</td>
</tr>
<tr>
<td align="left">调用链路信息</td>
<td align="left">支持同步调用</td>
<td align="left">不支持</td>
</tr>
<tr>
<td align="left">限流</td>
<td align="left">基于 QPS / 并发数，支持基于调用关系的限流</td>
<td align="left">有限支持</td>
</tr>
<tr>
<td align="left">流量整形</td>
<td align="left">支持慢启动、匀速器模式</td>
<td align="left">不支持</td>
</tr>
<tr>
<td align="left">系统负载保护</td>
<td align="left">支持</td>
<td align="left">不支持</td>
</tr>
<tr>
<td align="left">控制台</td>
<td align="left">开箱即用，可配置规则、查看秒级监控、机器发现等</td>
<td align="left">较为简单</td>
</tr>
<tr>
<td align="left">常见框架的适配</td>
<td align="left">Servlet、Spring Cloud、Dubbo、gRPC 等</td>
<td align="left">Servlet、Spring Cloud Netflix</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>降级熔断</tag>
        <tag>限流</tag>
        <tag>Hystrix</tag>
        <tag>Sentinel</tag>
      </tags>
  </entry>
  <entry>
    <title>消息中间件的技术选型</title>
    <url>/2021/04/13/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/</url>
    <content><![CDATA[<p>现在市面上的消息中间件种类很多，常用的大致有4种，分别是Kafka、ActiveMQ、RabbitMQ、RocketMQ。</p>
<p>那么Kafka、ActiveMQ、RabbitMQ、RocketMQ都有什么优缺点？怎么技术选型呢？</p>
<span id="more"></span>

<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">ActiveMQ</th>
<th align="left">RabbitMQ</th>
<th align="left">RocketMQ</th>
<th align="left">Kafka</th>
</tr>
</thead>
<tbody><tr>
<td align="left">单机吞吐量</td>
<td align="left">万级，比 RocketMQ、Kafka 低一个数量级</td>
<td align="left">同 ActiveMQ</td>
<td align="left">10 万级，支撑高吞吐</td>
<td align="left">10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td>
</tr>
<tr>
<td align="left">topic 数量对吞吐量的影响</td>
<td align="left"></td>
<td align="left"></td>
<td align="left">topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic</td>
<td align="left">topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源</td>
</tr>
<tr>
<td align="left">时效性</td>
<td align="left">ms 级</td>
<td align="left">微秒级，这是 RabbitMQ 的一大特点，延迟最低</td>
<td align="left">ms 级</td>
<td align="left">延迟在 ms 级以内</td>
</tr>
<tr>
<td align="left">可用性</td>
<td align="left">高，基于主从架构实现高可用</td>
<td align="left">同 ActiveMQ</td>
<td align="left">非常高，分布式架构</td>
<td align="left">非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td>
</tr>
<tr>
<td align="left">消息可靠性</td>
<td align="left">有较低的概率丢失数据</td>
<td align="left">基本不丢</td>
<td align="left">经过参数优化配置，可以做到 0 丢失</td>
<td align="left">同 RocketMQ</td>
</tr>
<tr>
<td align="left">功能支持</td>
<td align="left">MQ 领域的功能极其完备</td>
<td align="left">基于 erlang 开发，并发能力很强，性能极好，延时很低</td>
<td align="left">MQ 功能较为完善，还是分布式的，扩展性好</td>
<td align="left">功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用</td>
</tr>
</tbody></table>
<p>综上，各种对比之后，有如下建议：</p>
<p>一般的业务系统要引入 MQ，最早大家都用 ActiveMQ，但是现在确实大家用的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃，所以大家还是算了吧，我个人不推荐用这个了；</p>
<p>后来大家开始用 RabbitMQ，但是确实 erlang 语言阻止了大量的 Java 工程师去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是确实人家是开源的，比较稳定的支持，活跃度也高；</p>
<p>不过现在确实越来越多的公司会去用 RocketMQ，确实很不错，毕竟是阿里出品，但社区可能有突然黄掉的风险（目前 RocketMQ 已捐给 Apache，但 GitHub 上的活跃度其实不算高）对自己公司技术实力有绝对自信的，推荐用 RocketMQ，否则回去老老实实用 RabbitMQ 吧，人家有活跃的开源社区，绝对不会黄。</p>
<p>所以中小型公司，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择；大型公司，基础架构研发实力较强，用 RocketMQ 是很好的选择。</p>
<p>如果是大数据领域的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</p>
]]></content>
      <categories>
        <category>架构篇</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
        <tag>RocketMQ</tag>
        <tag>消息中间件</tag>
        <tag>Kfaka</tag>
      </tags>
  </entry>
  <entry>
    <title>线上环境问题排查</title>
    <url>/2021/04/15/%E7%BA%BF%E4%B8%8A%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</url>
    <content><![CDATA[<p>本篇主要是介绍一些线上排查问题的指令和工具。</p>
<h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>工欲善其事，必先利其器，此处列出一些常用的工具，具体情况大家可以自由选择，本文的问题都是使用这些工具来定位和分析的。</p>
<h5 id="命令行终端"><a href="#命令行终端" class="headerlink" title="命令行终端"></a>命令行终端</h5><ul>
<li>标准终端类：jps、jinfo、jstat、jstack、jmap</li>
<li>功能整合类：jcmd、vjtools、arthas、greys</li>
</ul>
<h5 id="可视化界面"><a href="#可视化界面" class="headerlink" title="可视化界面"></a>可视化界面</h5><ul>
<li>简易：JConsole、JVisualvm、HA、GCHisto、GCViewer</li>
<li>进阶：MAT、JProfiler</li>
</ul>
<p>命令行推荐 arthas ，可视化界面推荐 JProfiler，此外还有一些在线的平台 <a href="https://gceasy.io/">gceasy</a>、<a href="https://heaphero.io/">heaphero</a>、<a href="https://fastthread.io/">fastthread</a> 也比较好用。</p>
<span id="more"></span>

<h3 id="开胃小菜"><a href="#开胃小菜" class="headerlink" title="开胃小菜"></a>开胃小菜</h3><p>开始之前先来一到小菜，循序渐进。</p>
<h4 id="简单指令"><a href="#简单指令" class="headerlink" title="简单指令"></a>简单指令</h4><h5 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">jps  一般使用这个指令来查看当前运行的java进程,-l查看所有</span></span><br><span class="line">jps -l</span><br></pre></td></tr></table></figure>

<p><img src="image-20210415160611851.png" alt="image-20210415160611851"></p>
<h5 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">jinfo 一般用来查看某个java进程使用的jvm参数和系统属性</span></span><br><span class="line">jinfo -sysprops pid</span><br></pre></td></tr></table></figure>

<p><img src="image-20210415160504342.png" alt="image-20210415160504342"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看所有jvm参数</span></span><br><span class="line">jinfo -flags pid</span><br></pre></td></tr></table></figure>

<p><img src="image-20210415160918989.png" alt="image-20210415160918989"></p>
<h5 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">一般我们使用该命令来查看jvm加载的类，gc统计</span></span><br><span class="line">jstat -class pid</span><br></pre></td></tr></table></figure>

<p><img src="image-20210415161245417.png" alt="image-20210415161245417"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">垃圾回收统计</span></span><br><span class="line">jstat -gc pid</span><br><span class="line">/*</span><br><span class="line">S0C：第一个幸存区的大小</span><br><span class="line">S1C：第二个幸存区的大小</span><br><span class="line">S0U：第一个幸存区的使用大小</span><br><span class="line">S1U：第二个幸存区的使用大小</span><br><span class="line">EC：伊甸园区的大小</span><br><span class="line">EU：伊甸园区的使用大小</span><br><span class="line">OC：老年代大小</span><br><span class="line">OU：老年代使用大小</span><br><span class="line">MC：方法区大小</span><br><span class="line">MU：方法区使用大小</span><br><span class="line">CCSC:压缩类空间大小</span><br><span class="line">CCSU:压缩类空间使用大小</span><br><span class="line">YGC：年轻代垃圾回收次数</span><br><span class="line">YGCT：年轻代垃圾回收消耗时间</span><br><span class="line">FGC：老年代垃圾回收次数</span><br><span class="line">FGCT：老年代垃圾回收消耗时间</span><br><span class="line">GCT：垃圾回收消耗总时间</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p><img src="image-20210415161406384.png" alt="image-20210415161406384"></p>
<h5 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">可以使用该命令来查看某个java进程的内存情况，还可以导出对应的堆栈信息</span></span><br><span class="line">jmap -heap pid</span><br></pre></td></tr></table></figure>

<p><img src="image-20210415161751600.png" alt="image-20210415161751600"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看某个java进程中存活的实例数和总大小， &gt; temp_file.txt 并输出到temp_file.txt文件里面</span></span><br><span class="line">jmap -histo:live pid &gt; temp_file.txt</span><br></pre></td></tr></table></figure>

<p><img src="image-20210415162408153.png" alt="image-20210415162408153"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">导出某个java进程的堆栈信息到.hprof文件，该文件可以利用MAT等工具查看</span></span><br><span class="line">jmap -dump:live,format=b,file=temp_file.hprof pid</span><br></pre></td></tr></table></figure>





<h3 id="正餐"><a href="#正餐" class="headerlink" title="正餐"></a>正餐</h3><p>接下来是我们的正餐，这部分主要讲述arthas 和mat的使用，包括一些线上GC的排查。</p>
<h4 id="arthas"><a href="#arthas" class="headerlink" title="arthas"></a>arthas</h4><p>arthas相信我们都不陌生，这是阿里开源的，现在才听说过的赶紧去下载用一次，附上 <a href="http://arthas.gitee.io/">arthas</a> 官网，这里的教程堪称完美，我这里就不多说了，只有几张图，方便后面我复习。</p>
<h5 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h5><p>step 1：到官网下载对应jar，使用上传命令rz上传到对应的服务器，也可以在服务器上直接使用curl下载</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -O https://arthas.aliyun.com/arthas-boot.jar</span><br></pre></td></tr></table></figure>

<p>step 2:  运行阿尔萨斯</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure>

<p><img src="image-20210415163551814.png" alt="image-20210415163551814"></p>
<p>step 3: 选择要依附的java进程，输入数字，出现下面红框表示成功</p>
<p><img src="image-20210415163702184.png" alt="image-20210415163702184"></p>
<h5 id="jvm指令相关"><a href="#jvm指令相关" class="headerlink" title="jvm指令相关"></a>jvm指令相关</h5><h6 id="dashboard"><a href="#dashboard" class="headerlink" title="dashboard"></a>dashboard</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看控制台，ctrl+c停止输出</span></span><br><span class="line">dashboard</span><br></pre></td></tr></table></figure>

<p><img src="image-20210415164048784.png" alt="image-20210415164048784"></p>
<h6 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看当前有哪些线程</span></span><br><span class="line">thread </span><br></pre></td></tr></table></figure>

<p><img src="image-20210415164150907.png" alt="image-20210415164150907"></p>
<h6 id="jvm"><a href="#jvm" class="headerlink" title="jvm"></a>jvm</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看当前的jvm信息</span></span><br><span class="line">jvm</span><br></pre></td></tr></table></figure>

<p><img src="image-20210415164323897.png" alt="image-20210415164323897"></p>
<h6 id="sysprop"><a href="#sysprop" class="headerlink" title="sysprop"></a>sysprop</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看和修改JVM的系统属性</span></span><br><span class="line">sysprop</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看某个系统属性</span></span><br><span class="line">sysprop prop-name</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改某个系统属性</span></span><br><span class="line">sysprop prop-name newValue</span><br></pre></td></tr></table></figure>

<p><img src="image-20210415164537300.png" alt="image-20210415164537300"></p>
<h6 id="sysenv"><a href="#sysenv" class="headerlink" title="sysenv"></a>sysenv</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看JVM的环境变量</span></span><br><span class="line">sysenv</span><br></pre></td></tr></table></figure>

<p><img src="image-20210415164922657.png" alt="image-20210415164922657"></p>
<h6 id="vmoption"><a href="#vmoption" class="headerlink" title="vmoption"></a>vmoption</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看和修改JVM里诊断相关的option</span></span><br><span class="line">vmoption</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看指定的option</span></span><br><span class="line">vmoption option</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改某个option的配置，一般都是用来开启PrintGCDetails等</span></span><br><span class="line">vmoption option value</span><br></pre></td></tr></table></figure>

<p><img src="image-20210415165040780.png" alt="image-20210415165040780"></p>
<h6 id="heapdump"><a href="#heapdump" class="headerlink" title="heapdump"></a>heapdump</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">dump java heap, 类似jmap命令的heap dump功能</span></span><br><span class="line">heapdump /tempfile.hprof</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">只dump还存活的对象</span></span><br><span class="line">heapdump --live /tmpfile.hprof</span><br></pre></td></tr></table></figure>

<h5 id="class-classloader指令相关"><a href="#class-classloader指令相关" class="headerlink" title="class/classloader指令相关"></a>class/classloader指令相关</h5><h6 id="sc"><a href="#sc" class="headerlink" title="sc"></a>sc</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">模糊搜索类</span></span><br><span class="line">sc test.*</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输出某个类的详细信息</span></span><br><span class="line">sc -d test.Demo</span><br></pre></td></tr></table></figure>

<h6 id="sm"><a href="#sm" class="headerlink" title="sm"></a>sm</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看已加载类的方法信息</span></span><br><span class="line">sm java.lang.String</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看某个方法的详细</span></span><br><span class="line">sm -d java.lang.String toString</span><br></pre></td></tr></table></figure>

<h6 id="jad"><a href="#jad" class="headerlink" title="jad"></a>jad</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">反编译指定的类，只显示源码，并输出到文件Demo.java</span></span><br><span class="line">jad --source-only test.Demo &gt; /temp/Demo.java</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">反编译指定的方法</span></span><br><span class="line">jad test.Demo methodTest</span><br></pre></td></tr></table></figure>

<h6 id="mc"><a href="#mc" class="headerlink" title="mc"></a>mc</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">内存编译java文件为class</span></span><br><span class="line">mc /temp/Test.java</span><br></pre></td></tr></table></figure>

<h6 id="retransform"><a href="#retransform" class="headerlink" title="retransform"></a>retransform</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">热加载class进jvm</span></span><br><span class="line">retransform /temp/Test.class</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">每加载一个.class文件，会记录一个entry，-l命令查看所有entry</span></span><br><span class="line">retransform -l</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除指定<span class="built_in">id</span>的entry</span></span><br><span class="line">retransform -d id</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">显式触发，让这个类立刻起作用</span></span><br><span class="line">retransform --classPattern test.Demo</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果是想消除这个类的影响，需要清除这个类对应的所有entry，然后重新显式触发</span></span><br></pre></td></tr></table></figure>



<h5 id="在docker中使用Arthas"><a href="#在docker中使用Arthas" class="headerlink" title="在docker中使用Arthas"></a>在docker中使用Arthas</h5><p>​    现在很多公司都是使用Docker来部署项目，使用jps命令查看不到当前哪些java进程，这样就使用不了Arthas，接下来进行一些小调整，使得能够在Docker容器里面使用Arthas。</p>
<p>​    首先是调整一下Dockerfile，我们一般使用的是如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">仅包含java运行环境，没有java自带的一些工具</span></span><br><span class="line">FROM java:8-jre</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">需要调整为如下</span></span><br><span class="line">FROM openjdk:8-jdk</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">或者</span></span><br><span class="line">FROM openjdk:8-jdk-alpine</span><br></pre></td></tr></table></figure>

<p>进入容器内部，下载Arthas并执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it arthas-demo /bin/sh -c &quot;java -jar /opt/arthas/arthas-boot.jar&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">或者把下载好的arthas复制到容器内部，再使用java -jar来运行</span></span><br><span class="line">docker cp arthas-bott.jar containerId:/dir</span><br></pre></td></tr></table></figure>

<p>这里需要注意，之前我们一般都是使用/bin/bash来进入命令行，这里是没有了，需要修改为/bin/sh</p>
<h4 id="MAT"><a href="#MAT" class="headerlink" title="MAT"></a>MAT</h4><p>指令有点多，写的累，看得也累，接下来还是看图片吧，这里主要讲述通过导出的hprof也就是堆栈文件，拿到MAT进行解析。我们主要是看堆栈解析里面的是否存在内存泄漏和对象实例的使用空间分析，这里看的还是很清晰明了的，我们用的最多就是这个Leak supect report和Histogram。</p>
<p>一打开某个堆栈文件，他就会问你是不是需要看是否存在内存泄漏分析，的确这个就是我们都需要看的。</p>
<p><img src="image-20210415172625652.png" alt="image-20210415172625652"></p>
<p><img src="image-20210415172929515.png" alt="image-20210415172929515"></p>
<p><img src="image-20210415173005165.png" alt="image-20210415173005165"></p>
<p><img src="image-20210415173041630.png" alt="image-20210415173041630"></p>
<p><img src="image-20210415173103066.png" alt="image-20210415173103066"></p>
<h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>相信我们大部分公司都是用的JDK8，JDK8默认使用的垃圾回收器是Parallel Scavenge +ParallelOld，如下图，现在主流的垃圾回收器基本都是CMS+ParNew或者G1，也有少部分已经用上了ZGC，它们的好不言而喻，感兴趣的话可以自行去了解下，那你清楚怎么切换CMS或者G1吗？本来还想写一次线上GC问题排查的过程，但是有点困了，下次一定。</p>
<p><img src="image-20210415174037743.png" alt="image-20210415174037743"></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>问题排查</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一次请求慢的问题排查</title>
    <url>/2021/03/13/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E8%AF%B7%E6%B1%82%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>  最近测试同事反馈测试环境卡顿频繁问题，第一时间反应可能是数据量大，查询慢所导致，但是使用Jmeter压测后发现并无异常，于是有了下面的记录。<span id="more"></span></p>
<h3 id="问题排查过程"><a href="#问题排查过程" class="headerlink" title="问题排查过程"></a>问题排查过程</h3><p> ①重现场景(使用的浏览器为chrome)</p>
<p>  经过一顿页面点击操作之后，果然出现了有一个接口返回很慢，但是该接口只是获取部门结构树，单表查询不存在查询慢的问题。F12查看该接口的请求信息，切换到 Timing tab，发现该请求的耗时如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20210317154726178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5nbGlmdTUyMA==,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>发现接口耗时最长在Stalled过程，锁定是建立链接发生了错误，接下来使用Wireshark抓包看一下到底发生了什么，下载地址可百度。</p>
<h3 id="工具准备阶段"><a href="#工具准备阶段" class="headerlink" title="工具准备阶段"></a>工具准备阶段</h3><p>由于很多人都是使用Fiddler，相信不陌生，这里阐述Wireshark的工具准备过程。</p>
<p>由于我需要抓的是https请求，需要把请求抓取到本地再由wireshark去解析，所以需要做一下配置，首先在任意位置创建两个文件，注意后缀要使用.log，如下</p>
<p><img src="https://img-blog.csdnimg.cn/20210317155537163.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>配置系统环境变量SSLKEYFILELOG，对应值为上面配置的sslkey.log的位置，如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20210317155753760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5nbGlmdTUyMA==,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>接着在wireshark的首选项里面配置文件的位置 首选项》Protocos》TLS，如下：</p>
<p><img src="https://img-blog.csdnimg.cn/2021031715595570.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5nbGlmdTUyMA==,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h3 id="开始抓包"><a href="#开始抓包" class="headerlink" title="开始抓包"></a>开始抓包</h3><p>然后在wireshark的捕获选项配置自己要抓包的接口 和 过滤规则。比如想抓取的<a href="https://baidu.com,(使用过滤规则host提示报错,我改用ip.addr)/">https://baidu.com，(使用过滤规则host提示报错，我改用ip.addr)</a></p>
<p>首先Ping一下拿到ip地址，不会的请手动敲自己。</p>
<p>然后在wireshark的过滤条件 输入 ip.addr == 百度的真实ip，如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210317160718786.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5nbGlmdTUyMA==,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>捕获到请求后入上图，框1就是耗时、协议等信息，框2就是对应的OSI信息，框3就是对应的ASCII内容。</p>
<p>回到最上面的问题，接口出了什么问题呢，下面附上一张图：</p>
<p><img src="https://img-blog.csdnimg.cn/20210317161049147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5nbGlmdTUyMA==,size_16,color_FFFFFF,t_70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>这里大家回想一下TCP三次握手的过程，首先是客户端会发送SYN要建立，服务端回一个ACK和SYNC说准备好了，可以下一步，正当客户端兴冲冲跑过来回复说我也好了(ACK)，我可是带了一点东西的(PSH)，发现服务端没反应，并且连续重试5次都没得到服务端的回应(Windows下是5次，加起来是6次)，我只能重置这个链接(RST)准备发起下一次握手请求。</p>
<p>以上情况就是我们经常听到的丢包，由于是发生在服务端回了ACK后，客户端带着PSH再请求发生的丢包，可以确定为是网络问题，这种情况让网管去处理就好了；如果wireshark显示ZEROWINDOW，那就是发送的数据太多了，接收端搞不赢，可以及时去缓冲区取数据。</p>
<p>PS:写的可能不准确，请提出纠正，这只是个人的一次记录。</p>
]]></content>
      <categories>
        <category>工作记录</category>
      </categories>
      <tags>
        <tag>问题</tag>
      </tags>
  </entry>
</search>
