---
layout: posts
title: 线上环境问题排查
date: 2021-04-15 15:44:42
tags: [JVM, 问题排查]
categories: 学习笔记
---



本篇主要是介绍一些线上排查问题的指令和工具。



### 前提

工欲善其事，必先利其器，此处列出一些常用的工具，具体情况大家可以自由选择，本文的问题都是使用这些工具来定位和分析的。

##### 命令行终端

- 标准终端类：jps、jinfo、jstat、jstack、jmap
- 功能整合类：jcmd、vjtools、arthas、greys

##### 可视化界面

- 简易：JConsole、JVisualvm、HA、GCHisto、GCViewer
- 进阶：MAT、JProfiler

命令行推荐 arthas ，可视化界面推荐 JProfiler，此外还有一些在线的平台 [gceasy](https://gceasy.io/)、[heaphero](https://heaphero.io/)、[fastthread](https://fastthread.io/) 也比较好用。

<!--more-->

### 开胃小菜

开始之前先来一到小菜，循序渐进。

#### 简单指令

##### jps

```shell
#jps  一般使用这个指令来查看当前运行的java进程,-l查看所有
jps -l
```

![image-20210415160611851](image-20210415160611851.png)



##### jinfo

```shell
#jinfo 一般用来查看某个java进程使用的jvm参数和系统属性
jinfo -sysprops pid
```

![image-20210415160504342](image-20210415160504342.png)

```shell
#查看所有jvm参数
jinfo -flags pid
```

![image-20210415160918989](image-20210415160918989.png)



##### jstat

```shell
#一般我们使用该命令来查看jvm加载的类，gc统计
jstat -class pid
```

![image-20210415161245417](image-20210415161245417.png)

```shell
#垃圾回收统计
jstat -gc pid
/*
S0C：第一个幸存区的大小
S1C：第二个幸存区的大小
S0U：第一个幸存区的使用大小
S1U：第二个幸存区的使用大小
EC：伊甸园区的大小
EU：伊甸园区的使用大小
OC：老年代大小
OU：老年代使用大小
MC：方法区大小
MU：方法区使用大小
CCSC:压缩类空间大小
CCSU:压缩类空间使用大小
YGC：年轻代垃圾回收次数
YGCT：年轻代垃圾回收消耗时间
FGC：老年代垃圾回收次数
FGCT：老年代垃圾回收消耗时间
GCT：垃圾回收消耗总时间
*/
```

![image-20210415161406384](image-20210415161406384.png)



##### jmap

```shell
#可以使用该命令来查看某个java进程的内存情况，还可以导出对应的堆栈信息
jmap -heap pid
```

![image-20210415161751600](image-20210415161751600.png)

```shell
#查看某个java进程中存活的实例数和总大小， > temp_file.txt 并输出到temp_file.txt文件里面
jmap -histo:live pid > temp_file.txt
```

![image-20210415162408153](image-20210415162408153.png)

```shell
#导出某个java进程的堆栈信息到.hprof文件，该文件可以利用MAT等工具查看
jmap -dump:live,format=b,file=temp_file.hprof pid
```





### 正餐

接下来是我们的正餐，这部分主要讲述arthas 和mat的使用，包括一些线上GC的排查。

#### arthas

arthas相信我们都不陌生，这是阿里开源的，现在才听说过的赶紧去下载用一次，附上 <a href="http://arthas.gitee.io/">arthas</a> 官网，这里的教程堪称完美，我这里就不多说了，只有几张图，方便后面我复习。

##### 操作步骤

step 1：到官网下载对应jar，使用上传命令rz上传到对应的服务器，也可以在服务器上直接使用curl下载

```shell
curl -O https://arthas.aliyun.com/arthas-boot.jar
```

step 2:  运行阿尔萨斯

```shell
java -jar arthas-boot.jar
```

![image-20210415163551814](image-20210415163551814.png)

step 3: 选择要依附的java进程，输入数字，出现下面红框表示成功

![image-20210415163702184](image-20210415163702184.png)



##### jvm指令相关

###### dashboard

```shell
#查看控制台，ctrl+c停止输出
dashboard
```

![image-20210415164048784](image-20210415164048784.png)

###### thread

```shell
#查看当前有哪些线程
thread 
```

![image-20210415164150907](image-20210415164150907.png)

###### jvm

```shell
#查看当前的jvm信息
jvm
```

![image-20210415164323897](image-20210415164323897.png)

###### sysprop

```shell
#查看和修改JVM的系统属性
sysprop
#查看某个系统属性
sysprop prop-name
#修改某个系统属性
sysprop prop-name newValue
```

![image-20210415164537300](image-20210415164537300.png)

###### sysenv

```shell
#查看JVM的环境变量
sysenv
```

![image-20210415164922657](image-20210415164922657.png)



###### vmoption

```shell
#查看和修改JVM里诊断相关的option
vmoption
#查看指定的option
vmoption option
#修改某个option的配置，一般都是用来开启PrintGCDetails等
vmoption option value
```

![image-20210415165040780](image-20210415165040780.png)

###### heapdump

```shell
#dump java heap, 类似jmap命令的heap dump功能
heapdump /tempfile.hprof
#只dump还存活的对象
heapdump --live /tmpfile.hprof
```

##### class/classloader指令相关

###### sc

```shell
#模糊搜索类
sc test.*
#输出某个类的详细信息
sc -d test.Demo
```

###### sm

```shell
#查看已加载类的方法信息
sm java.lang.String
#查看某个方法的详细
sm -d java.lang.String toString
```

###### jad

```shell
#反编译指定的类，只显示源码，并输出到文件Demo.java
jad --source-only test.Demo > /temp/Demo.java
#反编译指定的方法
jad test.Demo methodTest
```

###### mc

```shell
#内存编译java文件为class
mc /temp/Test.java
```

###### retransform 

```shell
#热加载class进jvm
retransform /temp/Test.class
#每加载一个.class文件，会记录一个entry，-l命令查看所有entry
retransform -l
#删除指定id的entry
retransform -d id
#显式触发，让这个类立刻起作用
retransform --classPattern test.Demo

#如果是想消除这个类的影响，需要清除这个类对应的所有entry，然后重新显式触发
```



##### 在docker中使用Arthas

​	现在很多公司都是使用Docker来部署项目，使用jps命令查看不到当前哪些java进程，这样就使用不了Arthas，接下来进行一些小调整，使得能够在Docker容器里面使用Arthas。

​	首先是调整一下Dockerfile，我们一般使用的是如下

```shell
#仅包含java运行环境，没有java自带的一些工具
FROM java:8-jre

#需要调整为如下
FROM openjdk:8-jdk
#或者
FROM openjdk:8-jdk-alpine
```

进入容器内部，下载Arthas并执行

```shell
docker exec -it arthas-demo /bin/sh -c "java -jar /opt/arthas/arthas-boot.jar"
#或者把下载好的arthas复制到容器内部，再使用java -jar来运行
docker cp arthas-bott.jar containerId:/dir
```

这里需要注意，之前我们一般都是使用/bin/bash来进入命令行，这里是没有了，需要修改为/bin/sh



#### MAT

指令有点多，写的累，看得也累，接下来还是看图片吧，这里主要讲述通过导出的hprof也就是堆栈文件，拿到MAT进行解析。我们主要是看堆栈解析里面的是否存在内存泄漏和对象实例的使用空间分析，这里看的还是很清晰明了的，我们用的最多就是这个Leak supect report和Histogram。

一打开某个堆栈文件，他就会问你是不是需要看是否存在内存泄漏分析，的确这个就是我们都需要看的。

![image-20210415172625652](image-20210415172625652.png)

![image-20210415172929515](image-20210415172929515.png)

![image-20210415173005165](image-20210415173005165.png)

![image-20210415173041630](image-20210415173041630.png)

![image-20210415173103066](image-20210415173103066.png)





### 写在最后

相信我们大部分公司都是用的JDK8，JDK8默认使用的垃圾回收器是Parallel Scavenge +ParallelOld，如下图，现在主流的垃圾回收器基本都是CMS+ParNew或者G1，也有少部分已经用上了ZGC，它们的好不言而喻，感兴趣的话可以自行去了解下，那你清楚怎么切换CMS或者G1吗？本来还想写一次线上GC问题排查的过程，但是有点困了，下次一定。

![image-20210415174037743](image-20210415174037743.png)