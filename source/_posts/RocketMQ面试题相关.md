---
layout: posts
title: RocketMQ面试题相关
date: 2021-04-16 15:46:33
tags: [RocketMQ]
categories: 面试篇
---

图为自己画的，错误之处请指出，在线图  <a href="https://www.processon.com/view/link/607952ccf346fb647a5702f3?pw=rifu">点我</a> 。该文档持续更新...<!-- more -->

![image-20210416171452462](image-20210416171452462.png)

#### ①如何保证消息可靠性？

这里可分为三个方面来回答，这里主要考察的是消息传递的可靠性，不会发生消息丢失的情况。RabbitMQ的回答也是如此。

##### 生产者丢失

消息发送也分为同步发送和异步发送，由于同步发送不会发生丢失的问题，这里主要讲异步发送。

异步发送分为两个方式：异步有回调和异步无回调，无回调的方式，生产者发送完后不管结果可能就会造成消息丢失，而通过异步发送+回调通知+本地消息表的形式我们就可以做出一个解决方案。以下单的场景举例。

1.下单后先保存本地数据和MQ消息表，这时候消息的状态是发送中，如果本地事务失败，那么下单失败，事务回滚。

2.下单成功，直接返回客户端成功，异步发送MQ消息

3.MQ回调通知消息发送结果，对应更新数据库MQ发送状态

4.JOB轮询超过一定时间（时间根据业务配置）还未发送成功的消息去重试

5.在监控平台配置或者JOB程序处理超过一定次数一直发送不成功的消息，告警，人工介入。

##### MQ丢失

就是Master收到了消息，此时数据还在内存中，但是还没同步消息到Slave时候发生了宕机，导致的数据不同步。

RocketMQ分为同步刷盘和异步刷盘两种方式，默认的是异步刷盘，就有可能导致消息还未刷到硬盘上就丢失了，可以通过设置为同步刷盘的方式来保证消息可靠性，这样即使MQ挂了，恢复的时候也可以从磁盘中去恢复消息，这个需要考察业务需要。

##### 消费者丢失

消费者刚收到消息，但是还没消费发生宕机，MQ认为该消息已经消费不会重发。消费端需要设置消息回调，就是消费成功需要回传ack给MQ，让其更新消息的消费状态，在RocketMQ里面，消费者会更新offset给MQ，告知当前的消费位置。



#### ②RocketMQ是如何保证高可靠和高可用的？

我们知道 RocketMQ 是一款高性能、高可靠的分布式消息中间件，高性能和高可靠是很难兼得的。因为要保证高可靠，那么数据就必须持久化到磁盘上，将数据持久化到磁盘，那么可能就不能保证高性能了。

RocketMQ 在兼容这两方面做的不错，先从磁盘说起，**「现代的磁盘都是高性能的，写速度并不一定比网络的数据传输速度慢」**。比如 SSD 固态硬盘在 M.2 NVMe协议下，顺序写的速度可以达到 1500 MB/s，就算是普通磁盘，如果性能比较高的话，顺序写的速度可以达到 450MB/s~600MB/s。

在顺序写的情况下是这速度，但是不人为控制的话，磁盘采用的是随机写，在随机写的情况下，磁盘的写入速度急速下降，**「磁盘的随机写速度可能只有几百KB/s，这远远要慢于网络传输速度，所以它并不能满足高性能的要求」**。

RocketMQ 在持久化的设计上，采取的是**「消息顺序写、随机读的策略」**，利用磁盘顺序写的速度，让磁盘的写速度不会成为系统的瓶颈。并且采用 MMPP 这种“零拷贝”技术，提高消息存盘和网络发送的速度。极力满足 RocketMQ 的高性能、高可靠要求。



#### ③Broker是如何保存数据的呢？

RocketMQ主要的存储文件包括commitlog文件、consumequeue文件、indexfile文件。

![image-20210417105606013](image-20210417105606013.png)

Broker在收到消息之后，会把消息保存到commitlog的文件当中，而同时在分布式的存储当中，每个broker都会保存一部分topic的数据，同时，每个topic对应的messagequeue下都会生成consumequeue文件用于保存commitlog的物理位置偏移量offset，indexfile中会保存key和offset的对应关系。

![890b041845970ff38244f677e51eb441](890b041845970ff38244f677e51eb441.png)

CommitLog文件保存于${Rocket_Home}/store/commitlog目录中，从图中我们可以明显看出来文件名的偏移量，每个文件默认1G，写满后自动生成一个新的文件。

![7c8eb3d9a6024e90346a88d7618757fd](7c8eb3d9a6024e90346a88d7618757fd.png)

由于同一个topic的消息并不是连续的存储在commitlog中，消费者如果直接从commitlog获取消息效率非常低，所以通过consumequeue保存commitlog中消息的偏移量的物理地址，这样消费者在消费的时候先从consumequeue中根据偏移量定位到具体的commitlog物理文件，然后根据一定的规则（offset和文件大小取模）在commitlog中快速定位。
![图片](5daa5e005b9ae74b51ea67756a97f9fc.png)



#### ④数据刷盘的方式

因为操作系统 PAGECACHE 的存在，PageCache是OS对文件的缓存，用于加速对文件的读写，所以一般都是先写入到 PAGECACHE 中，然后再持久化到磁盘上。我们熟悉的其他组件，MySQL、Redis 等都是如此。RocketMQ 也不列外。

在 RocketMQ 中提供了**「同步刷盘」**和**「异步刷盘」**两种刷盘方式，可以通过 Broker 配置文中中的 flushDiskType 参数来设置（SYNC_FLUSH、ASYNC_FLUSH）。

**「异步刷盘方式（默认）」**：消息写入到内存的 PAGECACHE中，就立刻给客户端返回写操作成功，当 PAGECACHE 中的消息积累到一定的量时，触发一次写操作，将 PAGECACHE 中的消息写入到磁盘中。这种方式**「吞吐量大，性能高，但是 PAGECACHE 中的数据可能丢失，不能保证数据绝对的安全」**。

**「同步刷盘方式」**：消息写入内存的 PAGECACHE 后，立刻通知刷盘线程刷盘，然后等待刷盘完成，刷盘线程执行完成后唤醒等待的线程，返回消息写成功的状态。这种方式**「可以保证数据绝对安全，但是吞吐量不大」**。



#### ⑤消息堆积如何解决？

* 生产者端：生产消息的速度过快，限制生产消息的频率。
* 消费者端：消息太多，消费不过来，可以考虑扩容来提高消费效率。
* Broker:内存是否足够大？如果Page Cache够大的话，可以考虑提高Consumer拉取消息的频率。



#### ⑥RocketMQ 为什么会重复消费？讲下 RocketMQ 造成重复消费的底层实现原理？





#### ⑦如何保证消息消费的顺序性？

首先多个queue只能保证一个queue消费的顺序性，而且是队列结构，天然的顺序性FIFO，我们可以在发送消息的时候把需要顺序消费的消息发送到一个queue，在消费端也只开一个消费者。

如何保证消息都发送到同一个queue，在使用producer发送消息的时候重写MessageQueueSelector接口

```java
Message message = new Message("orderTopic", ("hello!" + i).getBytes());
producer.send(
    // 要发的那条消息
    message,
    // queue 选择器 ，向 topic中的哪个queue去写消息
    new MessageQueueSelector() {
        // 手动 选择一个queue
        @Override
        public MessageQueue select(
            // 当前topic 里面包含的所有queue
            List<MessageQueue> mqs,
            // 具体要发的那条消息
            Message msg,
            // 对应到 send（） 里的 args，也就是2000前面的那个0
            Object arg) {
            // 向固定的一个queue里写消息，比如这里就是向第一个queue里写消息
            if (Integer.parseInt(arg.toString()) % 2 == 0) {
                return mqs.get(0);
            } else {
                return mqs.get(1);
            }
        }
    },
    // 自定义参数：0
    // 2000代表2000毫秒超时时间
    0, 2000);
```





